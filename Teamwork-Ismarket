//+------------------------------------------------------------------+
//|                                              Naver Give up 6.mq5 |
//|                                  Copyright 2025, MetaQuotes Ltd. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, MetaQuotes Ltd."
#property link      "https://www.mql5.com"
#property version   "1.00"
#property strict
#property version   "4.00"
#property description "Advanced Recovery System with Cooperative Strategy Management"

// --- Includes ---
#include <Trade\Trade.mqh>
#include <Trade\PositionInfo.mqh>
#include <Trade\AccountInfo.mqh>


CTrade trade;

// --- Globals ---
datetime lastBarTime = 0;
bool newBar = false;
CPositionInfo positionInfo;
CAccountInfo accountInfo;
double pointValue = 0;
int recoveryLayerCount = 0;
int currentFightingPhase = 0;
double phaseStartEquity = 0;
datetime phaseStartTime = 0;
int fightingTradesCount = 0;
double totalFightingProfit = 0;
double TotalPortfolioProfit = 0.0;
bool recoveryModeActive = false;
datetime recoveryStartTime = 0;
double recoveryProgress = 0.0;
string LastSystemMessage = "";
datetime MessageTime = 0;


// --- Breakeven Visual Variables ---
string beLineName = "Breakeven_Line";
double currentBreakevenPrice = 0;
bool breakevenLineCreated = false;

// --- Fixes & Helpers ---
const int WRONG_VALUE_CONST = -1;
enum ENUM_POSITION_TYPE_CUSTOM 
{
   POSITION_TYPE_BUY_CUSTOM = 0,
   POSITION_TYPE_SELL_CUSTOM = 1,
   POSITION_TYPE_INVALID = -1
};
enum ENUM_SIGNAL_STRENGTH
{
   SIGNAL_NONE = 0,
   SIGNAL_WEAK = 1,
   SIGNAL_MEDIUM = 2,
   SIGNAL_STRONG = 3
};

enum ENUM_TREND_DIRECTION
{
    TREND_NONE,    // 0 - ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô
    TREND_UP,      // 1 - ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏Ç‡∏≤‡∏Ç‡∏∂‡πâ‡∏ô
    TREND_DOWN,    // 2 - ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏Ç‡∏≤‡∏•‡∏á
    TREND_SIDEWAYS // 3 - ‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô
};
// System modes
enum ENUM_SYSTEM_MODE
{
   MODE_NORMAL,
   MODE_RECOVERY,
   MODE_HIGH_RISK
};
// üî• ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô - ‡πÉ‡∏ä‡πâ‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏ê‡∏≤‡∏ô
enum ENUM_MARKET_REGIME {
   MARKET_REGIME_RANGING_CALM,        // 0
   MARKET_REGIME_TRENDING_STRONG,     // 1  
   MARKET_REGIME_BREAKOUT_POTENTIAL,  // 2
   MARKET_REGIME_RANGING_VOLATILE,    // 3 (‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà)
   MARKET_REGIME_TRENDING_WEAK,       // 4 (‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà)
   MARKET_REGIME_NORMAL               // 5
};
ENUM_MARKET_REGIME currentMarketRegime = MARKET_REGIME_RANGING_CALM;
ENUM_SYSTEM_MODE SystemMode = MODE_NORMAL;
ENUM_MARKET_REGIME g_currentRegime = MARKET_REGIME_NORMAL;


// --- Magic Numbers ---
#define MAGIC_TEST_SIMPLE 1000 
#define MAGIC_TREND_SCALP 1001
#define MAGIC_SCALP1      1002
#define MAGIC_SCALP1_HF   1003
#define MAGIC_SCALP2      3003
#define MAGIC_SCALP3      8008
#define MAGIC_RECOVERY    2002    
#define MAGIC_INDIVIDUAL  2011    
#define MAGIC_ORPHAN      2012    
#define MAGIC_HEDGE       6006
#define MAGIC_AI_NEWS     5005
#define MAGIC_AI_TREND    5006
#define MAGIC_BREAKOUT    4004
#define MAGIC_COUNTER     7007
#define MAGIC_MAIN        9009

#define VOLATILITY_THRESHOLD_LOW 0.002  // 0.2%
#define VOLATILITY_THRESHOLD_HIGH 0.008 // 0.8%
#define DIRECTION_UP 1
#define DIRECTION_DOWN -1
#define DIRECTION_NEUTRAL 0
//--------------//



// üìç ‡πÉ‡∏ô‡∏™‡πà‡∏ß‡∏ô Global Variables ‡∏´‡∏£‡∏∑‡∏≠ Input Parameters
input group "=== MAGIC NUMBERS FOR RECOVERY SYSTEMS ==="
input int MAGIC_INDIVIDUAL_RECOVERY           = 8881;    // Individual Recovery
input int MAGIC_STEPUP_RECOVERY               = 8882;    // Step-Up Recovery  
input int MAGIC_COUNTER_RECOVERY              = 8883;    // Counter Position
input int MAGIC_HEDGE__RECOVERY               = 8884;    // Emergency Hedge
input int MAGIC_ORPHAN__RECOVERY              = 8885;    // Orphan Management
input int MAGIC_ULTIMATE__RECOVERY            = 8886;    // Ultimate Fighting

// --- Inputs ---
input group "=== Main Settings ==="
input double MaxRiskPercent        = 2.0;
input double BaseLot               = 0.01;
input double MaxLot                = 0.50;
input int    MaxOpenOrders         = 6;
input bool   AutoLot               = true;
input int    MinDistance           = 10;      
input double RiskPercent           = 2.0;     
input bool   UseDynamicDistance    = true;    
input bool   UseTrendFilter        = true;    

input group "=== COOPERATIVE TARGET SYSTEM ==="

input double GlobalTargetProfit      = 50.0;
input double StrategyWeight_Scalp1   = 0.3;
input double StrategyWeight_Scalp2   = 0.25;
input double StrategyWeight_Scalp3   = 0.2;
input double StrategyWeight_Trend    = 0.15;
input double StrategyWeight_Breakout = 0.1;
input bool   EnableCooperativeSystem = true;

input group "=== TARGET PROFITS (NEVER GIVE UP MODE) ==="
input double Scalp2_TargetProfit     = 15.0;
input double Scalp3_TargetProfit     = 10.0;
input double Recovery_TargetProfit   = 25.0;
input double Breakout_TargetProfit   = 100.0;
input double BaseCollaborativeTarget = 100.0;      

input group "=== Debug Settings ==="
input bool   EnableDebugMode    = true;
input bool   ForceTrading       = false;
input int    DebugPrintLevel    = 2;

input group "=== Test & Manual Settings ==="  
input int    Test_TP_Points        = 30;
input int    Test_SL_Points        = 15;
input int    LowRisk_TP_Points     = 50;

input group "=== Independent Strategies ==="
input bool   BreakoutStrategy      = true;
input int    TP_Points_Breakout    = 1500;
input ENUM_TIMEFRAMES BO_Timeframe = PERIOD_M15;
input bool   UseMultiTimeframe     = true;
input bool   UseVolumeConfirmation = true;
input double MinBreakoutStrength   = 1.5;

input bool   AI_NewsTrading_Enabled    = false;
input bool   AI_TrendTrading_Enabled   = false;
input long   AI_News_Magic             = 5005;
input long   AI_Trend_Magic            = 5006;

input group "=== Simple Trend Scalp Settings ==="
input bool   SimpleTrendScalpEnabled = true;
input int    TrendScalp_TP_Points = 50;
input int    TrendScalp_SL_Points = 30;
input int    TrendEMA_Period = 20;
input double TrendStrength_Threshold = 0.0002;
input bool   EnableTrendScalpInRange = false;
input bool   EnableTrendScalpInWeakTrend = true;
input bool   EnableTrendScalpInBreakout = true;
input double TrendScalp_Base_Lot_Multiplier = 1.0;

input group "=== Scalp1 Strategy ==="
input bool   Scalp1Enabled         = true;
input int    Scalp1_TP_Points       = 20;
input int    Scalp1_SL_Points       = 15;
input int    Scalp1_MaxPositions    = 3;
input bool   Scalp1_UsePriceAction  = true;
input bool   EnableScalp1InVolatileMarket = false;
input bool   EnableScalp1InBreakout = true;
input bool   EnableScalp1InStrongTrend = true;
input double Scalp1_Base_Lot_Multiplier = 1.0;

input group "=== Scalp1 High-Frequency Settings ==="
input bool   Scalp1AdvanceEnabled   = true;
input int    Scalp1_MaxPositions1   = 5;
input int    Scalp1_Quick_TP        = 12;
input int    Scalp1_Quick_SL        = 8;
input bool   Scalp1_Aggressive      = true;
input double Scalp1_Lot_Multiplier  = 1.0;

input group "=== Scalp2 Strategy ==="
input bool   Scalp2Enabled         = true;
input double MinLossToHelp         = 2.0;
input double Scalp2ProfitBuffer    = 2.0;
input bool   WaitNewBarForScalp2   = true;
input int    Scalp2_TP_Points      = 60;
input int    Scalp2_SL_Points      = 0;
input double Scalp2_LotMultiplier = 1.0;
input double MaxHelpLot = 0.05;
input double MinHelpLot = 0.01;
input bool UseFixedLot = true;

input group "=== Scalp3 Integrated Settings ==="
input bool   Scalp3_Enabled         = true;
input double localScalp3Trigger = 5.0;
input double localScalp3Multiplier = 1.8;
input int    Scalp3_MaxActivePairs  = 3;
input bool   Scalp3_UseSignal       = false;
input int    Scalp3_MaxHelpPerMain  = 1;

input group "=== Close Conditions ==="  
input bool   Close_OnTarget         = true;
input bool   Close_OnBreakEven      = true;
input bool   Close_OnHelpProfit     = true;
input bool   Close_OnReversal       = false;

input group "=== Continuous Battle System ==="
input bool   EnableContinuousBattle = true;
input double MinEquityToTrade      = 100.0;
input bool   NeverGiveUpMode       = true;
input int    MaxTotalPositions     = 8;
input double localAggressiveMult = 2.0;

input group "=== Step-Up Recovery System ==="
input bool   StepUpRecoveryEnabled = true;
input double RecoveryStartLot      = 0.01;
input double LotStepSize           = 0.01;
input double MaxRecoveryLot        = 0.40;
input int    localMaxSteps         = 10;
input double RecoveryTrigger       = 15.0;
input double RecoveryTarget        = 5.0;
input int    RecoveryDistance      = 30;



input group "=== Counter-Position Management ==="
input bool   EnableCounterPosition   = true;
input double localCounterTrigger = 25.0;
input double CounterProfitTarget     = 15.0;
input double localCounterMultiplier = 1.2;
input int    localMaxCounter = 3;
input double localCounterSL = 50.0;      // SL ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡πÉ‡∏ô points
input double localCounterTP = 100.0;     // TP ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡πÉ‡∏ô points

input group "=== Individual Recovery Set ==="
input bool   EnableIndividualRecovery = true;
input double IndividualRecoveryTrigger = 8.0;
input double localRecoveryMultiplier = 1.5;
input int    localMaxRecovery = 5;
input bool   UseSetTP = true;
input double SetTP_Fixed = 10.0;
input double SetTP_DynamicPercent = 0.0;
input double MinSetTP = 5.0;
input double MaxSetTP = 50.0;
input bool   UseAdaptiveTP = false;
input double TP_PerRecoveryBonus = 2.0;
input bool   UseTimeBasedTP = false;
input int    TP_TimeFactorMinutes = 60;
input double TP_TimeBonus = 0.1;
input int    Individual_MaxPerCycle    = 1;
input bool   Individual_WaitForClose   = true;
input int    Individual_CooldownSec    = 10;

input group "=== Emergency Hedge ==="
input bool   UseEmergencyHedge     = true;
input double EmergencyHedgeThreshold = 50.0;
input double HedgeLotMultiplier    = 1.5;
input double HedgeProfitTargetUSD  = 20.0;

input group "=== Smart Portfolio Closing ==="  
input double SmartCloseProfitTarget = 50.0;
input int    SmartCloseMinPositions = 3;
input double SmartCloseLotMultiplier = 1.3;
input int    SmartCloseTPBuffer = 5;

input group "=== ULTIMATE FIGHTING MODE ==="
input bool   UltimateFightingMode    = true;
input double FightingAggressionLevel = 1.5;
input int    MaxFightingPhases       = 5;
input double Phase1Trigger           = 10.0;
input double Phase2Trigger           = 20.0;
input double Phase3Trigger           = 30.0;
input double Phase4Trigger           = 40.0;
input double Phase5Trigger           = 50.0;

input group "=== Display ==="
input bool   ShowDashboard         = true;

input group "=== Universal Orphan Management ==="
input bool   EnableUniversalOrphan = true;
input double localOrphanTrigger = 10.0;
input int    localMaxOrphanSteps = 3;
input bool   OrphanAutoCloseProfit = true;
input double OrphanCloseProfit = 5.0;
input int    MaxOrphansPerCycle     = 1;
input int    OrphanProcessDelay     = 10;
input bool   OrphanPrioritySystem   = true;
input double OrphanMaxRiskPerTrade  = 1.0;
input int    Orphan_MaxPerCycle        = 1;
input bool   Orphan_WaitForProfit      = true;

input group "=== Recovery Safety Mechanisms ==="
input bool   UseRecoverySafety     = true;
input double MaxTotalLoss          = 100.0;
input double MaxDrawdownPercent    = 20.0;
input int    MaxConsecutiveLosses  = 3;
input bool   AutoStopRecovery      = true;
input double SafetyStopThreshold   = 80.0;

// üìç ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏ô‡∏™‡πà‡∏ß‡∏ô Input Parameters
input group "=== RECOVERY COOPERATION SYSTEM ==="
input double Recovery_StartLevel    = -200.0;  // ‡πÄ‡∏£‡∏¥‡πà‡∏° Recovery ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏ñ‡∏∂‡∏á
input double Recovery_StopLevel     = -50.0;   // ‡∏´‡∏¢‡∏∏‡∏î Recovery ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡πÄ‡∏´‡∏•‡∏∑‡∏≠
input bool   EnableRecoveryCoop     = true;    // ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Recovery ‡∏£‡πà‡∏ß‡∏°‡∏°‡∏∑‡∏≠
input bool   UseMarketAnalysis    = true;     // ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏ï‡∏•‡∏≤‡∏î
input bool   AllowVolatileTrading = false;    // ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÄ‡∏ó‡∏£‡∏î‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
input bool   TradeDuringNews      = false;    // ‡πÄ‡∏ó‡∏£‡∏î‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡∏Ç‡πà‡∏≤‡∏ß‡πÄ‡∏®‡∏£‡∏©‡∏ê‡∏Å‡∏¥‡∏à
input double MaxLossForNewTrade = -50.0;
input int    MaxAllowedSpread     = 25;       // Spread ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï
input int    MaxRangeOrders       = 3;        // ‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î Sideway
input double MaxRangeDrawdown     = 20.0;     // ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡πÉ‡∏ô Range Trading
input bool   UseHedgeInVolatileMarket = true; // ‡πÉ‡∏ä‡πâ Hedge ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
input double MaxDrawdown          = 100.0;
input int    PartialClosePct      = 50;
input int    MinTradeDistance         = 50;        // ‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå (points)
input bool   CheckPreviousOrderLevel  = true;      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤
input bool  EnableMarketAdaptiveRecovery = true; // ‡∏õ‡∏£‡∏±‡∏ö Recovery ‡∏ï‡∏≤‡∏°‡∏ï‡∏•‡∏≤‡∏î
input bool  AllowHighVolatilityTrading = false;
input bool AutoCalculateBaseTarget = true;
//input double TargetMultiplier = 1.02;
input double TargetPercentage = 2.0;  

input group "=== Breakout Strategy Regime Settings ==="
input bool EnableBreakoutInStrongTrend = true;
input bool EnableBreakoutInVolatileMarket = false;
input bool EnableBreakoutInCalmMarket = true;
input bool EnableBreakoutInWeakTrend = true;
input bool UseStopLossInBreakout = true;
input int SL_Points_Breakout = 50;

// --- Cooperative System Variables ---
struct StrategyStatus {
    string name;
    double currentProfit;
    double targetProfit;
    int positions;
    bool isActive;
    double contribution;
    double progress;
    string missionTeam;
    double missionProgress;
};

double g_BaseCollaborativeTarget;

bool currentEnableCooperativeSystem = true;
string strategyMissionTeam[11];
double strategyMissionProgress[11];

// üìç ‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏® Mission structure
struct MissionData {
    double lotSize;
    bool missionCompleted;
    double totalProgress;
    int activeTeamsCount;
};

MissionData Mission;

StrategyStatus strategies[5];
double totalCollaborativeProfit = 0;
double collaborativeTarget = 0;
bool cooperativeSystemInitialized = false;

// --- Global Variables for Target Tracking ---
double scalp2TotalProfit = 0;
double scalp3TotalProfit = 0;
double recoveryTotalProfit = 0;
double breakoutTotalProfit = 0;
double Current_Scalp1_Lot_Multiplier = 1.0;
double Current_Scalp2_LotMultiplier = 1.0;
int Current_TrendScalp_TP_Points = 50;
double LastRSIValue = 50.0; 


int ema9_handle;
int ema21_handle;
int ema50_handle;
int ema9_handle_h1, ema21_handle_h1;
int ema9_handle_m5, ema21_handle_m5; // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö timeframe ‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
int rsi_handle_h1, stoch_handle_h1; // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö indicator ‡∏≠‡∏∑‡πà‡∏ô‡πÜ
int ema9_handle_m15, ema21_handle_m15;
int ema50_handle_m15;
int ema200_handle;



// ‚úÖ ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£ reset
double Original_Scalp1_Multiplier = 1.0;
double Original_Scalp2_Multiplier = 1.0;
int Original_Trend_TP = 50;

// --- Recovery Safety Variables ---
int consecutiveLosses = 0;
double maxTotalLoss = 0;
bool recoveryStopped = false;

// --- Counter Position Variables ---
int counterPositionsCount = 0;

// --- Battle System Variables ---
bool isInBattleMode = false;
int battlePhase = 0;
double lastEquity = 0;

// --- New: Variables for Independent Strategies ---
datetime lastBreakoutCheck = 0;
datetime lastAICheck = 0;
bool newBarBreakout = false;
bool newBarAI = false;

// --- Recovery Enhancement Variables ---
struct RecoveryStep {
   int step;
   double lot;
   datetime openTime;
   double openEquity;
   bool isSuccessful;
   double profitTarget;
};

RecoveryStep recoveryHistory[100];
int failedRecoveryCount = 0;
datetime lastRecoveryTime = 0;
double totalRecoveryProfit = 0;
int successfulRecoveries = 0;

// --- Scalp3 Integrated Variables ---
struct TradingPair {
    ulong mainTicket;
    ulong helpTicket;
    string symbol;
    double currentProfit;
    double targetProfit;
    bool isActive;
};

int scalp3HelpOperations = 0;
TradingPair tradingPairs[50];
int totalTradingPairs = 0;

// --- Individual Recovery Set Management ---
struct RecoverySet {
   int setNumber;
   ulong mainTicket;
   ulong subTickets[20];
   int subCount;
   double mainProfit;
   double subsProfit;
   double totalProfit;
   bool isCompleted;
   datetime createdTime;
};

RecoverySet recoverySets[50];
int totalRecoverySets = 0;
int nextSetNumber = 1;

// --- Additional Recovery Set Variables ---
struct RecoverySetOld {
   ulong mainTicket;
   ulong recoveryTickets[10];
   int recoveryCount;
   datetime openTime;
   double targetProfit;
   bool isClosed;
   double setTP;
};
RecoverySetOld recoverySetsOld[100];
int totalSets = 0;

// --- Orphan Management ---
struct UniversalOrphan {
    ulong ticket;
    string symbol;
    ENUM_POSITION_TYPE type;
    double volume;
    double openPrice;
    datetime openTime;
    int recoveryCount;
    double totalProfit;
    string originalStrategy;
    long originalMagic;
};

int totalUniversalOrphans = 0;
UniversalOrphan universalOrphans[100];
datetime lastOrphanProcessTime = 0;
int currentOrphanIndex = 0;
bool isProcessingOrphan = false;
datetime lastOrphanHelpTime[100]; 
int orphanHelpAttempts[100];      
bool orphanStopped[100];  
int currentIndividualProcessCount = 0;
int currentOrphanProcessCount = 0;
datetime lastIndividualCycleTime = 0;
datetime lastOrphanCycleTime = 0;
bool individualCycleCompleted = true;
bool orphanCycleCompleted = true;

struct OrphanJob {
    int jobId;
    ulong mainTicket;
    ulong orphanTickets[20];
    int orphanCount;
    double targetProfit;
    datetime createdTime;
    bool isCompleted;
    string originalStrategy;
};

OrphanJob activeOrphanJobs[10];
int totalActiveJobs = 0;
int nextJobId = 1;

bool needOrphanMonitoring = false;
datetime lastOrphanCheck = 0;
int orphanCheckInterval = 1;
int normalCheckInterval = 60;

//----


datetime lastMarketConditionCheck = 0;
int marketConditionScore = 0;
//double netMomentum = 0;

ulong g_ticket;
ulong g_currentTicket;       // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å ticket
double g_netMomentum;        // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å netMomentum  
string g_missionId;          // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å g_missionId

int CountBuy = 0;
int CountSell = 0;
int MaxTrade = 5;

double GetNetMomentum();
bool g_EnableCounterPosition = true;

double currentVolatility = 0;
int currentSpread = 0;
double currentTrendStrength = 0.5;

double currentRecoveryMultiplier = 1.5;
int currentMaxRecovery = 4;
// ‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ global (‡∏ó‡∏µ‡πà‡∏™‡πà‡∏ß‡∏ô‡∏ö‡∏ô‡∏Ç‡∏≠‡∏á‡πÑ‡∏ü‡∏•‡πå)
double g_TP_Multiplier = 1.0;
double g_Lot_Multiplier = 1.0;
int g_Max_Orders = 5;
bool g_Use_Grid = true;
bool g_Trend_Only = false;
bool g_Strict_SL = false;


// ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ strategy weights
bool currentEnableCounterPosition = EnableCounterPosition;
double currentStrategyWeight_Trend = StrategyWeight_Trend;
double currentStrategyWeight_Breakout = StrategyWeight_Breakout;
double currentStrategyWeight_Scalp1 = StrategyWeight_Scalp1;
double currentStrategyWeight_Scalp2 = StrategyWeight_Scalp2;
double currentStrategyWeight_Scalp3 = StrategyWeight_Scalp3;
bool currentEnableIndividualRecovery = EnableIndividualRecovery;
bool currentStepUpRecoveryEnabled = StepUpRecoveryEnabled;

//-------------------HEAD----------------------------------//
// üìç ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà
void UpdatePortfolioHealth() 
{
   TotalPortfolioProfit = CalculateTotalProfit();
   
   if(!EnableRecoveryCoop) return;
   
   // ‡πÄ‡∏Ç‡πâ‡∏≤‡πÇ‡∏´‡∏°‡∏î Recovery
   if(TotalPortfolioProfit <= -Recovery_StartLevel && SystemMode != MODE_RECOVERY) 
   {
      SystemMode = MODE_RECOVERY;
      Print("üÜò SYSTEM ENTERING RECOVERY MODE - Portfolio: $" + DoubleToString(TotalPortfolioProfit, 2));
      
      if(cooperativeSystemInitialized) 
      {
         recoveryModeActive = true;
         Print("ü§ù NOTIFYING COOPERATIVE SYSTEM - Recovery Mode Activated");
      }
   } 
   // ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÇ‡∏´‡∏°‡∏î Recovery
   else if(TotalPortfolioProfit >= Recovery_StopLevel && SystemMode == MODE_RECOVERY) 
   {
      SystemMode = MODE_NORMAL; 
      Print("‚úÖ SYSTEM RETURNING TO NORMAL MODE - Portfolio: $" + DoubleToString(TotalPortfolioProfit, 2));
      
      if(cooperativeSystemInitialized) 
      {
         recoveryModeActive = false;
         Print("ü§ù NOTIFYING COOPERATIVE SYSTEM - Recovery Mode Ended");
      }
   }
}

//-----------------------------------//
string TicketToStr(ulong ticket)
{
   return StringFormat("%I64u", ticket);
}

// Safer SymbolInfoDouble reader (helper) - returns false if not available
bool SafeSymbolInfoDouble(const string symbol, ENUM_SYMBOL_INFO_DOUBLE tag, double &out)
{
   return SymbolInfoDouble(symbol, tag, out);
}

// Safe get integer
long SafeSymbolInfoInteger(const string symbol, ENUM_SYMBOL_INFO_INTEGER tag)
{
   return SymbolInfoInteger(symbol, tag);
}

// Detect if symbol is XAU-like (common names)
bool IsSymbolXAU(const string symbol)
{
   string s = symbol;
   StringToUpper(s);
   if(StringFind(s, "XAU") != -1 || StringFind(s, "GOLD") != -1) return true;
   return false;
}

// Get contract size (safe fallback)
double GetContractSizeSafe(const string symbol)
{
   double cs = 0.0;
   if(SafeSymbolInfoDouble(symbol, SYMBOL_TRADE_CONTRACT_SIZE, cs) && cs > 0) return cs;
   if(IsSymbolXAU(symbol)) return 100.0;
   return 100000.0;
}

// Universal pip (price movement unit) in PRICE terms (eg 0.0001 for EURUSD, 0.01 for XAU)
double GetPipSize(const string symbol)
{
   if(IsSymbolXAU(symbol)) return 0.01;
   double point = 0.0;
   SafeSymbolInfoDouble(symbol, SYMBOL_POINT, point);
   int digits = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);
   if(digits == 5 || digits == 3) return point * 10.0;
   return point;
}

// Convert pips (integer or fractional) to PRICE movement
double PipsToPriceMove(double pips, const string symbol)
{
   double pipSize = GetPipSize(symbol);
   return pips * pipSize;
}

double GetAsk(const string symbol)
{
   double ask = 0.0;
   if(SafeSymbolInfoDouble(symbol, SYMBOL_ASK, ask)) return ask;
   return SymbolInfoDouble(symbol, SYMBOL_BID);
}

double GetBid(const string symbol)
{
   double bid = 0.0;
   if(SafeSymbolInfoDouble(symbol, SYMBOL_BID, bid)) return bid;
   return SymbolInfoDouble(symbol, SYMBOL_ASK);
}

// Get TP price (BUY/SELL) in normalized digits
double GetTPPriceUniversal(bool isBuy, double tp_pips, const string symbol = NULL)
{
   string sym = (symbol==NULL) ? _Symbol : symbol;
   double price_move = PipsToPriceMove(tp_pips, sym);
   int digits = (int)SymbolInfoInteger(sym, SYMBOL_DIGITS);
   double price = 0.0;
   if(isBuy)
   {
      double ask = GetAsk(sym);
      price = ask + price_move;
   }
   else
   {
      double bid = GetBid(sym);
      price = bid - price_move;
   }
   return NormalizeDouble(price, digits);
}

// Get SL price universal (optional)
double GetSLPriceUniversal(bool isBuy, double sl_pips, const string symbol = NULL)
{
   string sym = (symbol==NULL) ? _Symbol : symbol;
   double price_move = PipsToPriceMove(sl_pips, sym);
   int digits = (int)SymbolInfoInteger(sym, SYMBOL_DIGITS);
   double price = 0.0;
   if(isBuy)
   {
      double ask = GetAsk(sym);
      price = ask - price_move;
   }
   else
   {
      double bid = GetBid(sym);
      price = bid + price_move;
   }
   return NormalizeDouble(price, digits);
}

//+------------------------------------------------------------------+
//| Execute Simple Trend Scalp                                      |
//+------------------------------------------------------------------+
void ExecuteSimpleTrendScalp(ENUM_MARKET_REGIME regime = MARKET_REGIME_NORMAL)
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö regime ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏™‡πà‡∏á‡∏°‡∏≤
    if(regime == MARKET_REGIME_NORMAL) 
    {
        regime = DetectMarketRegime();
    }
    
    if(!SimpleTrendScalpEnabled) 
    {
        DebugPrint(3, "Simple Trend Scalp disabled - skipping");
        return;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Trend Scalp ‡∏Ñ‡∏ß‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÉ‡∏ô regime ‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if(!IsTrendScalpAllowedInRegime(regime)) 
    {
        DebugPrint(2, "Trend Scalp not allowed in " + EnumToString(regime) + " regime");
        return;
    }
    
    // üîç DEBUG INFO
    if(EnableDebugMode)
    {
        Print("=== üéØ SIMPLE TREND SCALP ===");
        Print("Market Regime: " + EnumToString(regime));
    }
    
    // 1. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
    int trendScalpCount = CountPositionsByMagic(MAGIC_TREND_SCALP);
    
    // ‡∏õ‡∏£‡∏±‡∏ö max positions ‡∏ï‡∏≤‡∏° regime
    int allowedPositions = GetTrendScalpMaxPositionsForRegime(regime);
    if(trendScalpCount >= allowedPositions) 
    {
        DebugPrint(3, "Max Trend Scalp positions reached for " + EnumToString(regime) + 
                  ": " + IntegerToString(trendScalpCount) + "/" + IntegerToString(allowedPositions));
        return;
    }

    // 2. ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏´‡∏•‡∏±‡∏Å (‡πÉ‡∏ä‡πâ‡∏´‡∏•‡∏≤‡∏¢ timeframe)
    ENUM_TREND_DIRECTION mainTrend = AnalyzeMultiTimeframeTrend();
    double trendStrength = CalculateTrendStrength();
    
    if(EnableDebugMode)
    {
        Print("1. Main Trend: ", GetTrendDirectionName(mainTrend));
        Print("2. Trend Strength: ", DoubleToString(trendStrength, 2));
        Print("3. Current Positions: ", trendScalpCount, "/", allowedPositions);
    }

    // 3. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÄ‡∏ó‡∏£‡∏î‡∏ï‡∏≤‡∏°‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏•‡∏∞ regime
    if(ShouldTradeBasedOnTrend(mainTrend, trendStrength, regime))
    {
        // ‡∏õ‡∏£‡∏±‡∏ö lot size ‡∏ï‡∏≤‡∏° regime ‡πÅ‡∏•‡∏∞ trend strength
        double baseLot = CalculateTrendBasedLot(trendStrength);
        double lotMultiplier = GetTrendScalpLotMultiplierForRegime(regime);
        double lot = NormalizeDouble(baseLot * lotMultiplier, 2);
        
        if(!CheckMargin(lot)) 
        {
            DebugPrint(1, "Insufficient margin for Trend Scalp: " + DoubleToString(lot, 2));
            return;
        }

        trade.SetExpertMagicNumber(MAGIC_TREND_SCALP);
        
        if(mainTrend == TREND_UP)
        {
            ExecuteTrendBuy(lot, regime);
        }
        else if(mainTrend == TREND_DOWN)
        {
            ExecuteTrendSell(lot, regime);
        }
    }
    else
    {
        DebugPrint(3, "No clear trend signal for " + EnumToString(regime) + " - waiting");
    }
}

// üî• ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Helper ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Trend Scalp ‡∏ï‡∏≤‡∏° Regime
bool IsTrendScalpAllowedInRegime(ENUM_MARKET_REGIME regime)
{
    switch(regime)
    {
        case MARKET_REGIME_RANGING_CALM:
        case MARKET_REGIME_RANGING_VOLATILE:
            // ‡πÉ‡∏ô sideways market ‡πÑ‡∏°‡πà‡∏Ñ‡∏ß‡∏£‡πÉ‡∏ä‡πâ trend strategy
            return EnableTrendScalpInRange;
            
        case MARKET_REGIME_TRENDING_STRONG:
            // ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö trend strategy
            return true;
            
        case MARKET_REGIME_TRENDING_WEAK:
            // ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏≠‡πà‡∏≠‡∏ô ‡∏≠‡∏≤‡∏à‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ stricter rules
            return EnableTrendScalpInWeakTrend;
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            // ‡πÉ‡∏ô breakout ‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö trend scalp
            return EnableTrendScalpInBreakout;
            
        case MARKET_REGIME_NORMAL:
        default:
            return true;
    }
}
int GetTrendScalpMaxPositionsForRegime(ENUM_MARKET_REGIME regime)
{
    int baseMax = Scalp1_MaxPositions; // ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö Scalp1 ‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏≤‡∏à‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏¢‡∏Å
    
    switch(regime)
    {
        case MARKET_REGIME_TRENDING_STRONG:
            // ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á ‡∏≠‡∏≤‡∏à‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏î‡πâ‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤
            return MathMin(baseMax + 2, 8);
            
        case MARKET_REGIME_RANGING_CALM:
        case MARKET_REGIME_RANGING_VOLATILE:
            // ‡πÉ‡∏ô sideways ‡πÄ‡∏õ‡∏¥‡∏î‡∏ô‡πâ‡∏≠‡∏¢‡∏•‡∏á
            return MathMax(1, baseMax / 2);
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            // ‡πÉ‡∏ô breakout ‡∏£‡∏∞‡∏ß‡∏±‡∏á
            return MathMax(1, (int)(baseMax * 0.6));
            
        case MARKET_REGIME_TRENDING_WEAK:
            // ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏≠‡πà‡∏≠‡∏ô ‡∏õ‡∏Å‡∏ï‡∏¥
            return baseMax;
            
        default:
            return baseMax;
    }
}
double GetTrendScalpLotMultiplierForRegime(ENUM_MARKET_REGIME regime)
{
    switch(regime)
    {
        case MARKET_REGIME_TRENDING_STRONG:
            // ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á ‡πÄ‡∏û‡∏¥‡πà‡∏° lot ‡πÑ‡∏î‡πâ
            return 1.3;
            
        case MARKET_REGIME_RANGING_VOLATILE:
            // ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô ‡∏•‡∏î lot
            return 0.6;
            
        case MARKET_REGIME_RANGING_CALM:
            // ‡πÉ‡∏ô sideways ‡πÄ‡∏á‡∏µ‡∏¢‡∏ö ‡∏õ‡∏Å‡∏ï‡∏¥
            return 0.9;
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            // ‡πÉ‡∏ô breakout ‡∏£‡∏∞‡∏ß‡∏±‡∏á
            return 0.7;
            
        case MARKET_REGIME_TRENDING_WEAK:
            // ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏≠‡πà‡∏≠‡∏ô ‡∏•‡∏î‡∏ô‡∏¥‡∏î‡∏´‡∏ô‡πà‡∏≠‡∏¢
            return 0.8;
            
        default:
            return 1.0;
    }
}
bool ShouldTradeBasedOnTrend(ENUM_TREND_DIRECTION trend, double strength, ENUM_MARKET_REGIME regime)
{
    if(trend == TREND_NONE) return false;
    
    // ‡∏õ‡∏£‡∏±‡∏ö trend strength requirement ‡∏ï‡∏≤‡∏° regime
    double requiredStrength = GetRequiredTrendStrengthForRegime(regime);
    
    if(strength < requiredStrength) 
    {
        if(EnableDebugMode) 
        {
            Print("Trend strength too low for " + EnumToString(regime) + 
                  ": " + DoubleToString(strength, 2) + " < " + DoubleToString(requiredStrength, 2));
        }
        return false;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡∏ï‡∏≤‡∏° regime
    switch(regime)
    {
        case MARKET_REGIME_TRENDING_STRONG:
            // ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ confirmation ‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤
            return true;
            
        case MARKET_REGIME_TRENDING_WEAK:
            // ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏≠‡πà‡∏≠‡∏ô ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ confirmation ‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô
            return HasMultipleTrendConfirmations(trend);
            
        case MARKET_REGIME_RANGING_CALM:
            // ‡πÉ‡∏ô sideways ‡πÄ‡∏á‡∏µ‡∏¢‡∏ö ‡∏Ñ‡∏ß‡∏£‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á trend trade
            return false;
            
        case MARKET_REGIME_RANGING_VOLATILE:
            // ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ strict confirmation
            return IsTrendValidInVolatileMarket(trend);
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            // ‡πÉ‡∏ô breakout ‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà false breakout
            return IsTrendConfirmedAfterBreakout(trend);
            
        default:
            return true;
    }
}

double GetRequiredTrendStrengthForRegime(ENUM_MARKET_REGIME regime)
{
    switch(regime)
    {
        case MARKET_REGIME_TRENDING_STRONG:
            return 0.6; // ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏£‡∏á‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥ 60%
            
        case MARKET_REGIME_TRENDING_WEAK:
            return 0.4; // ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏£‡∏á‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥ 40%
            
        case MARKET_REGIME_RANGING_VOLATILE:
            return 0.7; // ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏£‡∏á‡∏°‡∏≤‡∏Å‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            return 0.5; // ‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á
            
        case MARKET_REGIME_RANGING_CALM:
            return 0.8; // ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏£‡∏á‡∏°‡∏≤‡∏Å‡πÉ‡∏ô sideways ‡πÄ‡∏á‡∏µ‡∏¢‡∏ö
            
        default:
            return 0.5; // ‡∏õ‡∏Å‡∏ï‡∏¥ 50%
    }
}

// üî• ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô ExecuteTrendBuy ‡πÅ‡∏•‡∏∞ ExecuteTrendSell
void ExecuteTrendBuy(double lot, ENUM_MARKET_REGIME regime)
{
    // ‡∏õ‡∏£‡∏±‡∏ö TP/SL ‡∏ï‡∏≤‡∏° regime
    double tpMultiplier = GetTrendScalpTPMultiplierForRegime(regime);
    double slMultiplier = GetTrendScalpSLMultiplierForRegime(regime);
    
    double tpPoints = MathMax(Scalp1_TP_Points * tpMultiplier, 10);
    double slPoints = MathMax(Scalp1_SL_Points * slMultiplier, 15);
    
    double tpPrice = GetTPPriceUniversal(true, (int)tpPoints);
    double slPrice = GetSLPriceUniversal(true, (int)slPoints);
    
    DebugPrint(2, "Trend Scalp BUY - Regime: " + EnumToString(regime) + 
               ", Lot: " + DoubleToString(lot, 2) + 
               ", TP: " + IntegerToString((int)tpPoints) + "pips");
               
    if(trade.Buy(lot, _Symbol, slPrice, 0, tpPrice, "TrendScalp-Buy-" + EnumToString(regime)))
    {
        ulong ticket = trade.ResultOrder();
        Print("‚úÖ TREND SCALP BUY | Regime: " + EnumToString(regime) + 
              " | Ticket: #" + TicketToStr(ticket) + 
              " | Lot: " + DoubleToString(lot, 2) + 
              " | TP: " + IntegerToString((int)tpPoints) + "pips");
    }
    else
    {
        Print("‚ùå Trend Scalp BUY Error: " + trade.ResultRetcodeDescription());
    }
}

void ExecuteTrendSell(double lot, ENUM_MARKET_REGIME regime)
{
    // ‡∏õ‡∏£‡∏±‡∏ö TP/SL ‡∏ï‡∏≤‡∏° regime
    double tpMultiplier = GetTrendScalpTPMultiplierForRegime(regime);
    double slMultiplier = GetTrendScalpSLMultiplierForRegime(regime);
    
    double tpPoints = MathMax(Scalp1_TP_Points * tpMultiplier, 10);
    double slPoints = MathMax(Scalp1_SL_Points * slMultiplier, 15);
    
    double tpPrice = GetTPPriceUniversal(false, (int)tpPoints);
    double slPrice = GetSLPriceUniversal(false, (int)slPoints);
    
    DebugPrint(2, "Trend Scalp SELL - Regime: " + EnumToString(regime) + 
               ", Lot: " + DoubleToString(lot, 2) + 
               ", TP: " + IntegerToString((int)tpPoints) + "pips");
               
    if(trade.Sell(lot, _Symbol, slPrice, 0, tpPrice, "TrendScalp-Sell-" + EnumToString(regime)))
    {
        ulong ticket = trade.ResultOrder();
        Print("‚úÖ TREND SCALP SELL | Regime: " + EnumToString(regime) + 
              " | Ticket: #" + TicketToStr(ticket) + 
              " | Lot: " + DoubleToString(lot, 2) + 
              " | TP: " + IntegerToString((int)tpPoints) + "pips");
    }
    else
    {
        Print("‚ùå Trend Scalp SELL Error: " + trade.ResultRetcodeDescription());
    }
}

double GetTrendScalpTPMultiplierForRegime(ENUM_MARKET_REGIME regime)
{
    switch(regime)
    {
        case MARKET_REGIME_TRENDING_STRONG:
            return 2.0; // TP ‡∏¢‡∏≤‡∏ß‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á
            
        case MARKET_REGIME_RANGING_VOLATILE:
            return 0.5; // TP ‡∏™‡∏±‡πâ‡∏ô‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            return 1.8; // TP ‡∏¢‡∏≤‡∏ß‡πÉ‡∏ô breakout
            
        case MARKET_REGIME_RANGING_CALM:
            return 0.8; // TP ‡∏™‡∏±‡πâ‡∏ô‡πÉ‡∏ô sideways ‡πÄ‡∏á‡∏µ‡∏¢‡∏ö
            
        case MARKET_REGIME_TRENDING_WEAK:
            return 1.2; // TP ‡∏¢‡∏≤‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
            
        default:
            return 1.0;
    }
}

double GetTrendScalpSLMultiplierForRegime(ENUM_MARKET_REGIME regime)
{
    switch(regime)
    {
        case MARKET_REGIME_TRENDING_STRONG:
            return 1.5; // SL ‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á
            
        case MARKET_REGIME_RANGING_VOLATILE:
            return 0.7; // SL ‡πÅ‡∏Ñ‡∏ö‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            return 1.3; // SL ‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡πÉ‡∏ô breakout
            
        default:
            return 1.0;
    }
}
bool IsMAAlignmentConfirming(int trend)  // ‡∏´‡∏£‡∏∑‡∏≠ double trend ‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡πÉ‡∏ä‡πâ
{
    // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏á‡∏ó‡∏µ‡πà
    const int TREND_UP = 1;
    const int TREND_DOWN = 2;
    const int TREND_NONE = 0;
    
    // ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤ EMA ‡∏î‡πâ‡∏ß‡∏¢ CopyBuffer
    double maFastArray[1], maMediumArray[1], maSlowArray[1];
    
    // ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å handles
    if(CopyBuffer(ema9_handle_m15, 0, 0, 1, maFastArray) <= 0)
    {
        Print("Failed to copy EMA9 buffer");
        return false;
    }
    
    if(CopyBuffer(ema21_handle_m15, 0, 0, 1, maMediumArray) <= 0)
    {
        Print("Failed to copy EMA21 buffer");
        return false;
    }
    
    if(CopyBuffer(ema50_handle_m15, 0, 0, 1, maSlowArray) <= 0)
    {
        Print("Failed to copy EMA50 buffer");
        return false;
    }
    
    double maFast = maFastArray[0];
    double maMedium = maMediumArray[0];
    double maSlow = maSlowArray[0];
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏±‡∏ß‡∏Ç‡∏≠‡∏á MA
    bool maBullish = (maFast > maMedium && maMedium > maSlow);
    bool maBearish = (maFast < maMedium && maMedium < maSlow);
    
    if(trend == TREND_UP && maBullish) return true;
    if(trend == TREND_DOWN && maBearish) return true;
    
    return false;
}
bool IsMACDConfirming(int trend)
{
    const int TREND_UP = 1;
    const int TREND_DOWN = 2;
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á MACD handle
    int macdHandle = iMACD(_Symbol, PERIOD_M15, 12, 26, 9, PRICE_CLOSE);
    if(macdHandle == INVALID_HANDLE)
    {
        Print("Failed to create MACD handle");
        return false;
    }
    
    // ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤ MACD ‡πÅ‡∏•‡∏∞ Signal line
    double macdArray[1], signalArray[1];
    
    if(CopyBuffer(macdHandle, 0, 0, 1, macdArray) <= 0 ||
       CopyBuffer(macdHandle, 1, 0, 1, signalArray) <= 0)
    {
        IndicatorRelease(macdHandle);
        return false;
    }
    
    IndicatorRelease(macdHandle);
    
    double macd = macdArray[0];
    double signal = signalArray[0];
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ï‡∏≤‡∏° trend
    if(trend == TREND_UP)
    {
        // MACD bullish: MACD > Signal ‡πÅ‡∏•‡∏∞ MACD > 0
        return (macd > signal && macd > 0);
    }
    else if(trend == TREND_DOWN)
    {
        // MACD bearish: MACD < Signal ‡πÅ‡∏•‡∏∞ MACD < 0
        return (macd < signal && macd < 0);
    }
    
    return false;
}
bool IsRSIConfirming(int trend)
{
    const int TREND_UP = 1;
    const int TREND_DOWN = 2;
    
    int rsiHandle = iRSI(_Symbol, PERIOD_M15, 14, PRICE_CLOSE);
    if(rsiHandle == INVALID_HANDLE) return false;
    
    double rsiArray[1];
    if(CopyBuffer(rsiHandle, 0, 0, 1, rsiArray) <= 0)
    {
        IndicatorRelease(rsiHandle);
        return false;
    }
    
    IndicatorRelease(rsiHandle);
    
    double rsi = rsiArray[0];
    
    if(trend == TREND_UP)
    {
        // RSI bullish: RSI > 50 ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà overbought
        return (rsi > 50 && rsi < 70);
    }
    else if(trend == TREND_DOWN)
    {
        // RSI bearish: RSI < 50 ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà oversold
        return (rsi < 50 && rsi > 30);
    }
    
    return false;
}
bool IsPriceActionConfirming(int trend)
{
    const int TREND_UP = 1;
    const int TREND_DOWN = 2;
    
    MqlRates rates[3];
    if(CopyRates(_Symbol, PERIOD_H1, 0, 3, rates) < 3) 
    {
        // ‡∏•‡∏≠‡∏á timeframe ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡πá‡∏Å‡∏Å‡∏ß‡πà‡∏≤
        if(CopyRates(_Symbol, PERIOD_M15, 0, 3, rates) < 3) return false;
    }
    
    if(trend == TREND_UP)
    {
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö higher highs ‡∏´‡∏£‡∏∑‡∏≠ higher lows
        bool higherHighs = true;
        bool higherLows = true;
        
        for(int i = 1; i < 3; i++)
        {
            if(rates[i].high <= rates[i-1].high) higherHighs = false;
            if(rates[i].low <= rates[i-1].low) higherLows = false;
        }
        
        return (higherHighs || higherLows);
    }
    else if(trend == TREND_DOWN)
    {
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö lower highs ‡∏´‡∏£‡∏∑‡∏≠ lower lows
        bool lowerHighs = true;
        bool lowerLows = true;
        
        for(int i = 1; i < 3; i++)
        {
            if(rates[i].high >= rates[i-1].high) lowerHighs = false;
            if(rates[i].low >= rates[i-1].low) lowerLows = false;
        }
        
        return (lowerHighs || lowerLows);
    }
    
    return false;
}
bool IsMomentumConfirming(int trend)
{
    const int TREND_UP = 1;
    const int TREND_DOWN = 2;
    
    // ‡πÉ‡∏ä‡πâ Stochastic ‡∏´‡∏£‡∏∑‡∏≠ RSI ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö momentum
    int stochHandle = iStochastic(_Symbol, PERIOD_M15, 14, 3, 3, MODE_SMA, STO_LOWHIGH);
    if(stochHandle == INVALID_HANDLE)
    {
        // ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ RSI ‡∏ñ‡πâ‡∏≤ Stochastic ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ
        return IsRSIConfirming(trend);
    }
    
    double mainArray[1], signalArray[1];
    
    if(CopyBuffer(stochHandle, 0, 0, 1, mainArray) <= 0 ||
       CopyBuffer(stochHandle, 1, 0, 1, signalArray) <= 0)
    {
        IndicatorRelease(stochHandle);
        return IsRSIConfirming(trend);
    }
    
    IndicatorRelease(stochHandle);
    
    double stochMain = mainArray[0];
    double stochSignal = signalArray[0];
    
    if(trend == TREND_UP)
    {
        // Stochastic bullish: main > signal ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô overbought (>80)
        return (stochMain > stochSignal && stochMain < 80);
    }
    else if(trend == TREND_DOWN)
    {
        // Stochastic bearish: main < signal ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô oversold (<20)
        return (stochMain < stochSignal && stochMain > 20);
    }
    
    return false;
}
// üî• ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö trend confirmation
bool HasMultipleTrendConfirmations(int trend)
{
    const int TREND_UP = 1;
    const int TREND_DOWN = 2;
    
    if(trend != TREND_UP && trend != TREND_DOWN) return false;
    
    int confirmations = 0;
    
    // 1. MA alignment
    if(IsMAAlignmentConfirming(trend)) 
    {
        confirmations++;
        if(EnableDebugMode) Print("MA Alignment confirmed for trend: ", trend);
    }
    
    // 2. MACD
    if(IsMACDConfirming(trend)) 
    {
        confirmations++;
        if(EnableDebugMode) Print("MACD confirmed for trend: ", trend);
    }
    
    // 3. Momentum (RSI/Stochastic)
    if(IsMomentumConfirming(trend)) 
    {
        confirmations++;
        if(EnableDebugMode) Print("Momentum confirmed for trend: ", trend);
    }
    
    // 4. Price action (optional)
    if(IsPriceActionConfirming(trend)) 
    {
        confirmations++;
        if(EnableDebugMode) Print("Price action confirmed for trend: ", trend);
    }
    
    if(EnableDebugMode) Print("Total confirmations: ", confirmations, " for trend: ", trend);
    
    // ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 2 confirmations
    return (confirmations >= 2);
}

bool IsTrendValidInVolatileMarket(ENUM_TREND_DIRECTION trend)
{
    // ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ trend ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà noise
     double atr = GetATRValue(_Symbol, PERIOD_H1, 14, 0);
    double atrAvg = GetATRAverage(_Symbol, PERIOD_H1, 14, 20);
    
    // ‡∏ñ‡πâ‡∏≤ ATR ‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤‡∏õ‡∏Å‡∏ï‡∏¥‡∏°‡∏≤‡∏Å ‡∏≠‡∏≤‡∏à‡πÄ‡∏õ‡πá‡∏ô noise
    if(atr > atrAvg * 1.8) 
    {
        DebugPrint(2, "High volatility detected - trend may be noise");
        return false;
    }
    
    return HasMultipleTrendConfirmations(trend);
}

bool IsTrendConfirmedAfterBreakout(int trend)  // trend: 1=UP, 2=DOWN
{
    const int TREND_UP = 1;
    const int TREND_DOWN = 2;
    
    if(trend != TREND_UP && trend != TREND_DOWN) return false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ trend ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡∏∂‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á breakout ‡∏à‡∏£‡∏¥‡∏á
    return IsPriceAboveKeyLevel(trend) && HasVolumeConfirmation();
}
// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô HasVolumeConfirmation (‡πÅ‡∏ö‡∏ö‡∏á‡πà‡∏≤‡∏¢)
bool HasVolumeConfirmation()
{
    // ‡πÉ‡∏ô MQL5 ‡∏≠‡∏≤‡∏à‡πÉ‡∏ä‡πâ tick volume ‡∏´‡∏£‡∏∑‡∏≠‡πÅ‡∏ó‡πâ‡∏à‡∏£‡∏¥‡∏á‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏ß‡∏£‡πÉ‡∏ä‡πâ OnBalanceVolume, Money Flow Index
    MqlRates rates[2];
    if(CopyRates(_Symbol, PERIOD_H1, 0, 2, rates) < 2) return false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö volume ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ó‡πà‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤‡πÅ‡∏ó‡πà‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤
    // ‡πÉ‡∏ô MQL5, rates[].tick_volume ‡∏Ñ‡∏∑‡∏≠ tick volume
    if(rates[0].tick_volume > rates[1].tick_volume * 1.2)
    {
        return true; // Volume ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏°‡∏µ‡∏ô‡∏±‡∏¢‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç
    }
    
    // ‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢ volume
    double avgVolume = GetAverageVolume(10);
    if(avgVolume > 0 && rates[0].tick_volume > avgVolume * 1.5)
    {
        return true;
    }
    
    return false;
}
double GetAverageVolume(int bars)
{
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_H1, 0, bars, rates) < bars) return 0;
    
    double total = 0;
    for(int i = 0; i < bars; i++)
    {
        total += (double)rates[i].tick_volume;  // ‡πÅ‡∏õ‡∏•‡∏á‡∏à‡∏≤‡∏Å long ‡πÄ‡∏õ‡πá‡∏ô double
    }
    
    return total / bars;
}
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô GetEMA ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö MQL5
double GetEMA(int period, int shift = 0, ENUM_TIMEFRAMES tf = PERIOD_H1)
{
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á EMA handle
    int handle = iMA(_Symbol, tf, period, 0, MODE_EMA, PRICE_CLOSE);
    if(handle == INVALID_HANDLE)
    {
        Print("Failed to create EMA", period, " handle");
        return 0;
    }
    
    // ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡∏î‡πâ‡∏ß‡∏¢ CopyBuffer
    double buffer[1];
    if(CopyBuffer(handle, 0, shift, 1, buffer) <= 0)
    {
        IndicatorRelease(handle);
        Print("Failed to copy EMA", period, " buffer");
        return 0;
    }
    
    IndicatorRelease(handle);
    return buffer[0];
}
// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô IsPriceAboveKeyLevel
bool IsPriceAboveKeyLevel(int trend)
{
    const int TREND_UP = 1;
    const int TREND_DOWN = 2;
    
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double ema20 = GetEMAValue(_Symbol, PERIOD_H1, 20, 0);
    
    if(trend == TREND_UP)
    {
        return (currentPrice > ema20);
    }
    else if(trend == TREND_DOWN)
    {
        return (currentPrice < ema20);
    }
    
    return false;
    
}
double GetATRSimple(int period = 14, int shift = 0, ENUM_TIMEFRAMES tf = PERIOD_H1)
{
    return GetATRValue(_Symbol, tf, period, shift);
}
// 3. ‡πÉ‡∏ô GetTrendFromSingleTimeframe()
int GetTrendFromSingleTimeframe(ENUM_TIMEFRAMES tf)
{
    const int TREND_NONE = 0;
    const int TREND_UP = 1;
    const int TREND_DOWN = 2;
    
    // ‡πÉ‡∏ä‡πâ helper functions
    double ema9 = GetEMASimple(9, 0, tf);
    double ema21 = GetEMASimple(21, 0, tf);
    double atr14 = GetATRSimple(14, 0, tf);
    
    if(ema9 == 0 || ema21 == 0 || atr14 == 0) 
    {
        return TREND_NONE;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö EMA alignment ‡πÅ‡∏•‡∏∞ strength
    bool bullishAlignment = (ema9 > ema21);
    bool bearishAlignment = (ema9 < ema21);
    
    double diff = MathAbs(ema9 - ema21);
    double diffInATR = atr14 > 0 ? diff / atr14 : 0;
    
    // ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 0.4 * ATR
    if(diffInATR < 0.4) 
    {
        return TREND_NONE; // Trend ‡πÑ‡∏°Ôúä‡πÅ‡∏£‡∏á‡∏û‡∏≠
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö price position
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    if(bullishAlignment)
    {
        // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö uptrend ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ñ‡∏ß‡∏£‡∏≠‡∏¢‡∏π‡πà‡πÄ‡∏´‡∏ô‡∏∑‡∏≠ EMA ‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á
        if(currentPrice > ema9 && currentPrice > ema21)
        {
            return TREND_UP;
        }
    }
    else if(bearishAlignment)
    {
        // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö downtrend ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ñ‡∏ß‡∏£‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ï‡πâ EMA ‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á
        if(currentPrice < ema9 && currentPrice < ema21)
        {
            return TREND_DOWN;
        }
    }
    
    return TREND_NONE;
}
double GetKeyLevelForBreakout(int trend)
{
    const int TREND_UP = 1;
    const int TREND_DOWN = 2;
    
    // ‡∏´‡∏≤ recent high/low ‡πÄ‡∏õ‡πá‡∏ô key level
    MqlRates rates[20];
    if(CopyRates(_Symbol, PERIOD_H1, 0, 20, rates) < 20)
    {
        // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
        return (trend == TREND_UP) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) * 0.99 
                                   : SymbolInfoDouble(_Symbol, SYMBOL_BID) * 1.01;
    }
    
    if(trend == TREND_UP)
    {
        // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö breakout up ‡πÉ‡∏ä‡πâ recent high
        double highestHigh = rates[0].high;
        for(int i = 1; i < 20; i++)
        {
            if(rates[i].high > highestHigh) highestHigh = rates[i].high;
        }
        return highestHigh;
    }
    else // TREND_DOWN
    {
        // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö breakout down ‡πÉ‡∏ä‡πâ recent low
        double lowestLow = rates[0].low;
        for(int i = 1; i < 20; i++)
        {
            if(rates[i].low < lowestLow) lowestLow = rates[i].low;
        }
        return lowestLow;
    }
}
//+------------------------------------------------------------------+
//| Calculate Total Profit - Fixed implementation                  |
//+------------------------------------------------------------------+
double CalculateTotalProfit()
{
   double total = 0;
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(PositionGetSymbol(i) == _Symbol)
      {
         total += PositionGetDouble(POSITION_PROFIT);
      }
   }
   return total;
}


//+------------------------------------------------------------------+
//| Open Trend Scalp Position                                       |
//+------------------------------------------------------------------+
void OpenTrendScalpPosition(bool isBuy)
{
    double lot = CalculateSimpleLot();
    
    if(!CheckMargin(lot)) 
    {
        DebugPrint(1, "Insufficient margin for Trend Scalp: " + DoubleToString(lot, 2));
        return;
    }
    
    trade.SetExpertMagicNumber(MAGIC_TREND_SCALP);
    
    if(isBuy)
    {
        double tpPrice = GetTPPriceUniversal(true, TrendScalp_TP_Points);
        double slPrice = (TrendScalp_SL_Points > 0) ? GetSLPriceUniversal(true, TrendScalp_SL_Points) : 0;
        
        if(trade.Buy(lot, _Symbol, slPrice, 0, tpPrice, "Trend-Scalp-Buy"))
        {
            Print("?? TREND SCALP BUY | Lot: " + DoubleToString(lot, 2) + 
                  " | TP: " + IntegerToString(TrendScalp_TP_Points) + " pips");
        }
    }
    else
    {
        double tpPrice = GetTPPriceUniversal(false, TrendScalp_TP_Points);
        double slPrice = (TrendScalp_SL_Points > 0) ? GetSLPriceUniversal(false, TrendScalp_SL_Points) : 0;
        
        if(trade.Sell(lot, _Symbol, slPrice, 0, tpPrice, "Trend-Scalp-Sell"))
        {
            Print("?? TREND SCALP SELL | Lot: " + DoubleToString(lot, 2) + 
                  " | TP: " + IntegerToString(TrendScalp_TP_Points) + " pips");
        }
    }
}

//+------------------------------------------------------------------+
//| Calculate Simple Lot                                            |
//+------------------------------------------------------------------+
double CalculateSimpleLot()
{
    double lot = BaseLot;
    
    double riskPressure = CalculateRiskPressure();
    if(riskPressure > 0.7) 
    {
        lot *= 0.5; 
    }
    
    lot = MathMin(lot, MaxLot);
    lot = MathMax(lot, BaseLot);
    
    return NormalizeDouble(lot, 2);
}
// üîß ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡πâ‡∏î‡∏µ‡∏Ç‡∏∂‡πâ‡∏ô
double CalculateDynamicLot()
{
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double risk = 0.02; // Risk 2% ‡∏ï‡πà‡∏≠‡πÄ‡∏ó‡∏£‡∏î
   double stoploss = CalculateDynamicDistance() * 2;
   double lot = (balance * risk) / (stoploss * 100000);
   
   // ‡πÉ‡∏ä‡πâ MaxLot ‡∏à‡∏≤‡∏Å input parameters
   return NormalizeDouble(MathMin(lot, MaxLot), 2);
}
//+------------------------------------------------------------------+
//| Check Active Trend Scalp Position                              |
//+------------------------------------------------------------------+
bool HasActiveTrendScalpPosition()
{
    return (CountPositionsByMagic(MAGIC_TREND_SCALP) > 0);
}

//+------------------------------------------------------------------+
//| Clean Up Inactive Pairs - ????????????? active                |
//+------------------------------------------------------------------+
void CleanUpInactivePairs()
{
    int newIndex = 0;
    for(int i = 0; i < totalTradingPairs; i++)
    {
        if(tradingPairs[i].isActive) // ????????????????? active
        {
            if(i != newIndex)
            {
                tradingPairs[newIndex] = tradingPairs[i];
            }
            newIndex++;
        }
    }
    totalTradingPairs = newIndex; // ??????????????
}

//+------------------------------------------------------------------+
//| Should Close Trading Pair - ??????????????                   |
//+------------------------------------------------------------------+
bool ShouldCloseTradingPair(int pairIndex)
{
    double pairProfit = tradingPairs[pairIndex].currentProfit;
    double targetProfit = tradingPairs[pairIndex].targetProfit;
    
    // 1. ????????????????
    if(pairProfit >= targetProfit)
    {
        Print("?? Pair target reached: $" + DoubleToString(pairProfit, 2));
        return true;
    }
    
    // 2. ?????????????...
    return false;
}

//+------------------------------------------------------------------+
//| Update Pair Profit - ???????????????                          |
//+------------------------------------------------------------------+
double UpdatePairProfit(int pairIndex)
{
    double totalProfit = 0;
    
    // ????????????????????
    if(PositionSelectByTicket(tradingPairs[pairIndex].mainTicket))
    {
        totalProfit += PositionGetDouble(POSITION_PROFIT);
    }
    
    // ????????????????????????
    if(PositionSelectByTicket(tradingPairs[pairIndex].helpTicket))
    {
        totalProfit += PositionGetDouble(POSITION_PROFIT);
    }
    
    tradingPairs[pairIndex].currentProfit = totalProfit;
    return totalProfit;
}
bool IsMainTicketMissing(int setIndex)
{
    return !PositionSelectByTicket(recoverySets[setIndex].mainTicket);
}

bool ShouldCloseIndividualRecovery(ulong recoveryTicket)
{
    if(!PositionSelectByTicket(recoveryTicket)) return false;
    
    double profit = PositionGetDouble(POSITION_PROFIT);
    // ‡∏õ‡∏¥‡∏î‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏≥‡πÑ‡∏£‡∏ñ‡∏∂‡∏á MinSetTP (‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢)
    return (profit >= MinSetTP);
}
//+------------------------------------------------------------------+
//| Notify Universal Orphan (Legacy - use RegisterOrphan instead)  |
//+------------------------------------------------------------------+
void NotifyUniversalOrphan(ulong ticket, string strategyName = "Unknown", long originalMagic = 0)
{
    // This is a legacy function - redirect to new system
    RegisterOrphan(ticket, originalMagic, strategyName);
    
    // Legacy logging
    Print("üÜò LEGACY ORPHAN NOTIFICATION: Ticket #" + TicketToStr(ticket) + 
          " | Strategy: " + strategyName);
}
// +------------------------------------------------------------------+
//| Notify Orphan Job System (‡πÅ‡∏ó‡∏ô NotifyUniversalOrphan)            |
//+------------------------------------------------------------------+
void NotifyOrphanJobSystem(ulong ticket, string strategyName = "Unknown", long originalMagic = 0)
{
    if(!PositionSelectByTicket(ticket)) return;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ ticket ‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô Orphan ‡∏ó‡∏µ‡πà‡∏Ñ‡∏ß‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á Job ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    ulong mainTicket = ExtractMainTicketFromComment(PositionGetString(POSITION_COMMENT));
    
    if(mainTicket > 0 && !PositionSelectByTicket(mainTicket))
    {
        // ‡∏û‡∏ö Orphan ‡∏ó‡∏µ‡πà Main ‡∏´‡∏≤‡∏¢ ‚Üí ‡πÅ‡∏à‡πâ‡∏á‡∏£‡∏∞‡∏ö‡∏ö Job
        Print("üÜò ORPHAN DETECTED | Ticket: #" + TicketToStr(ticket) + 
              " | Main: #" + TicketToStr(mainTicket) +
              " | Strategy: " + strategyName);
        
        // ‡∏£‡∏∞‡∏ö‡∏ö Orphan Universal ‡∏à‡∏∞‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á Job ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
        // ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á Job ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà ‡πÄ‡∏û‡∏£‡∏≤‡∏∞ ManageOrphanUniversal() ‡∏à‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏≠‡∏á
    }
    else
    {
        DebugPrint(3, "NotifyOrphan: Ticket #" + TicketToStr(ticket) + " is not an orphan (main still exists)");
    }
}

// +------------------------------------------------------------------+
//| Notify Orphan Job System (‡πÅ‡∏ó‡∏ô NotifyUniversalOrphan)            |
//+------------------------------------------------------------------+
void CheckAndNotifyRecoverySetOrphans()
{
    for(int i = 0; i < totalRecoverySets; i++)
    {
        if(recoverySets[i].isCompleted) continue;
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Main ‡∏´‡∏≤‡∏¢‡πÑ‡∏õ
        if(!PositionSelectByTicket(recoverySets[i].mainTicket))       
        {
            Print("üîî RECOVERY SET ORPHAN DETECTED: Set #" + IntegerToString(recoverySets[i].setNumber) + 
                  " | Main #" + TicketToStr(recoverySets[i].mainTicket) + " is missing!");
            
            // ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏Å NotifyUniversalOrphan ‡∏≠‡∏µ‡∏Å
            // ‡∏£‡∏∞‡∏ö‡∏ö Orphan Universal ‡∏à‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á Job ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
        }
    }
}
// +------------------------------------------------------------------+
//| Register Orphan Tickets From Set (‡πÅ‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà)                     |
//+------------------------------------------------------------------+
void RegisterOrphanTicketsFromSet(int setIndex)
{
    int registeredCount = 0;
    
    for(int i = 0; i < recoverySets[setIndex].subCount; i++)
    {
        ulong subTicket = recoverySets[setIndex].subTickets[i];
        
        if(PositionSelectByTicket(subTicket))
        {
            // ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏Å NotifyUniversalOrphan ‡∏≠‡∏µ‡∏Å
            // ‡πÅ‡∏Ñ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ß‡πà‡∏≤ Set ‡∏ô‡∏µ‡πâ‡∏°‡∏µ Orphan
            registeredCount++;
            DebugPrint(2, "Orphan ticket in Set #" + IntegerToString(recoverySets[setIndex].setNumber) + 
                      ": #" + TicketToStr(subTicket));
        }
    }
    
    Print("üìã Set #" + IntegerToString(recoverySets[setIndex].setNumber) + 
          " has " + IntegerToString(registeredCount) + " orphan tickets");
    
    // Mark set as completed ‡πÄ‡∏û‡∏£‡∏≤‡∏∞ Main ‡∏´‡∏≤‡∏¢
    recoverySets[setIndex].isCompleted = true;
}

//+------------------------------------------------------------------+
//| ??????? Orphan ?????????????                                  |
//+------------------------------------------------------------------+
void CheckAllStrategiesForOrphans()
{
    // 1. ??????? Recovery Sets
    CheckAndNotifyRecoverySetOrphans();
    
    // 2. ????????????????????
    CheckOtherStrategiesForOrphans();
}

//+------------------------------------------------------------------+
//| ??????????????????? ?????? Orphan                           |
//+------------------------------------------------------------------+
void CheckOtherStrategiesForOrphans()
{
    for(int i = PositionsTotal()-1; i >= 0; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            long magic = PositionGetInteger(POSITION_MAGIC);
            string comment = PositionGetString(POSITION_COMMENT);
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô Recovery Position ‡∏ó‡∏µ‡πà Main ‡∏´‡∏≤‡∏¢
            if((magic == MAGIC_RECOVERY || magic == MAGIC_INDIVIDUAL) && 
               StringFind(comment, "Recovery-") != -1)
            {
                ulong mainTicket = ExtractMainTicketFromComment(comment);
                if(mainTicket > 0 && !PositionSelectByTicket(mainTicket))
                {
                    // ‡∏û‡∏ö Orphan ‚Üí ‡∏£‡∏∞‡∏ö‡∏ö Orphan Universal ‡∏à‡∏∞‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏≠‡∏á
                    DebugPrint(2, "Orphan detected: #" + TicketToStr(ticket) + " (Main #" + TicketToStr(mainTicket) + " missing)");
                }
            }
        }
    }
}
//+------------------------------------------------------------------+
//| ??????????????????????????????????                          |
//+------------------------------------------------------------------+
bool IsAbandonedPosition(ulong ticket, long magic, string comment)
{
    // ?????????????????????????????????? activity
    datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
    double minutesOpen = (TimeCurrent() - openTime) / 60.0;
    
    // ??????????????????????? 2 ??????? ???????? comment ?????????????????????????????
    if(minutesOpen > 120)
    {
        // ???????????????????? "Active", "Managed", "Current" ?? comment
        if(StringFind(comment, "Active") == -1 && 
           StringFind(comment, "Managed") == -1 && 
           StringFind(comment, "Current") == -1)
        {
            return true;
        }
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| ????????????????? Magic Number                               |
//+------------------------------------------------------------------+
string GetMagicStrategyName(long magic)
{
    if(magic == MAGIC_SCALP1)     return "Scalp1";
    if(magic == MAGIC_SCALP2)     return "Scalp2";
    if(magic == MAGIC_SCALP3)     return "Scalp3";
    if(magic == MAGIC_RECOVERY)   return "Recovery";
    if(magic == MAGIC_HEDGE)      return "Hedge";
    if(magic == MAGIC_COUNTER)    return "Counter";
    if(magic == MAGIC_BREAKOUT)   return "Breakout";
    if(magic == MAGIC_MAIN)       return "Main";
    if(magic == AI_News_Magic)    return "AI-News";
    if(magic == AI_Trend_Magic)   return "AI-Trend";
    
    return "Unknown-" + StringFormat("%I64d", magic);
}
//+------------------------------------------------------------------+
//| ?????????????????????????????                                |
//+------------------------------------------------------------------+
bool ShouldHavePair(ulong ticket, long magic, string comment)
{
    // ???????????????????????:
    // - Recovery orders (????? Main)
    // - Hedge orders (????????????????)
    // - Counter orders (????????????????)
    
    if(magic == MAGIC_RECOVERY || magic == MAGIC_HEDGE || magic == MAGIC_COUNTER)
        return true;
        
    // ????????????????? "Help", "Recovery", "Hedge" ?? comment
    if(StringFind(comment, "Help") != -1 || 
       StringFind(comment, "Recovery") != -1 || 
       StringFind(comment, "Hedge") != -1 ||
       StringFind(comment, "Counter") != -1)
        return true;
        
    return false;
}
//+------------------------------------------------------------------+
//| ??? Ticket ??????? Comment ???? prefix ?????                 |
//+------------------------------------------------------------------+
string ExtractMainTicketWithPrefix(string comment, string prefix)
{
    int pos = StringFind(comment, prefix);
    if(pos != -1)
    {
        string temp = StringSubstr(comment, pos + StringLen(prefix));
        
        // ??????????????????? ticket number
        int endPos = StringFind(temp, "-");
        if(endPos != -1)
        {
            return StringSubstr(temp, 0, endPos);
        }
        return temp;
    }
    
    return "";
}
//+------------------------------------------------------------------+
//| ???????????????????????                                      |
//+------------------------------------------------------------------+

// +------------------------------------------------------------------+
//| Check For Missing Pair (‡πÅ‡∏ö‡∏ö‡πÉ‡∏ä‡πâ‡∏£‡∏∞‡∏ö‡∏ö Orphan Job ‡πÉ‡∏´‡∏°‡πà)            |
//+------------------------------------------------------------------+
void CheckForMissingPair(ulong ticket, long magic, string comment)
{
    string mainTicketStr = "";
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡∏≠‡∏á Position
    if(magic == MAGIC_RECOVERY && StringFind(comment, "Recovery-") != -1)
    {
        mainTicketStr = ExtractMainTicketWithPrefix(comment, "Recovery-");
    }
    else if(magic == MAGIC_HEDGE && StringFind(comment, "Hedge") != -1)
    {
        mainTicketStr = ExtractMainTicketWithPrefix(comment, "Hedge-");
    }
    else if(magic == MAGIC_COUNTER && StringFind(comment, "Counter-") != -1)
    {
        mainTicketStr = ExtractMainTicketWithPrefix(comment, "Counter-");
    }
    
    if(mainTicketStr != "" && mainTicketStr != "0")
    {
        ulong mainTicket = StringToInteger(mainTicketStr);
        if(!PositionSelectByTicket(mainTicket))
        {
            // ‚úÖ ‡πÉ‡∏ä‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà: ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å Log ‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å NotifyUniversalOrphan
            Print("üîî MISSING PAIR DETECTED | Helper: #" + TicketToStr(ticket) + 
                  " | Main: #" + mainTicketStr + " missing" +
                  " | Type: " + GetMagicStrategyName(magic));
            
            // ‚úÖ ‡∏£‡∏∞‡∏ö‡∏ö Orphan Universal ‡∏à‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á Job ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
            // ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡∏≠‡∏∞‡πÑ‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏° - ManageOrphanUniversal() ‡∏à‡∏∞‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏≠‡∏á
        }
    }
}

//+------------------------------------------------------------------+
//| ??? Ticket ??????? Recovery Comment                          |
//+------------------------------------------------------------------+
string ExtractMainTicketFromRecoveryComment(string comment)
{
    int startPos = StringFind(comment, "Recovery-");
    if(startPos != -1)
    {
        string temp = StringSubstr(comment, startPos + 9); // "Recovery-" = 9 chars
        int endPos = StringFind(temp, "-");
        if(endPos != -1)
        {
            return StringSubstr(temp, 0, endPos);
        }
        return temp;
    }
    return "";
}
//+------------------------------------------------------------------+
//| Calculate Safe Orphan Lot - ????????????????                 |
//+------------------------------------------------------------------+
// +------------------------------------------------------------------+
//| Calculate Safe Orphan Lot (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏ö Orphan Job ‡πÉ‡∏´‡∏°‡πà)         |
//+------------------------------------------------------------------+
double CalculateSafeOrphanLot(ulong orphanTicket, int recoveryCount = 0)
{
    if(!PositionSelectByTicket(orphanTicket)) 
    {
        Print("‚ùå CalculateSafeOrphanLot: Ticket not found #" + TicketToStr(orphanTicket));
        return BaseLot;
    }
    
    double orphanVolume = PositionGetDouble(POSITION_VOLUME);
    double orphanProfit = PositionGetDouble(POSITION_PROFIT);
    
    double baseMultiplier = localRecoveryMultiplier;
    
    // ‚úÖ ‡∏õ‡∏£‡∏±‡∏ö multiplier ‡∏ï‡∏≤‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô recovery ‡∏ó‡∏µ‡πà‡πÄ‡∏Ñ‡∏¢‡∏ó‡∏≥
    if(recoveryCount == 0)
        baseMultiplier *= 1.0;
    else if(recoveryCount == 1)
        baseMultiplier *= 1.2;
    else
        baseMultiplier *= 1.5;
    
    // ‚úÖ ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° % ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô
    double lossPercent = MathAbs(orphanProfit) / accountInfo.Balance() * 100.0;
    if(lossPercent > 1.0)
        baseMultiplier *= 1.1;
    if(lossPercent > 2.0)
        baseMultiplier *= 1.2;
    
    double recoveryLot = orphanVolume * baseMultiplier;
    recoveryLot = MathMin(recoveryLot, MaxLot);
    recoveryLot = MathMax(recoveryLot, BaseLot);
    
    Print("üßÆ SAFE ORPHAN LOT CALC | Ticket: #" + TicketToStr(orphanTicket) +
          " | Base Volume: " + DoubleToString(orphanVolume, 2) +
          " | Multiplier: " + DoubleToString(baseMultiplier, 2) +
          " | Result: " + DoubleToString(recoveryLot, 2) +
          " | Recovery Count: " + IntegerToString(recoveryCount));
    
    return NormalizeDouble(recoveryLot, 2);
}
//+------------------------------------------------------------------+
//| Check Orphan Risk - ?????????????????                       |
//+------------------------------------------------------------------+
bool CheckOrphanRisk(int orphanIndex)
{
    double balance = accountInfo.Balance();
    double orphanLoss = MathAbs(universalOrphans[orphanIndex].totalProfit);
    double riskPercent = (orphanLoss / balance) * 100.0;
    
    if(riskPercent > OrphanMaxRiskPerTrade)
    {
        return false;
    }
    
    if(universalOrphans[orphanIndex].recoveryCount >= localMaxOrphanSteps)
    {
        return false;
    }
    
    return true;
}



//+------------------------------------------------------------------+
//| Calculate Orphan Priority Score - ???????????????????      |
//+------------------------------------------------------------------+
double CalculateOrphanPriorityScore(int orphanIndex)
{
    double score = 0;
    
    if(!PositionSelectByTicket(universalOrphans[orphanIndex].ticket)) 
        return 0;
    
    double profit = PositionGetDouble(POSITION_PROFIT);
    double volume = PositionGetDouble(POSITION_VOLUME);
    datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
    
    // 1. ????????? = ???????????? (?????????????)
    score += MathAbs(profit) * 10;
    
    // 2. ???????? = ????????????
    score += volume * 5;
    
    // 3. ????????? = ????????????
    double hoursOpen = (TimeCurrent() - openTime) / 3600.0;
    score += hoursOpen * 2;
    
    // 4. ?????????????????????????????? = ????????????
    score += (localMaxOrphanSteps - universalOrphans[orphanIndex].recoveryCount) * 15;
    
    // 5. ????????????? = ???????????? (?????????????????)
    double riskPercent = MathAbs(profit) / accountInfo.Balance() * 100.0;
    score += (OrphanMaxRiskPerTrade - riskPercent) * 3;
    
    return score;
}

//+------------------------------------------------------------------+
//| Get Orphan Management Status - ?????????????? Orphan         |
//+------------------------------------------------------------------+
string GetOrphanManagementStatus()
{
    string status = "";
    status += "=== ORPHAN MANAGEMENT STATUS ===\n";
    status += "Total Orphans: " + IntegerToString(totalUniversalOrphans) + "\n";
    status += "Processing: " + IntegerToString(MaxOrphansPerCycle) + " per cycle\n";
    status += "Cycle Delay: " + IntegerToString(OrphanProcessDelay) + " seconds\n";
    status += "Priority System: " + (OrphanPrioritySystem ? "ACTIVE" : "INACTIVE") + "\n";
    
    int needHelpCount = 0;
    for(int i = 0; i < totalUniversalOrphans; i++)
    {
        if(PositionSelectByTicket(universalOrphans[i].ticket))
        {
            double profit = PositionGetDouble(POSITION_PROFIT);
            if(profit <= -localOrphanTrigger && universalOrphans[i].recoveryCount < localMaxOrphanSteps)
            {
                needHelpCount++;
            }
        }
    }
    
    status += "Orphans Needing Help: " + IntegerToString(needHelpCount) + "\n";
    status += "Max Risk Per Trade: " + DoubleToString(OrphanMaxRiskPerTrade, 1) + "%";
    
    return status;
}

//+------------------------------------------------------------------+
//| Help Single Orphan - ????????? Orphan ?????                   |
//+------------------------------------------------------------------+
bool HelpSingleOrphan(int orphanIndex)
{
    // ? ????????????? Array ????
    if(orphanIndex < 0 || orphanIndex >= totalUniversalOrphans) 
    {
        DebugPrint(1, "? Invalid orphan index: " + IntegerToString(orphanIndex));
        return false;
    }
    
    ulong orphanTicket = universalOrphans[orphanIndex].ticket;
    
    if(!PositionSelectByTicket(orphanTicket)) 
    {
        Print("? Orphan ticket not found: #" + TicketToStr(orphanTicket));
        return false;
    }
    
    ENUM_POSITION_TYPE orphanType = universalOrphans[orphanIndex].type;
    double orphanVolume = universalOrphans[orphanIndex].volume;
    string symbol = universalOrphans[orphanIndex].symbol;
    double orphanProfit = universalOrphans[orphanIndex].totalProfit;
    
    // ? ?????????????????????????????
    if(orphanStopped[orphanIndex])
    {
        DebugPrint(2, "Orphan stopped: " + TicketToStr(orphanTicket));
        return false;
    }
    
    // ? ??????? Cooldown ???? (3 ?????)
    if(TimeCurrent() - lastOrphanHelpTime[orphanIndex] < 180) 
    {
        DebugPrint(2, "Orphan in cooldown: " + TicketToStr(orphanTicket));
        return false;
    }
    
    // ? ??????????????????????????
    if(orphanHelpAttempts[orphanIndex] >= 3) 
    {
        DebugPrint(1, "? MAX HELP ATTEMPTS REACHED for Orphan: " + TicketToStr(orphanTicket));
        orphanStopped[orphanIndex] = true; // ???????????????
        return false;
    }
    
    // ? ???????????????????????????????
    if(!CheckOrphanRisk(orphanIndex))
    {
        Print("?? RISK LIMIT EXCEEDED for Orphan: #" + TicketToStr(orphanTicket));
        return false;
    }
    
    // ??????????????????
    double recoveryLot = CalculateSafeOrphanLot(orphanIndex);
    
    if(!CheckMargin(recoveryLot, symbol))
    {
        Print("? Margin insufficient for orphan recovery: " + DoubleToString(recoveryLot, 2));
        return false;
    }
    
    // ????????????????????
trade.SetExpertMagicNumber(MAGIC_ORPHAN);
   bool success = false;
   ulong recoveryTicket = 0;
   string comment = "Orphan-Help-" + TicketToStr(orphanTicket) + "-" + IntegerToString(universalOrphans[orphanIndex].recoveryCount + 1);
   
   if(orphanType == POSITION_TYPE_BUY)
   {
      success = trade.Sell(recoveryLot, symbol, 0, 0, 0, comment);
   }
   else
   {
      success = trade.Buy(recoveryLot, symbol, 0, 0, 0, comment);
   }
   
   if(success)
   {
      recoveryTicket = trade.ResultOrder();
      universalOrphans[orphanIndex].recoveryCount++;
      
      Print("?? SINGLE ORPHAN HELP: Orphan #" + TicketToStr(orphanTicket) +
            " | Strategy: " + universalOrphans[orphanIndex].originalStrategy +
            " | Loss: $" + DoubleToString(orphanProfit, 2) +
            " | Help #" + TicketToStr(recoveryTicket) +
            " | Lot: " + DoubleToString(recoveryLot, 2) +
            " | Magic: " + IntegerToString(MAGIC_ORPHAN) + // ? ???? Magic ????
            " | Help Count: " + IntegerToString(universalOrphans[orphanIndex].recoveryCount));
      
      return true;
    }
    else
    {
        Print("? Failed to help orphan: " + trade.ResultRetcodeDescription());
        return false;
    }
}
//+------------------------------------------------------------------+
//| ??????????????????????? Orphan ????                          |
//+------------------------------------------------------------------+
bool isOrphanProcessing = false;        // ? ????????????????????????
int currentProcessingOrphan = -1;       // ? Orphan ????????????????
datetime lastOrphanCompletionTime = 0;  // ? ????????????????????????????

//+------------------------------------------------------------------+
//| ?????? Universal Orphans (?????????????)                     |
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//| ??????????????? Orphan Management                             |
//+------------------------------------------------------------------+
void StartNewOrphanCycle()
{
   currentOrphanProcessCount = 0;
   orphanCycleCompleted = false;
   lastOrphanCycleTime = TimeCurrent();
   
   // ?????????????? Orphans ????
   CheckAllStrategiesForOrphans();
   
   // ???? Orphans ???????????
   CleanUpClosedUniversalOrphans();
   
   Print("?? ORPHAN CYCLE STARTED | Max: " + IntegerToString(Orphan_MaxPerCycle) + " per cycle");
}

//+------------------------------------------------------------------+
//| ??????????? Orphan Management                                |
//+------------------------------------------------------------------+
void ProcessOrphanCycle()
{
   // ? ?????????????????????????????
   if(currentOrphanProcessCount >= Orphan_MaxPerCycle)
   {
      orphanCycleCompleted = true;
      Print("? ORPHAN CYCLE COMPLETED | Processed: " + IntegerToString(currentOrphanProcessCount));
      return;
   }
   
   // ? ????????????????????
   if(OrphanPrioritySystem)
   {
      SortOrphansByPriority();
   }
   
   // ? ????? Orphan ????????????????
   int bestOrphanIndex = FindBestOrphanCandidate();
   
   if(bestOrphanIndex == -1)
   {
      orphanCycleCompleted = true;
      Print("?? ORPHAN CYCLE COMPLETED | No suitable orphans found");
      return;
   }
   
   // ? ????????? Orphan
   if(HelpSingleOrphanStrict(bestOrphanIndex))
   {
      currentOrphanProcessCount++;
      Print("?? ORPHAN PROGRESS: " + IntegerToString(currentOrphanProcessCount) + 
            "/" + IntegerToString(Orphan_MaxPerCycle));
   }
   
   // ? ?????????????????????
   Sleep(1000);
}

//+------------------------------------------------------------------+
//| ????? Orphan Candidate ????????????????                      |
//+------------------------------------------------------------------+
int FindBestOrphanCandidate()
{
   int bestIndex = -1;
   double bestScore = -1;
   
   for(int i = 0; i < totalUniversalOrphans; i++)
   {
      // ? ???? orphan ????????????????
      if(orphanStopped[i]) continue;
      
      if(!PositionSelectByTicket(universalOrphans[i].ticket)) continue;
      
      double currentProfit = PositionGetDouble(POSITION_PROFIT);
      universalOrphans[i].totalProfit = currentProfit;
      
      // ? ?????????????????
      bool canHelp = (currentProfit <= -localOrphanTrigger) && 
                    (universalOrphans[i].recoveryCount < localMaxOrphanSteps) &&
                    (orphanHelpAttempts[i] < 3) &&
                    (TimeCurrent() - lastOrphanHelpTime[i] >= 180);
      
      if(canHelp)
      {
         double score = CalculateOrphanPriorityScore(i);
         if(score > bestScore)
         {
            bestScore = score;
            bestIndex = i;
         }
      }
   }
   
   return bestIndex;
}


//+------------------------------------------------------------------+
//| ????????? Orphan ????? (?????????????????)                   |
//+------------------------------------------------------------------+
bool HelpSingleOrphanStrict(int orphanIndex)
{
    if(orphanIndex < 0 || orphanIndex >= totalUniversalOrphans) 
    {
        DebugPrint(1, "? Invalid orphan index: " + IntegerToString(orphanIndex));
        return false;
    }
    
    ulong orphanTicket = universalOrphans[orphanIndex].ticket;
    
    if(!PositionSelectByTicket(orphanTicket)) 
    {
        Print("? Orphan ticket not found: #" + TicketToStr(orphanTicket));
        return false;
    }
    
    // ? ????????????????????????????????
    double currentProfit = PositionGetDouble(POSITION_PROFIT);
    if(currentProfit > -localOrphanTrigger)
    {
        DebugPrint(2, "Orphan no longer needs help: " + TicketToStr(orphanTicket));
        return false;
    }
    
    ENUM_POSITION_TYPE orphanType = universalOrphans[orphanIndex].type;
    double orphanVolume = universalOrphans[orphanIndex].volume;
    string symbol = universalOrphans[orphanIndex].symbol;
    
    // ? ?????????????????????????
    if(!CheckOrphanRisk(orphanIndex))
    {
        Print("?? RISK LIMIT EXCEEDED for Orphan: #" + TicketToStr(orphanTicket));
        return false;
    }
    
    // ??????????????????
    double recoveryLot = CalculateSafeOrphanLot(orphanIndex);
    
    if(!CheckMargin(recoveryLot, symbol))
    {
        Print("? Margin insufficient for orphan recovery: " + DoubleToString(recoveryLot, 2));
        return false;
    }
    
    // ????????????????????
    trade.SetExpertMagicNumber(MAGIC_ORPHAN);
    bool success = false;
    ulong recoveryTicket = 0;
    string comment = "Orphan-Help-" + TicketToStr(orphanTicket) + "-" + 
                     IntegerToString(universalOrphans[orphanIndex].recoveryCount + 1);
    
    if(orphanType == POSITION_TYPE_BUY)
    {
        success = trade.Sell(recoveryLot, symbol, 0, 0, 0, comment);
    }
    else
    {
        success = trade.Buy(recoveryLot, symbol, 0, 0, 0, comment);
    }
    
    if(success)
    {
        recoveryTicket = trade.ResultOrder();
        universalOrphans[orphanIndex].recoveryCount++;
        lastOrphanHelpTime[orphanIndex] = TimeCurrent();
        
        Print("?? SINGLE ORPHAN HELP SUCCESS: Orphan #" + TicketToStr(orphanTicket) +
              " | Strategy: " + universalOrphans[orphanIndex].originalStrategy +
              " | Loss: $" + DoubleToString(currentProfit, 2) +
              " | Help #" + TicketToStr(recoveryTicket) +
              " | Lot: " + DoubleToString(recoveryLot, 2) +
              " | Help Count: " + IntegerToString(universalOrphans[orphanIndex].recoveryCount));
        
        return true;
    }
    else
    {
        Print("? Failed to help orphan: " + trade.ResultRetcodeDescription());
        return false;
    }
}




//+------------------------------------------------------------------+
//| CalculateSetTP - Fixed Version                                  |
//+------------------------------------------------------------------+
void CalculateSetTP(int setIndex)
{
   if(setIndex < 0 || setIndex >= totalRecoverySets) return;
   
   double mainProfit = 0;
   double mainVolume = 0;
   string symbol = "";
   
   if(PositionSelectByTicket(recoverySets[setIndex].mainTicket))
   {
      mainProfit = PositionGetDouble(POSITION_PROFIT);
      mainVolume = PositionGetDouble(POSITION_VOLUME);
      symbol = PositionGetString(POSITION_SYMBOL);
   }
   
   double mainLoss = MathAbs(mainProfit);
   int recoveryCount = recoverySets[setIndex].subCount;
   double setTP = 0;
   
   if(SetTP_Fixed > 0) setTP = SetTP_Fixed;
   
   if(SetTP_DynamicPercent > 0)
   {
      double dynamicTP = mainLoss * (SetTP_DynamicPercent / 100.0);
      if(dynamicTP > setTP) setTP = dynamicTP;
   }
   
   if(UseAdaptiveTP && recoveryCount > 0)
   {
      double recoveryBonus = recoveryCount * TP_PerRecoveryBonus;
      setTP += recoveryBonus;
   }
   
   if(UseTimeBasedTP)
   {
      datetime setOpenTime = recoverySets[setIndex].createdTime;
      double minutesOpen = (TimeCurrent() - setOpenTime) / 60.0;
      double timeBonus = minutesOpen * TP_TimeBonus;
      setTP += timeBonus;
   }
   
   setTP = MathMax(setTP, MinSetTP);
   setTP = MathMin(setTP, MaxSetTP);
   
   if(mainVolume > 0.10)
   {
      double volumeFactor = 1.0 - ((mainVolume - 0.10) * 2.0);
      volumeFactor = MathMax(volumeFactor, 0.5);
      setTP *= volumeFactor;
   }
   
   Print("?? SET TP CALCULATION: Main " + TicketToStr(recoverySets[setIndex].mainTicket) + 
         " | Base TP: $" + DoubleToString(setTP, 2) +
         " | Recovery Count: " + IntegerToString(recoveryCount) +
         " | Main Loss: $" + DoubleToString(mainLoss, 2));
}

// ? ???????????????? TP Settings
void PrintTPSettings()
{
   Print("=== INDIVIDUAL RECOVERY TP SETTINGS ===");
   Print("Fixed TP: $" + DoubleToString(SetTP_Fixed, 2));
   Print("Dynamic TP: " + DoubleToString(SetTP_DynamicPercent, 1) + "% of main loss");
   Print("Min TP: $" + DoubleToString(MinSetTP, 2));
   Print("Max TP: $" + DoubleToString(MaxSetTP, 2));
   Print("Recovery Bonus: $" + DoubleToString(TP_PerRecoveryBonus, 2) + " per ticket");
   Print("Time Based TP: " + (UseTimeBasedTP ? "ON" : "OFF"));
   if(UseTimeBasedTP)
   {
      Print("Time Factor: " + IntegerToString(TP_TimeFactorMinutes) + " minutes");
      Print("Time Bonus: $" + DoubleToString(TP_TimeBonus, 2) + " per minute");
   }
}
//+------------------------------------------------------------------+
//| Calculate scalp                              |
//+------------------------------------------------------------------+
double CalculateScalpLot()
{
   double base_scalp_lot = BaseLot * Current_Scalp1_Lot_Multiplier;  // ‚úÖ ‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÉ‡∏´‡∏°‡πà
   
   base_scalp_lot = MathMin(base_scalp_lot, MaxLot);
   base_scalp_lot = MathMax(base_scalp_lot, BaseLot);
   
   return NormalizeDouble(base_scalp_lot, 2);
}
//+------------------------------------------------------------------+
//| InitializeNewSet - ????? Set ????                              |
//+------------------------------------------------------------------+
int InitializeNewSet(ulong mainTicket)
{
   if(totalRecoverySets >= 50)
   {
      Print("? Maximum recovery sets reached (50)");
      return -1;
   }
   
   if(!PositionSelectByTicket(mainTicket))
   {
      Print("? Main ticket not found: ", TicketToStr(mainTicket));
      return -1;
   }
   
   RecoverySet newSet;
   newSet.setNumber = nextSetNumber;
   newSet.mainTicket = mainTicket;
   newSet.subCount = 0;
   newSet.mainProfit = PositionGetDouble(POSITION_PROFIT);
   newSet.subsProfit = 0;
   newSet.totalProfit = newSet.mainProfit;
   newSet.isCompleted = false;
   newSet.createdTime = TimeCurrent();
   
   // Initialize subTickets array
   for(int i = 0; i < 20; i++)
      newSet.subTickets[i] = 0;
   
   recoverySets[totalRecoverySets] = newSet;
   totalRecoverySets++;
   
   Print("? NEW RECOVERY SET #", newSet.setNumber, " Created | Main: #", TicketToStr(mainTicket),
         " | Initial Loss: $", DoubleToString(newSet.mainProfit, 2));
   
   nextSetNumber++;
   return newSet.setNumber;
}

//+------------------------------------------------------------------+
//| AddSubOrderToSet - ?????????????????????                       |
//+------------------------------------------------------------------+
bool AddSubOrderToSet(int setNumber, ulong subTicket)
{
   int setIndex = FindSetIndex(setNumber);
   if(setIndex == -1)
   {
      Print("? Set not found: #", setNumber);
      return false;
   }
   
   if(recoverySets[setIndex].subCount >= 20)
   {
      Print("? Maximum sub orders reached for set #", setNumber);
      return false;
   }
   
   if(!PositionSelectByTicket(subTicket))
   {
      Print("? Sub ticket not found: #", TicketToStr(subTicket));
      return false;
   }
   
   // Add to array
   recoverySets[setIndex].subTickets[recoverySets[setIndex].subCount] = subTicket;
   recoverySets[setIndex].subCount++;
   
   Print("? Added Sub Order to Set #", setNumber, " | Sub: #", TicketToStr(subTicket),
         " | Total Subs: ", recoverySets[setIndex].subCount);
   
   return true;
}

//+------------------------------------------------------------------+
//| FindSetIndex - ????? Set ?????? Set Number                     |
//+------------------------------------------------------------------+
int FindSetIndex(int setNumber)
{
   for(int i = 0; i < totalRecoverySets; i++)
   {
      if(recoverySets[i].setNumber == setNumber && !recoverySets[i].isCompleted)
         return i;
   }
   return -1;
}

//+------------------------------------------------------------------+
//| FindSetByMainTicket - ????? Set ?????? Main Ticket             |
//+------------------------------------------------------------------+
int FindSetByMainTicket(ulong mainTicket)
{
    for(int i = 0; i < totalRecoverySets; i++)
    {
        if(recoverySets[i].mainTicket == mainTicket && !recoverySets[i].isCompleted)
            return i;
    }
    return -1;
}
//+------------------------------------------------------------------+
//| CalculateSetProfit - ????????????? Set                        |
//+------------------------------------------------------------------+
double CalculateSetProfit(int setIndex)
{
    if(setIndex < 0 || setIndex >= totalRecoverySets)
        return 0;
    
    double totalProfit = 0;
    bool mainExists = false;
    
    // 1. Check Main Ticket
    if(PositionSelectByTicket(recoverySets[setIndex].mainTicket))
    {
        recoverySets[setIndex].mainProfit = PositionGetDouble(POSITION_PROFIT);
        totalProfit += recoverySets[setIndex].mainProfit;
        mainExists = true;
    }
    else
    {
        // MAIN TICKET MISSING!
        recoverySets[setIndex].mainProfit = 0;
        mainExists = false;
        
        // Register Recovery Tickets as Orphans
        for(int i = 0; i < recoverySets[setIndex].subCount; i++)
        {
            ulong subTicket = recoverySets[setIndex].subTickets[i];
            if(PositionSelectByTicket(subTicket))
            {
                // ‚úÖ Use the new Orphan Job System instead of NotifyUniversalOrphan
                RegisterOrphan(subTicket, 
                              MAGIC_RECOVERY, 
                              "Recovery-Set-" + IntegerToString(recoverySets[setIndex].setNumber));
            }
        }
        
        // Mark set as completed
        recoverySets[setIndex].isCompleted = true;
        Print("üîî Set #" + IntegerToString(recoverySets[setIndex].setNumber) + 
              " marked as completed (Main missing)");
    }
    
    // 2. Calculate Sub Tickets Profit
    recoverySets[setIndex].subsProfit = 0;
    for(int i = 0; i < recoverySets[setIndex].subCount; i++)
    {
        if(PositionSelectByTicket(recoverySets[setIndex].subTickets[i]))
        {
            double subProfit = PositionGetDouble(POSITION_PROFIT);
            recoverySets[setIndex].subsProfit += subProfit;
            totalProfit += subProfit;
        }
    }
    
    recoverySets[setIndex].totalProfit = totalProfit;
    return totalProfit;
}

//+------------------------------------------------------------------+
//| IsSetProfitable - ?????????????????????????                   |
//+------------------------------------------------------------------+
bool IsSetProfitable(int setIndex)
{
   if(setIndex < 0 || setIndex >= totalRecoverySets) return false;
   if(!PositionSelectByTicket(recoverySets[setIndex].mainTicket)) return false;
   
   double setProfit = CalculateSetProfit(setIndex);
   double mainProfit = recoverySets[setIndex].mainProfit;
   
   // ‚úÖ ‡∏ï‡πâ‡∏≠‡∏á‡∏ú‡πà‡∏≤‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ô‡∏µ‡πâ‡∏ñ‡∏∂‡∏á‡∏õ‡∏¥‡∏î:
   
   // 1. Main ‡∏¢‡∏±‡∏á‡∏≠‡∏¢‡∏π‡πà
   bool mainExists = PositionSelectByTicket(recoverySets[setIndex].mainTicket);
   
   // 2. ‡∏ó‡∏±‡πâ‡∏á Set ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≥‡πÑ‡∏£ (‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î!)
   bool totalProfitPositive = (setProfit > 0);
   
   // 3. ‡∏´‡∏£‡∏∑‡∏≠ Recovery ‡∏ï‡πâ‡∏≠‡∏á cover loss ‡πÑ‡∏î‡πâ + buffer
   bool recoveryCovers = (recoverySets[setIndex].subsProfit > MathAbs(mainProfit) * 1.05); // +5% buffer
   
   return mainExists && (totalProfitPositive || recoveryCovers);
}

void ManageSetsWithMain()
{
    for(int i = 0; i < totalRecoverySets; i++)
    {
        if(recoverySets[i].isCompleted) continue;
        if(IsMainTicketMissing(i)) continue;
        
        double mainLoss = MathAbs(recoverySets[i].mainProfit);
        
        // ‚úÖ ‡πÉ‡∏ä‡πâ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
        if(recoverySets[i].subsProfit >= mainLoss + MinSetTP)
        {
            Print("‚úÖ Closing complete set - Recovery covers main loss + profit");
            CloseCompleteSet(i);
            recoverySets[i].isCompleted = true;
        }
    }
}
//+------------------------------------------------------------------+
//| ManageOrphanedRecoverySets -                                     |
//+------------------------------------------------------------------+
void ManageOrphanedRecoverySets()
{
    for(int i = 0; i < totalRecoverySets; i++)
    {
        if(recoverySets[i].isCompleted) continue;
        if(!IsMainTicketMissing(i)) continue; // ‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏£‡∏ì‡∏µ Main ‡∏≠‡∏¢‡∏π‡πà
        
        double mainLossBeforeMissing = MathAbs(recoverySets[i].mainProfit);
        
        // ‚úÖ ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£
        double currentRecoveryTotal = 0;
        
        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Å‡∏≥‡πÑ‡∏£ Recovery ‡∏£‡∏ß‡∏°‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
        for(int j = 0; j < recoverySets[i].subCount; j++)
        {
            ulong subTicket = recoverySets[i].subTickets[j];
            if(PositionSelectByTicket(subTicket))
            {
                currentRecoveryTotal += PositionGetDouble(POSITION_PROFIT);
            }
        }
        
        // ‚úÖ ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏õ‡∏¥‡∏î: Recovery ‡∏£‡∏ß‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏° Main Loss
        if(currentRecoveryTotal >= mainLossBeforeMissing + MinSetTP)
        {
            // ‡∏õ‡∏¥‡∏î Recovery Orders ‡∏ó‡∏µ‡∏•‡∏∞‡∏ï‡∏±‡∏ß
            for(int j = 0; j < recoverySets[i].subCount; j++)
            {
                ulong subTicket = recoverySets[i].subTickets[j];
                if(PositionSelectByTicket(subTicket))
                {
                    trade.PositionClose(subTicket);
                    Print("‚úÖ Closed orphan recovery: #", TicketToStr(subTicket));
                }
            }
            recoverySets[i].isCompleted = true;
            Print("üì¶ Orphan set completed - Recoveries covered main loss");
        }
        else
        {
            // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞ Recovery ‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÑ‡∏´‡∏°
            for(int j = 0; j < recoverySets[i].subCount; j++)
            {
                ulong subTicket = recoverySets[i].subTickets[j];
                if(PositionSelectByTicket(subTicket))
                {
                    double profit = PositionGetDouble(POSITION_PROFIT);
                    
                    // ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏ñ‡∏∂‡∏á Trigger ‚Üí ‡∏™‡πà‡∏á‡πÉ‡∏´‡πâ Orphan System
                    if(profit <= -localOrphanTrigger)
                    {
                        Print("üÜò Orphan recovery needs help: #", TicketToStr(subTicket), " | Loss: $", profit);
                        RegisterOrphan(subTicket, MAGIC_INDIVIDUAL, "Recovery-Orphan");
                    }
                }
            }
        }
    }
}
//+------------------------------------------------------------------+
//| RemoveSetByMainTicket - ?????? Set ?????? Main Ticket         |
//+------------------------------------------------------------------+
bool RemoveSetByMainTicket(ulong mainTicket)
{
   int setIndex = FindSetByMainTicket(mainTicket);
   if(setIndex == -1)
      return false;
   
   Print("??? Removing Set #", recoverySets[setIndex].setNumber, " | Main: #", TicketToStr(mainTicket));
   
   // Mark as completed
   recoverySets[setIndex].isCompleted = true;
   
   // Compact array
   CompactRecoverySets();
   
   return true;
}

//+------------------------------------------------------------------+
//| RemoveOrderFromSet - ??????????????                          |
//+------------------------------------------------------------------+
bool RemoveOrderFromSet(ulong orderTicket)
{
   for(int i = 0; i < totalRecoverySets; i++)
   {
      if(recoverySets[i].isCompleted) continue;
      
      // Check main ticket
      if(recoverySets[i].mainTicket == orderTicket)
      {
         Print("??? Removing Main Order from Set #", recoverySets[i].setNumber, " | Ticket: #", TicketToStr(orderTicket));
         recoverySets[i].isCompleted = true;
         CompactRecoverySets();
         return true;
      }
      
      // Check sub tickets
      for(int j = 0; j < recoverySets[i].subCount; j++)
      {
         if(recoverySets[i].subTickets[j] == orderTicket)
         {
            Print("??? Removing Sub Order from Set #", recoverySets[i].setNumber, " | Ticket: #", TicketToStr(orderTicket));
            return RemoveSubTicketFromSet(i, j);
         }
      }
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| RemoveSubTicketFromSet - ?? Sub ?????? Set                   |
//+------------------------------------------------------------------+
bool RemoveSubTicketFromSet(int setIndex, int subIndex)
{
   if(setIndex < 0 || setIndex >= totalRecoverySets)
      return false;
   
   if(subIndex < 0 || subIndex >= recoverySets[setIndex].subCount)
      return false;
   
   // Shift array left
   for(int i = subIndex; i < recoverySets[setIndex].subCount - 1; i++)
   {
      recoverySets[setIndex].subTickets[i] = recoverySets[setIndex].subTickets[i + 1];
   }
   
   recoverySets[setIndex].subTickets[recoverySets[setIndex].subCount - 1] = 0;
   recoverySets[setIndex].subCount--;
   
   return true;
}

//+------------------------------------------------------------------+
//| CompactRecoverySets - ?????? Array ???????                   |
//+------------------------------------------------------------------+
void CompactRecoverySets()
{
   int newIndex = 0;
   for(int i = 0; i < totalRecoverySets; i++)
   {
      if(!recoverySets[i].isCompleted)
      {
         if(i != newIndex)
            recoverySets[newIndex] = recoverySets[i];
         newIndex++;
      }
   }
   totalRecoverySets = newIndex;
}

//+------------------------------------------------------------------+
//| AutoRemoveProfitableSets - ?? Set ???????????????????        |
//+------------------------------------------------------------------+
void AutoRemoveProfitableSets()
{
   int removedCount = 0;
   
   for(int i = 0; i < totalRecoverySets; i++)
   {
      if(recoverySets[i].isCompleted) continue;
      
      if(IsSetProfitable(i))
      {
         Print("?? AUTO REMOVE: Set #", recoverySets[i].setNumber, " is profitable | Total Profit: $", 
               DoubleToString(recoverySets[i].totalProfit, 2));
         
         // Close all positions in the set
         CloseCompleteSet(i);
         removedCount++;
      }
   }
   
   if(removedCount > 0)
   {
      Print("?? AUTO REMOVE SUMMARY: ", removedCount, " sets removed");
      CompactRecoverySets();
   }
}

//+------------------------------------------------------------------+
//| CloseCompleteSet - ??????? Set                               |
//+------------------------------------------------------------------+
void CloseCompleteSet(int setIndex)
{
   if(setIndex < 0 || setIndex >= totalRecoverySets)
      return;
   
   int closedCount = 0;
   
   // Close main ticket
   if(PositionSelectByTicket(recoverySets[setIndex].mainTicket))
   {
      if(trade.PositionClose(recoverySets[setIndex].mainTicket))
      {
         closedCount++;
         Print("? Closed Main: #", TicketToStr(recoverySets[setIndex].mainTicket));
      }
   }
   
   // Close sub tickets
   for(int i = 0; i < recoverySets[setIndex].subCount; i++)
   {
      if(PositionSelectByTicket(recoverySets[setIndex].subTickets[i]))
      {
         if(trade.PositionClose(recoverySets[setIndex].subTickets[i]))
         {
            closedCount++;
            Print("? Closed Sub: #", TicketToStr(recoverySets[setIndex].subTickets[i]));
         }
      }
   }
   
   recoverySets[setIndex].isCompleted = true;
   
   Print("?? SET #", recoverySets[setIndex].setNumber, " COMPLETED | Closed ", closedCount, 
         " positions | Total Profit: $", DoubleToString(recoverySets[setIndex].totalProfit, 2));
}

//+------------------------------------------------------------------+
//| CleanUpClosedOrders - ??????????????????????????? Array      |
//+------------------------------------------------------------------+
void CleanUpClosedOrders()
{
   int cleanedCount = 0;
   
   for(int i = 0; i < totalRecoverySets; i++)
   {
      if(recoverySets[i].isCompleted) continue;
      
      // Check main ticket
      if(!PositionSelectByTicket(recoverySets[i].mainTicket))
      {
         Print("?? Cleaning closed Main Order from Set #", recoverySets[i].setNumber);
         recoverySets[i].isCompleted = true;
         cleanedCount++;
         continue;
      }
      
      // Check sub tickets
      for(int j = recoverySets[i].subCount - 1; j >= 0; j--)
      {
         if(!PositionSelectByTicket(recoverySets[i].subTickets[j]))
         {
            Print("?? Cleaning closed Sub Order from Set #", recoverySets[i].setNumber);
            RemoveSubTicketFromSet(i, j);
            cleanedCount++;
         }
      }
      
      // If no sub tickets left and main is closed, mark as completed
      if(recoverySets[i].subCount == 0 && !PositionSelectByTicket(recoverySets[i].mainTicket))
      {
         recoverySets[i].isCompleted = true;
         cleanedCount++;
      }
   }
   
   if(cleanedCount > 0)
   {
      CompactRecoverySets();
      Print("?? CLEANUP: Removed ", cleanedCount, " closed orders from sets");
   }
}
//+------------------------------------------------------------------+
//| ???????????????????????????? Individual Recovery              |
//+------------------------------------------------------------------+
double CalculateRecoveryPriorityScore(ulong mainTicket, double profit, int recoveryCount)
{
   double score = 0;
   
   if(!PositionSelectByTicket(mainTicket)) return 0;
   
   double lossAmount = MathAbs(profit);
   double volume = PositionGetDouble(POSITION_VOLUME);
   datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
   
   // 1. ????????? = ???????????? (?????????????)
   score += lossAmount * 10;
   
   // 2. ???????? = ????????????
   score += volume * 5;
   
   // 3. ????????? = ????????????
   double hoursOpen = (TimeCurrent() - openTime) / 3600.0;
   score += hoursOpen * 2;
   
   // 4. ?????????????????????????????? = ????????????
   score += (localMaxRecovery  - recoveryCount) * 20;
   
   // 5. ????????????? = ???????????? (?????????????????)
   double riskPercent = lossAmount / accountInfo.Balance() * 100.0;
   score += (5.0 - riskPercent) * 3; // 5% ????????????????
   
   return score;
}




//+------------------------------------------------------------------+
//| ??????????????????????? Individual Recovery ????            |
//+------------------------------------------------------------------+
bool isIndividualRecoveryProcessing = false;        // ? ????????????????????????
ulong currentProcessingMainTicket = 0;              // ? Main Ticket ????????????????
datetime lastIndividualRecoveryTime = 0;            // ? ??????????????????
int individualRecoveryCooldown = 10;                // ? Cooldown ??????????????????? (??????)

//+------------------------------------------------------------------+
//| ?????? Individual Recovery Sets (?????????????)              |
//+------------------------------------------------------------------+
void ManageIndividualRecoverySets()
{
   if(!EnableIndividualRecovery) return;
   
   // ? ??????????????????????
   if(individualCycleCompleted && (TimeCurrent() - lastIndividualCycleTime >= Individual_CooldownSec))
   {
      StartNewIndividualCycle();
   }
   
   // ? ????????????????????????
   if(!individualCycleCompleted) 
   {
      ProcessIndividualCycle();
   }

   // ? ?????????????????
   UpdateAllSetProfits();

   // ?????????? (??? 5 ?????)
   static datetime lastStatusPrint = 0;
   if(TimeCurrent() - lastStatusPrint > 300)
   {
      PrintIndividualRecoveryStatus();
      lastStatusPrint = TimeCurrent();
   }
}

//+------------------------------------------------------------------+
//| ????????? Individual Recovery                                 |
//+------------------------------------------------------------------+
void PrintIndividualRecoveryStatus()
{
   Print("=== INDIVIDUAL RECOVERY STATUS ===");
   Print("Cycle: " + (individualCycleCompleted ? "COMPLETED" : "PROCESSING") + 
         " | Progress: " + IntegerToString(currentIndividualProcessCount) + 
         "/" + IntegerToString(Individual_MaxPerCycle));
   Print("Total Sets: " + IntegerToString(totalRecoverySets));
   Print("Wait For Close: " + (Individual_WaitForClose ? "YES" : "NO"));
   Print("Cooldown: " + IntegerToString(Individual_CooldownSec) + "s");
   Print("=== END INDIVIDUAL STATUS ===");
}
//+------------------------------------------------------------------+
//| ????? Candidate ?????????????????????? Individual Recovery   |
//+------------------------------------------------------------------+
ulong FindBestRecoveryCandidate()
{
   ulong bestTicket = 0;
   double bestScore = -1;
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(!PositionSelectByTicket(ticket)) continue;
      
      long magic = PositionGetInteger(POSITION_MAGIC);
      double profit = PositionGetDouble(POSITION_PROFIT);
      
      // ? ????????????????????????????
      if(IsHelperPosition(magic)) continue;
      
      // ? ?????????????????????????
      if(profit <= -IndividualRecoveryTrigger)
      {
         // ? ??????????????? Set ???????? ???????????????????????
         int setIndex = FindSetByMainTicket(ticket);
         int recoveryCount = (setIndex != -1) ? recoverySets[setIndex].subCount : 0;
         
         if(recoveryCount < localMaxRecovery )
         {
            double score = CalculateRecoveryPriorityScore(ticket, profit, recoveryCount);
            
            if(score > bestScore)
            {
               bestScore = score;
               bestTicket = ticket;
            }
         }
      }
   }
   
   if(bestTicket != 0)
   {
      Print("?? Found recovery candidate: #" + TicketToStr(bestTicket) + " | Score: " + DoubleToString(bestScore, 1));
   }
   
   return bestTicket;
}
//+------------------------------------------------------------------+
//| OpenSingleRecoveryOrder - ‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå Recovery ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡∏±‡∏ß      |
//+------------------------------------------------------------------+
bool OpenSingleRecoveryOrder(ulong mainTicket)
{
    

    if(!PositionSelectByTicket(mainTicket)) 
    {
        Print("‚ùå Main ticket not found: " + TicketToStr(mainTicket));
        return false;
    }
    
    ENUM_POSITION_TYPE mainType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
    double mainVolume = PositionGetDouble(POSITION_VOLUME);
    string symbol = PositionGetString(POSITION_SYMBOL);
    double mainProfit = PositionGetDouble(POSITION_PROFIT);
    
    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Main ‡∏¢‡∏±‡∏á‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ Recovery ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if(mainProfit > -IndividualRecoveryTrigger)
    {
        DebugPrint(2, "Main no longer needs recovery: " + TicketToStr(mainTicket));
        return false;
    }
    
    // ‚úÖ ‡∏´‡∏≤ Set ‡πÅ‡∏•‡∏∞‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Recovery ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
    int setIndex = FindSetByMainTicket(mainTicket);
    int recoveryCount = (setIndex != -1) ? recoverySets[setIndex].subCount : 0;
    
    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Recovery ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î
    if(recoveryCount >= localMaxRecovery)
    {
        DebugPrint(2, "Max recovery reached for: " + TicketToStr(mainTicket));
        return false;
    }
    
    // ‚úÖ ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏•‡πá‡∏≠‡∏ï Recovery
    double recoveryLot = mainVolume * localRecoveryMultiplier;
    recoveryLot = MathMin(recoveryLot, MaxLot);
    recoveryLot = NormalizeDouble(recoveryLot, 2);
    
    if(!CheckMargin(recoveryLot, symbol))
    {
        Print("‚ùå Margin insufficient for recovery: " + DoubleToString(recoveryLot, 2));
        return false;
    }
    
    // ‚úÖ ‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå Recovery
    trade.SetExpertMagicNumber(MAGIC_INDIVIDUAL);
    bool success = false;
    ulong recoveryTicket = 0;
    
    string comment = "Individual-Recov-" + TicketToStr(mainTicket);
    
    if(mainType == POSITION_TYPE_BUY)
    {
        success = trade.Sell(recoveryLot, symbol, 0, 0, 0, comment);
    }
    else
    {
        success = trade.Buy(recoveryLot, symbol, 0, 0, 0, comment);
    }
    
    if(success)
    {
        recoveryTicket = trade.ResultOrder();
        
        // ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á Set ‡πÉ‡∏´‡∏°‡πà‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ
        if(setIndex == -1)
        {
            int newSetNumber = InitializeNewSet(mainTicket);
            if(newSetNumber != -1)
            {
                setIndex = FindSetIndex(newSetNumber);
            }
        }
        
        // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° Recovery ‡∏•‡∏á‡πÉ‡∏ô Set
        if(setIndex != -1)
        {
            AddSubOrderToSet(recoverySets[setIndex].setNumber, recoveryTicket);
            
            Print("‚úÖ SINGLE INDIVIDUAL RECOVERY | Set #" + IntegerToString(recoverySets[setIndex].setNumber) +
                  " | Main: #" + TicketToStr(mainTicket) +
                  " | Recovery: #" + TicketToStr(recoveryTicket) +
                  " | Lot: " + DoubleToString(recoveryLot, 2) +
                  " | Magic: " + IntegerToString(MAGIC_INDIVIDUAL) +
                  " | Direction: " + (mainType == POSITION_TYPE_BUY ? "SELL" : "BUY") +
                  " | Recovery Count: " + IntegerToString(recoveryCount + 1));
                  
            return true;
        }
    }
    else
    {
        Print("‚ùå Failed to open individual recovery: " + trade.ResultRetcodeDescription());
    }
    
    return false;
}
//+------------------------------------------------------------------+
//| ??????????? Individual Recovery (?????????????)             |
//+------------------------------------------------------------------+
void ProcessIndividualCycle()
{
   // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ñ‡∏£‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ï‡πà‡∏≠‡∏£‡∏≠‡∏ö‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
   if(currentIndividualProcessCount >= Individual_MaxPerCycle)
   {
      // ‚úÖ ‡πÇ‡∏´‡∏°‡∏î‡∏£‡∏≠‡∏õ‡∏¥‡∏î Set ‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏£‡∏≠‡∏ö‡πÉ‡∏´‡∏°‡πà
      if(Individual_WaitForClose)
      {
         // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ Set ‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏õ‡∏¥‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
         bool hasActiveSets = false;
         for(int i = 0; i < totalRecoverySets; i++)
         {
            if(!recoverySets[i].isCompleted)
            {
               hasActiveSets = true;
               break;
            }
         }
         
         if(hasActiveSets)
         {
            DebugPrint(2, "‚è≥ Waiting for active sets to close before next cycle...");
            return; // ‡∏£‡∏≠‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤ Set ‡∏à‡∏∞‡∏õ‡∏¥‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
         }
         else
         {
            // ‡πÑ‡∏°‡πà‡∏°‡∏µ Set ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà - ‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î‡∏£‡∏≠‡∏ö
            individualCycleCompleted = true;
            Print("‚úÖ INDIVIDUAL CYCLE COMPLETED | All sets closed | Processed: " + IntegerToString(currentIndividualProcessCount));
         }
      }
      else
      {
         individualCycleCompleted = true;
         Print("‚úÖ INDIVIDUAL CYCLE COMPLETED | Processed: " + IntegerToString(currentIndividualProcessCount));
      }
      return;
   }
   
   // ‚úÖ ‡∏´‡∏≤ Main Ticket ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
   ulong bestMainTicket = FindBestRecoveryCandidate();
   
   if(bestMainTicket == 0)
   {
      individualCycleCompleted = true;
      Print("‚úÖ INDIVIDUAL CYCLE COMPLETED | No suitable candidates found");
      return;
   }
   
   // ‚úÖ ‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå Recovery
   if(OpenSingleRecoveryOrder(bestMainTicket))
   {
      currentIndividualProcessCount++;
      Print("üìà INDIVIDUAL PROGRESS: " + IntegerToString(currentIndividualProcessCount) + 
            "/" + IntegerToString(Individual_MaxPerCycle));
   }
   
   // ‚úÖ ‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà‡∏Å‡πà‡∏≠‡∏ô‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏ï‡πà‡∏≠‡πÑ‡∏õ
   Sleep(1000);
}
//+------------------------------------------------------------------+
//| ??? Set ??????????????                                      |
//+------------------------------------------------------------------+
int CloseProfitableSets()
{
   int closedCount = 0;
   
   for(int i = 0; i < totalRecoverySets; i++)
   {
      if(!recoverySets[i].isCompleted && IsSetProfitable(i))
      {
         Print("?? CLOSING PROFITABLE SET #" + IntegerToString(recoverySets[i].setNumber) + 
               " | Profit: $" + DoubleToString(recoverySets[i].totalProfit, 2));
         
         CloseCompleteSet(i);
         closedCount++;
         
         // ? ???????? Set ?????????? ???????????????????? (?????!)
         if(currentIndividualProcessCount > 0)
         {
            currentIndividualProcessCount--;
            Print("?? Adjusted process count: " + IntegerToString(currentIndividualProcessCount));
         }
      }
   }
   
   if(closedCount > 0)
   {
      CompactRecoverySets();
   }
   
   return closedCount;
}
//+------------------------------------------------------------------+
//| ??????????????? Individual Recovery                          |
//+------------------------------------------------------------------+
void StartNewIndividualCycle()
{
   // ? ???? Set ???????????????????????????????
   int closedSets = CloseProfitableSets();
   if(closedSets > 0)
   {
      Print("?? Closed " + IntegerToString(closedSets) + " profitable sets before new cycle");
      
      // ? ??????? Set ???? ???????????????????????????????????????
      if(closedSets > 0 && currentIndividualProcessCount > 0)
      {
         Print("?? Resetting cycle counter after closing profitable sets");
         currentIndividualProcessCount = 0;
      }
   }
   
   currentIndividualProcessCount = 0;
   individualCycleCompleted = false;
   lastIndividualCycleTime = TimeCurrent();
   
   Print("?? INDIVIDUAL CYCLE STARTED | Max: " + IntegerToString(Individual_MaxPerCycle) + " per cycle");
}
//+------------------------------------------------------------------+
//| CheckForRecoveryOpportunities - ?????????????????????        |
//+------------------------------------------------------------------+
void CheckForRecoveryOpportunities()
{
   // ? ?????????????????????????
   // ???????????????????????? ManageIndividualRecoverySets() ???
   return;
}

//+------------------------------------------------------------------+
//| OpenRecoveryOrder - ????????????????????                     |
//+------------------------------------------------------------------+
void OpenRecoveryOrder(ulong mainTicket)
{
   // ? ?????????????????????????
   // ???????????????????????? ProcessSingleRecoveryOpportunity() ???
   return;
}




//+------------------------------------------------------------------+
//| UpdateAllSetProfits - ?????????????????                      |
//+------------------------------------------------------------------+
void UpdateAllSetProfits()
{
   for(int i = 0; i < totalRecoverySets; i++)
   {
      if(!recoverySets[i].isCompleted)
      {
         CalculateSetProfit(i);
      }
   }
}

//+------------------------------------------------------------------+
//| PrintRecoverySetsStatus - ?????????? Recovery Sets           |
//+------------------------------------------------------------------+
//+------------------------------------------------------------------+
//| ????????? Individual Recovery (??????????????)              |
//+------------------------------------------------------------------+
void PrintRecoverySetsStatus()
{
   if(totalRecoverySets == 0) 
   {
      Print("=== INDIVIDUAL RECOVERY STATUS: No active sets ===");
      return;
   }
   
   Print("=== INDIVIDUAL RECOVERY SETS STATUS ===");
   Print("Total Active Sets: " + IntegerToString(totalRecoverySets));
   Print("Processing: " + (isIndividualRecoveryProcessing ? 
         "ACTIVE (Main: #" + TicketToStr(currentProcessingMainTicket) + ")" : "IDLE"));
   
   int needsHelpCount = 0;
   int maxHelpReached = 0;
   
   for(int i = 0; i < totalRecoverySets; i++)
   {
      if(!recoverySets[i].isCompleted)
      {
         // ? ???????????????????????????????????????
         bool needsHelp = (recoverySets[i].subCount < localMaxRecovery );
         string status = needsHelp ? "NEEDS HELP" : "MAX HELP";
         
         if(needsHelp) needsHelpCount++;
         else maxHelpReached++;
         
         Print("Set #" + IntegerToString(recoverySets[i].setNumber) + 
               " | Main: #" + TicketToStr(recoverySets[i].mainTicket) +
               " | Subs: " + IntegerToString(recoverySets[i].subCount) + "/" + 
               IntegerToString(localMaxRecovery ) +
               " | Main P/L: $" + DoubleToString(recoverySets[i].mainProfit, 2) +
               " | Total: $" + DoubleToString(recoverySets[i].totalProfit, 2) +
               " | Status: " + status);
      }
   }
   
   Print("Summary - Needs Help: " + IntegerToString(needsHelpCount) + 
         " | Max Help Reached: " + IntegerToString(maxHelpReached));
   Print("=== END INDIVIDUAL RECOVERY STATUS ===");
}

//+------------------------------------------------------------------+
//| Individual Position Recovery Functions                         |
//+------------------------------------------------------------------+
int GetIndividualRecoveryCount(ulong ticket)
{
   int count = 0;
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong recoveryTicket = PositionGetTicket(i);
      if(PositionSelectByTicket(recoveryTicket))
      {
         long magic = PositionGetInteger(POSITION_MAGIC);
         string comment = PositionGetString(POSITION_COMMENT);
         
         // ? ??????????? MAGIC_INDIVIDUAL
         if(magic == MAGIC_INDIVIDUAL && StringFind(comment, TicketToStr(ticket)) != -1)
         {
            count++;
         }
      }
   }
   return count;
}
//+------------------------------------------------------------------+
//| ????? Total Volume ?????????                                   |
//+------------------------------------------------------------------+
double CalculateTotalVolume()
{
   double total = 0;
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         total += PositionGetDouble(POSITION_VOLUME);
      }
   }
   return total;
}

void ManageIndividualPositionRecovery()
{
   if(!EnableIndividualRecovery) return;
   
   for(int i = PositionsTotal()-1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         long magic = PositionGetInteger(POSITION_MAGIC);
         
         // ? ??????????? MAGIC_INDIVIDUAL
         if(magic == MAGIC_INDIVIDUAL)
         {
            string comment = PositionGetString(POSITION_COMMENT);
            if(StringFind(comment, "Indiv-Recov-") != -1)
            {
               double profit = PositionGetDouble(POSITION_PROFIT);
               
               if(profit >= 2.0)
               {
                  if(trade.PositionClose(ticket))
                  {
                     Print("?? QUICK INDIVIDUAL RECOVERY CLOSE | Profit: $" + DoubleToString(profit, 2));
                     
                     string mainTicketStr = StringSubstr(comment, 12);
                     ulong mainTicket = StringToInteger(mainTicketStr);
                     
                     if(PositionSelectByTicket(mainTicket))
                     {
                        double mainProfit = PositionGetDouble(POSITION_PROFIT);
                        if(mainProfit < -5.0)
                        {
                           double mainVolume = PositionGetDouble(POSITION_VOLUME);
                           OpenIndividualRecovery(mainTicket, mainVolume, mainProfit);
                        }
                     }
                  }
               }
            }
         }
      }
   }
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         long magic = PositionGetInteger(POSITION_MAGIC);
         double profit = PositionGetDouble(POSITION_PROFIT);
         
         // ? ?????? Magic Numbers
         if(magic == MAGIC_INDIVIDUAL || magic == MAGIC_ORPHAN || magic == MAGIC_COUNTER || magic == MAGIC_HEDGE) 
            continue;
         
         if(profit <= -IndividualRecoveryTrigger)
         {
            int recoveryCount = GetIndividualRecoveryCount(ticket);
            if(recoveryCount < localMaxRecovery )
            {
               double volume = PositionGetDouble(POSITION_VOLUME);
               OpenIndividualRecovery(ticket, volume, profit);
            }
         }
      }
   }
}
void CheckMagicNumbersUsage()
{
   Print("=== MAGIC NUMBERS VERIFICATION ===");
   Print("MAGIC_RECOVERY: " + IntegerToString(MAGIC_RECOVERY) + " (Recovery ????)");
   Print("MAGIC_INDIVIDUAL: " + IntegerToString(MAGIC_INDIVIDUAL) + " (Individual Recovery)");
   Print("MAGIC_ORPHAN: " + IntegerToString(MAGIC_ORPHAN) + " (Orphan Management)");
   
   // ?????????????????????????
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         long magic = PositionGetInteger(POSITION_MAGIC);
         string comment = PositionGetString(POSITION_COMMENT);
         Print("Ticket #" + TicketToStr(ticket) + " | Magic: " + IntegerToString(magic) + " | Comment: " + comment);
      }
   }
   Print("=== END VERIFICATION ===");
}
void OpenIndividualRecovery(ulong mainTicket, double mainVolume, double mainProfit)
{
   double recoveryLot = mainVolume * localRecoveryMultiplier;
   recoveryLot = MathMin(recoveryLot, MaxLot);
   
   if(!CheckMargin(recoveryLot)) return;
   
   // ? ??????????? MAGIC_INDIVIDUAL
   trade.SetExpertMagicNumber(MAGIC_INDIVIDUAL);
   
   if(PositionSelectByTicket(mainTicket))
   {
      ENUM_POSITION_TYPE mainType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      string symbol = PositionGetString(POSITION_SYMBOL);
      
      bool success = false;
      ulong recoveryTicket = 0;
      
      if(mainType == POSITION_TYPE_BUY)
      {
         success = trade.Sell(recoveryLot, symbol, 0, 0, 0, "Indiv-Recov-" + TicketToStr(mainTicket));
      }
      else
      {
         success = trade.Buy(recoveryLot, symbol, 0, 0, 0, "Indiv-Recov-" + TicketToStr(mainTicket));
      }
      
      if(success)
      {
         recoveryTicket = trade.ResultOrder();
         Print("?? Individual Recovery for Main: " + TicketToStr(mainTicket) + 
               " | Loss: $" + DoubleToString(mainProfit, 2) +
               " | Recovery: " + TicketToStr(recoveryTicket) +
               " | Lot: " + DoubleToString(recoveryLot, 2) +
               " | Magic: " + IntegerToString(MAGIC_INDIVIDUAL)); // ? ???? Magic ????
      }
   }
}

void ManageSmartPortfolioClosing()
{
   double totalProfit = CalculateTotalProfit();
   int totalPositions = PositionsTotal();
   
   // ? ????????????????????????
   if(totalPositions >= SmartCloseMinPositions && totalProfit >= SmartCloseProfitTarget * 0.7)
   {
      // ? ????????????????? (70%) ??????? TP ?????????????
      if(totalProfit >= SmartCloseProfitTarget * 0.7 && totalProfit < SmartCloseProfitTarget)
      {
         AdjustPositionsForTarget(totalProfit);
      }
      
      // ? ?????????????????????????????
      if(totalProfit >= SmartCloseProfitTarget)
      {
         ExecuteSmartPortfolioClose(totalProfit, totalPositions);
      }
   }
}

void AdjustPositionsForTarget(double currentProfit)
{
   double remaining = SmartCloseProfitTarget - currentProfit;
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         double profit = PositionGetDouble(POSITION_PROFIT);
         
         // ? ????????????????????????
         if(profit > 0)
         {
            // ? ????? TP ????? 5 pips
            double currentTP = PositionGetDouble(POSITION_TP);
            string symbol = PositionGetString(POSITION_SYMBOL);
            
            if(currentTP > 0)
            {
               double pipSize = GetPipSize(symbol);
               double bufferPrice = pipSize * SmartCloseTPBuffer;
               
               ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
               double newTP = (posType == POSITION_TYPE_BUY) ? currentTP + bufferPrice : currentTP - bufferPrice;
               
               newTP = NormalizeDouble(newTP, GetDigits(symbol));
               trade.PositionModify(ticket, 0, newTP);
            }
         }
      }
   }
}

void ExecuteSmartPortfolioClose(double totalProfit, int totalPositions)
{
   Print("?? SMART PORTFOLIO CLOSE TRIGGERED!");
   Print("?? Total Profit: $" + DoubleToString(totalProfit, 2));
   Print("?? Total Positions: " + IntegerToString(totalPositions));
   
   
   double totalVolume = CalculateTotalVolume();
   double avgProfitPerLot = totalProfit / totalVolume;
   
   Print("?? Total Volume: " + DoubleToString(totalVolume, 2));
   Print("?? Avg Profit/Lot: $" + DoubleToString(avgProfitPerLot, 2));
   
   
   CloseAllPositions("ExecuteSmartPortfolioClose", "SmartPortfolio - Close");
   
   
   ResetRecoverySystem();
}

//+------------------------------------------------------------------+
//| Reset All Systems - Remove Scalp1                              |
//+------------------------------------------------------------------+
void ResetAllSystems()
{
   
   
   ResetRecoverySystem();
   currentFightingPhase = 0;
   isInBattleMode = false;
   
   Print("?? ALL SYSTEMS RESET - READY FOR NEXT BATTLE!");
}

//+------------------------------------------------------------------+
//| Get digits for symbol                                           |
//+------------------------------------------------------------------+
int GetDigits(string symbol = NULL)
{
   if(symbol == NULL) symbol = _Symbol;
   return (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);
}

//+------------------------------------------------------------------+
//| Get point size for symbol                                       |
//+------------------------------------------------------------------+
double GetPoint(string symbol = NULL)
{
   if(symbol == NULL) symbol = _Symbol;
   double pt = SymbolInfoDouble(symbol, SYMBOL_POINT);
   if(pt <= 0)
      pt = MathPow(10, -GetDigits(symbol));
   return pt;
}

//+------------------------------------------------------------------+
//| Debug Print Function                                            |
//+------------------------------------------------------------------+
void DebugPrint(int level, string message)
{
   if(EnableDebugMode && level <= DebugPrintLevel)
   {
      Print("?? [DEBUG Lv." + IntegerToString(level) + "] " + message);
   }
}

//+------------------------------------------------------------------+
//| Trading Status Check                                            |
//+------------------------------------------------------------------+
void CheckTradingStatus()
{
   if(!EnableDebugMode) return;
   
   string status = "";
   status += "=== TRADING STATUS CHECK ===\n";
   status += "Account: " + DoubleToString(accountInfo.Balance(), 2) + " | Equity: " + DoubleToString(accountInfo.Equity(), 2) + "\n";
   status += "Risk Pressure: " + DoubleToString(CalculateRiskPressure(), 2) + "\n";
   status += "New Bar: " + (newBar ? "YES" : "NO") + "\n";
   status += "Positions Total: " + IntegerToString(PositionsTotal()) + "\n";
   status += "Battle Mode: " + (isInBattleMode ? "PHASE " + IntegerToString(battlePhase) : "NO") + "\n";
   status += "Recovery Stopped: " + (recoveryStopped ? "YES" : "NO") + "\n";
   status += "Recovery Layers: " + IntegerToString(recoveryLayerCount) + "\n";
   
   // Trading conditions
   status += "\n=== TRADING CONDITIONS ===\n";
   status += "Scalp1 Enabled: " + (Scalp1Enabled ? "YES" : "NO") + "\n";
   status += "Scalp2 Enabled: " + (Scalp2Enabled ? "YES" : "NO") + "\n";
   status += "Breakout Enabled: " + (BreakoutStrategy ? "YES" : "NO") + "\n";
   status += "Risk Pressure < 0.9: " + (CalculateRiskPressure() < 0.9 ? "YES" : "NO") + "\n";
   
   DebugPrint(1, status);
}
void CheckTargets()
{
    double currentPrice = SymbolInfoDouble(Symbol(), SYMBOL_BID);
    
    // Calculate target price
    double targetPrice = g_BaseCollaborativeTarget * (1 + (TargetPercentage / 100));
    
    if(currentPrice >= targetPrice)
    {
        Print("Target reached! Current: ", currentPrice, " Target: ", targetPrice);
        // Take profit or adjust position
    }
}
double CalculateDynamicBaseTarget()
{
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì base target ‡∏à‡∏≤‡∏Å indicators
    
    // 1. ‡∏à‡∏≤‡∏Å pivot point (‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß)
    double high = iHigh(Symbol(), PERIOD_D1, 1);
    double low = iLow(Symbol(), PERIOD_D1, 1);
    double close = iClose(Symbol(), PERIOD_D1, 1);
    double pivot = (high + low + close) / 3;
    
    // 2. ‡∏à‡∏≤‡∏Å moving average (‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç)
    // ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô GetMAValue ‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö shift parameter
    double ma100 = GetMAValue(Symbol(), PERIOD_D1, 100, 0, MODE_SMA);
    
    // ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏Ç‡∏≠‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏ß‡∏¥‡∏ò‡∏µ
    return (pivot + ma100) / 2;
}
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   
      
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á indicator handles
    ema9_handle = iMA(_Symbol, PERIOD_H1, 9, 0, MODE_EMA, PRICE_CLOSE);
    ema21_handle = iMA(_Symbol, PERIOD_H1, 21, 0, MODE_EMA, PRICE_CLOSE);
    ema50_handle = iMA(_Symbol, PERIOD_H1, 50, 0, MODE_EMA, PRICE_CLOSE);
    
    ema200_handle = iMA(_Symbol, PERIOD_H1, 200, 0, MODE_EMA, PRICE_CLOSE);
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ handles ‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if(ema9_handle == INVALID_HANDLE || ema21_handle == INVALID_HANDLE || ema50_handle == INVALID_HANDLE || ema200_handle == INVALID_HANDLE)
    {
        Print("Error creating EMA indicator handles");
        return INIT_FAILED;
    }
    
    
    
    
      // ‡∏™‡∏£‡πâ‡∏≤‡∏á handles ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö EMA ‡∏ö‡∏ô H1
    ema9_handle_h1 = iMA(_Symbol, PERIOD_H1, 9, 0, MODE_EMA, PRICE_CLOSE);
    ema21_handle_h1 = iMA(_Symbol, PERIOD_H1, 21, 0, MODE_EMA, PRICE_CLOSE);
    
    ema9_handle_m15 = iMA(_Symbol, PERIOD_M15, 9, 0, MODE_EMA, PRICE_CLOSE);
    ema21_handle_m15 = iMA(_Symbol, PERIOD_M15, 21, 0, MODE_EMA, PRICE_CLOSE);
    
    ema9_handle_m5 = iMA(_Symbol, PERIOD_M5, 9, 0, MODE_EMA, PRICE_CLOSE);
    ema21_handle_m5 = iMA(_Symbol, PERIOD_M5, 21, 0, MODE_EMA, PRICE_CLOSE);
    
    if(ema9_handle_h1 == INVALID_HANDLE || ema21_handle_h1 == INVALID_HANDLE) {
        Print("Error creating EMA handles for H1");
        return INIT_FAILED;
    }
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á handles ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö indicators ‡∏≠‡∏∑‡πà‡∏ô‡πÜ
    rsi_handle_h1 = iRSI(_Symbol, PERIOD_H1, 14, PRICE_CLOSE);
    stoch_handle_h1 = iStochastic(_Symbol, PERIOD_H1, 5, 3, 3, MODE_SMA, STO_LOWHIGH);
    
    
      // ‡∏™‡∏£‡πâ‡∏≤‡∏á handles ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö M15 timeframe
    ema9_handle_m15 = iMA(_Symbol, PERIOD_M15, 9, 0, MODE_EMA, PRICE_CLOSE);
    ema21_handle_m15 = iMA(_Symbol, PERIOD_M15, 21, 0, MODE_EMA, PRICE_CLOSE);
    ema50_handle_m15 = iMA(_Symbol, PERIOD_M15, 50, 0, MODE_EMA, PRICE_CLOSE);
    
    if(ema9_handle_m15 == INVALID_HANDLE || 
       ema21_handle_m15 == INVALID_HANDLE || 
       ema50_handle_m15 == INVALID_HANDLE)
    {
        Print("Failed to create EMA handles for M15");
        return INIT_FAILED;
    }

    //-----------------//
    
    
   DeleteBreakevenLine();
   trade.SetExpertMagicNumber(MAGIC_SCALP1);
   trade.SetDeviationInPoints(10);
   trade.SetTypeFilling(ORDER_FILLING_FOK);
   
   double tick_size = 0.0, tick_value = 0.0;
   if(SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE, tick_size) &&
      SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE, tick_value) &&
      tick_size > 0 && tick_value > 0)
   {
      pointValue = tick_value / tick_size * _Point;
   }
   else
   {
      double tick_value_fallback = 0.0;
      if(SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE, tick_value_fallback) && tick_value_fallback > 0)
         pointValue = tick_value_fallback * _Point;
      else
         pointValue = _Point;
   }
      
   lastBarTime = iTime(_Symbol, PERIOD_M1, 0);
   lastBreakoutCheck = lastBarTime;
   lastAICheck = lastBarTime;
   
   // Initialize cooperative system
   InitializeCollaborativeSystem();
   
   if(ShowDashboard)
      EventSetMillisecondTimer(500);
   
   Print("=== Hybrid EA v4.00 - COOPERATIVE STRATEGY SYSTEM ===");
   Print("ü§ù Cooperative System Activated - All strategies work together!");
   
   
   
   
   // Set base collaborative target
    if(AutoCalculateBaseTarget)
    {
        g_BaseCollaborativeTarget = CalculateDynamicBaseTarget();
    }
    else
    {
        g_BaseCollaborativeTarget = BaseCollaborativeTarget;
    }
    
    Print("Base Collaborative Target set to: ", g_BaseCollaborativeTarget);
   
   
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| ExecuteAI - AI Strategy                                         |
//+------------------------------------------------------------------+
void ExecuteAI()
{
   // Simple AI logic - replace with actual AI model
   bool aiBuySignal = false;
   bool aiSellSignal = false;

   if(AI_News_Magic > 0 && AI_NewsTrading_Enabled)
   {
      aiBuySignal = true;
   }
   
   if(AI_Trend_Magic > 0 && AI_TrendTrading_Enabled)
   {
      aiSellSignal = true;
   }

   if(aiBuySignal)
   {
      bool hasAI = false;
      int total = (int)PositionsTotal();
      for(int i = 0; i < total; i++)
      {
         ulong ticket = PositionGetTicket(i);
         if(ticket > 0 && PositionSelectByTicket(ticket))
         {
            if(PositionGetInteger(POSITION_MAGIC) == AI_News_Magic || PositionGetInteger(POSITION_MAGIC) == AI_Trend_Magic)
            {
               hasAI = true;
               break;
            }
         }
      }
      
      if(hasAI) 
      {
         DebugPrint(3, "AI position already exists - skipping");
         return;
      }

      double lot = BaseLot;
      if(lot > MaxLot) lot = MaxLot;
      if(!CheckMargin(lot)) return;

      trade.SetExpertMagicNumber((int)AI_News_Magic);
      double tpPrice = GetTPPriceUniversal(true, Scalp1_TP_Points);
      if(trade.Buy(lot, _Symbol, 0, 0, tpPrice, "AI-Buy"))
      {
         Print("?? AI BUY Signal executed, Lot: " + DoubleToString(lot, 2) + ", TP: " + DoubleToString(tpPrice, GetDigits()));
      }
   }
   else if(aiSellSignal)
   {
      bool hasAI = false;
      int total = (int)PositionsTotal();
      for(int i = 0; i < total; i++)
      {
         ulong ticket = PositionGetTicket(i);
         if(ticket > 0 && PositionSelectByTicket(ticket))
         {
            if(PositionGetInteger(POSITION_MAGIC) == AI_News_Magic || PositionGetInteger(POSITION_MAGIC) == AI_Trend_Magic)
            {
               hasAI = true;
               break;
            }
         }
      }
      
      if(hasAI) 
      {
         DebugPrint(3, "AI position already exists - skipping");
         return;
      }

      double lot = BaseLot;
      if(lot > MaxLot) lot = MaxLot;
      if(!CheckMargin(lot)) return;

      trade.SetExpertMagicNumber((int)AI_Trend_Magic);
      double tpPrice = GetTPPriceUniversal(false, Scalp1_TP_Points);
      if(trade.Sell(lot, _Symbol, 0, 0, tpPrice, "AI-Sell"))
      {
         Print("?? AI SELL Signal executed, Lot: " + DoubleToString(lot, 2) + ", TP: " + DoubleToString(tpPrice, GetDigits()));
      }
   }
}
//+------------------------------------------------------------------+
//| Manage Trading Pairs - ?????????????????                      |
//+------------------------------------------------------------------+
void ManageTradingPairs()
{
    // 1. ????????????? active
    CleanUpInactivePairs();
    
    // 2. ???????????????????
    for(int i = 0; i < totalTradingPairs; i++)
    {
        if(tradingPairs[i].isActive)
        {
            UpdatePairProfit(i);
            
            // 3. ???????????????????????????
            if(ShouldCloseTradingPair(i))
            {
                CloseTradingPair(i);
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Close Trading Pair - ??????????                              |
//+------------------------------------------------------------------+
void CloseTradingPair(int pairIndex)
{
    bool mainClosed = false;
    bool helpClosed = false;
    
    // ???????????????
    if(PositionSelectByTicket(tradingPairs[pairIndex].mainTicket))
    {
        mainClosed = trade.PositionClose(tradingPairs[pairIndex].mainTicket);
    }
    
    // ????????????????????
    if(PositionSelectByTicket(tradingPairs[pairIndex].helpTicket))
    {
        helpClosed = trade.PositionClose(tradingPairs[pairIndex].helpTicket);
    }
    
    if(mainClosed || helpClosed)
    {
        tradingPairs[pairIndex].isActive = false;
        Print("? TRADING PAIR CLOSED | Main: #" + TicketToStr(tradingPairs[pairIndex].mainTicket) + 
              " | Help: #" + TicketToStr(tradingPairs[pairIndex].helpTicket) + 
              " | Profit: $" + DoubleToString(tradingPairs[pairIndex].currentProfit, 2));
    }
}
//+------------------------------------------------------------------+
//| Add Trading Pair - ????????????????                          |
//+------------------------------------------------------------------+
void AddTradingPair(ulong mainTicket, ulong helpTicket, string symbol, double targetProfit)
{
    if(totalTradingPairs >= 50)
    {
        Print("? Maximum trading pairs reached (50)");
        return;
    }
    
    TradingPair newPair;
    newPair.mainTicket = mainTicket;
    newPair.helpTicket = helpTicket;
    newPair.symbol = symbol;
    newPair.currentProfit = 0;
    newPair.targetProfit = targetProfit;
    newPair.isActive = true;
    
    tradingPairs[totalTradingPairs] = newPair;
    totalTradingPairs++;
    
    Print("? NEW TRADING PAIR ADDED | Main: #" + TicketToStr(mainTicket) + 
          " | Help: #" + TicketToStr(helpTicket) + 
          " | Target: $" + DoubleToString(targetProfit, 2));
}
//+------------------------------------------------------------------+
//| Find Trading Pair by Main Ticket - ?????????????????? Main Ticket |
//+------------------------------------------------------------------+
int FindTradingPairByMainTicket(ulong mainTicket)
{
    for(int i = 0; i < totalTradingPairs; i++)
    {
        if(tradingPairs[i].mainTicket == mainTicket && tradingPairs[i].isActive)
        {
            return i;
        }
    }
    return -1;
}
//+------------------------------------------------------------------+
//| Find Trading Pair by Help Ticket - ?????????????????? Help Ticket |
//+------------------------------------------------------------------+
int FindTradingPairByHelpTicket(ulong helpTicket)
{
    for(int i = 0; i < totalTradingPairs; i++)
    {
        if(tradingPairs[i].helpTicket == helpTicket && tradingPairs[i].isActive)
        {
            return i;
        }
    }
    return -1;
}
//+------------------------------------------------------------------+
//| Calculate Recovery Risk Pressure (Improved with Market Awareness)|
//+------------------------------------------------------------------+
double CalculateRecoveryRiskPressure()
{
   // 1. ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Drawdown ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô (‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏°)
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   if(balance <= 0) return 0;
   double drawdownPercent = (balance - equity) / balance * 100.0;
   double baseRisk = drawdownPercent / MaxDrawdownPercent;
   
   // 2. ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡∏∂‡∏Å‡∏Ç‡∏≠‡∏á Recovery
   int recoveryStep = GetCurrentRecoveryStep();
   double recoveryRisk = recoveryStep * 0.15; // ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ç‡∏±‡πâ‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏° risk 15%
   
   // 3. ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡∏™‡∏†‡∏≤‡∏ß‡∏∞‡∏ï‡∏•‡∏≤‡∏î
   ENUM_MARKET_REGIME regime = DetectMarketRegime(); // ‡πÉ‡∏ä‡πâ ENUM
   double marketRisk = 0;
   switch(regime) {
      case MARKET_REGIME_RANGING_CALM:
         marketRisk = 0.1;    // ‡∏ï‡∏•‡∏≤‡∏î‡πÄ‡∏á‡∏µ‡∏¢‡∏ö ‚Üí risk ‡∏ï‡πà‡∏≥
         break;
      case MARKET_REGIME_TRENDING_STRONG:
         marketRisk = 0.3;    // ‡∏ï‡∏•‡∏≤‡∏î‡πÅ‡∏£‡∏á ‚Üí risk ‡∏™‡∏π‡∏á
         break;
      case MARKET_REGIME_BREAKOUT_POTENTIAL:
         marketRisk = 0.2;    // ‡πÇ‡∏≠‡∏Å‡∏≤‡∏™ breakout ‚Üí risk ‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á
         break;
      case MARKET_REGIME_RANGING_VOLATILE:
         marketRisk = 0.25;   // ‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô ‚Üí risk ‡∏™‡∏π‡∏á
         break;
      case MARKET_REGIME_TRENDING_WEAK:
         marketRisk = 0.2;    // ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏≠‡πà‡∏≠‡∏ô ‚Üí risk ‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á
         break;
      default: // MARKET_REGIME_NORMAL
         marketRisk = 0.15;   // ‡∏õ‡∏Å‡∏ï‡∏¥
   }
   
   // 4. ‡∏£‡∏ß‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
   double totalRisk = baseRisk + recoveryRisk + marketRisk;
   
   if(EnableDebugMode) {
      Print("   üìä RECOVERY RISK ANALYSIS:");
      Print("   Base Risk: " + DoubleToString(baseRisk, 2));
      Print("   Recovery Steps Risk: " + DoubleToString(recoveryRisk, 2));
      Print("   Market Regime: " + GetRegimeName(regime));
      Print("   Market Risk: " + DoubleToString(marketRisk, 2));
      Print("   TOTAL RISK: " + DoubleToString(totalRisk, 2));
   }
   
   return totalRisk;
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    

    // ‡∏Ñ‡∏∑‡∏ô‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£
    if(ema9_handle != INVALID_HANDLE) IndicatorRelease(ema9_handle);
    if(ema21_handle != INVALID_HANDLE) IndicatorRelease(ema21_handle);
    if(ema50_handle != INVALID_HANDLE) IndicatorRelease(ema50_handle);
    if(ema9_handle_h1 != INVALID_HANDLE) IndicatorRelease(ema9_handle_h1);
    if(ema21_handle_h1 != INVALID_HANDLE) IndicatorRelease(ema21_handle_h1);
    if(rsi_handle_h1 != INVALID_HANDLE) IndicatorRelease(rsi_handle_h1);
    if(stoch_handle_h1 != INVALID_HANDLE) IndicatorRelease(stoch_handle_h1);
     if(ema200_handle != INVALID_HANDLE) IndicatorRelease(ema200_handle);
    
   if(ShowDashboard)
      EventKillTimer();
   Print("EA Deinitialized - Reason: " + IntegerToString(reason));
   
   // ‡∏•‡πâ‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏õ‡∏¥‡∏î EA
    DeleteBreakevenLine();
    ObjectsDeleteAll(0, "BE_"); // ‡∏•‡πâ‡∏≤‡∏á text objects ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
}
double GetEMASimple(int period = 20, int shift = 0, ENUM_TIMEFRAMES tf = PERIOD_H1)
{
    return GetEMAValue(_Symbol, tf, period, shift);
}
double GetEMAValue(string symbol, ENUM_TIMEFRAMES tf, int period, int shift = 0)
{
    double emaArray[];
    ArraySetAsSeries(emaArray, true);
    
    int handle = iMA(symbol, tf, period, 0, MODE_EMA, PRICE_CLOSE);
    if(handle == INVALID_HANDLE) 
    {
        Print("Error: Cannot create EMA indicator handle");
        return 0;
    }
    
    int copied = CopyBuffer(handle, 0, shift, 1, emaArray);
    IndicatorRelease(handle);
    
    if(copied <= 0) 
    {
        Print("Error: Cannot copy EMA buffer");
        return 0;
    }
    
    return emaArray[0];
}


// ===== ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ Orphan ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏î‡∏π‡πÅ‡∏•‡πÑ‡∏´‡∏° =====
bool NeedActiveOrphanMonitoring()
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ Sets ‡∏ó‡∏µ‡πà Main ‡∏´‡∏≤‡∏¢‡πÅ‡∏•‡∏∞‡∏¢‡∏±‡∏á‡∏°‡∏µ Recovery Orders ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏î‡∏π‡πÅ‡∏•‡πÑ‡∏´‡∏°
    for(int i = 0; i < totalRecoverySets; i++)
    {
        if(recoverySets[i].isCompleted) continue;
        if(!IsMainTicketMissing(i)) continue;
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏¢‡∏±‡∏á‡∏°‡∏µ Recovery Orders ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏î‡∏π‡πÅ‡∏•‡πÑ‡∏´‡∏°
        for(int j = 0; j < recoverySets[i].subCount; j++)
        {
            ulong subTicket = recoverySets[i].subTickets[j];
            if(PositionSelectByTicket(subTicket))
            {
                double profit = PositionGetDouble(POSITION_PROFIT);
                // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ Order ‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏õ‡∏¥‡∏î (‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏Å‡∏≥‡πÑ‡∏£‡∏´‡∏£‡∏∑‡∏≠‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô)
                return true;
            }
        }
    }
    return false;
}

// ===== ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Main ‡∏´‡∏≤‡∏¢‡πÉ‡∏´‡∏°‡πà =====
bool HasNewMissingMain()
{
    for(int i = 0; i < totalRecoverySets; i++)
    {
        if(recoverySets[i].isCompleted) continue;
        if(IsMainTicketMissing(i)) 
        {
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô Main ‡∏ó‡∏µ‡πà‡∏´‡∏≤‡∏¢‡πÉ‡∏´‡∏°‡πà (‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£)
            bool hasActiveRecoveries = false;
            for(int j = 0; j < recoverySets[i].subCount; j++)
            {
                if(PositionSelectByTicket(recoverySets[i].subTickets[j]))
                {
                    hasActiveRecoveries = true;
                    break;
                }
            }
            if(hasActiveRecoveries) return true;
        }
    }
    return false;
}
void ExecuteEssentialManagementOnly()
{
    // ‚úÖ ‡∏¢‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç
    UpdateAllSetProfits();
    CheckAndCloseHedgedPairs();
    ManageTradingPairs();
    RunSafetyCheck();
    
    // ‚ùå ‡πÅ‡∏ï‡πà‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÉ‡∏´‡∏°‡πà
}

//+------------------------------------------------------------------+
//| Check Portfolio Total Target (‡πÉ‡∏ä‡πâ SmartCloseProfitTarget)       |
//+------------------------------------------------------------------+
void CheckPortfolioTotalTarget()
{
    double totalProfit = CalculateTotalProfit();
    double portfolioTarget = SmartCloseProfitTarget; // üéØ ‡πÉ‡∏ä‡πâ SmartCloseProfitTarget
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥
    int totalPositions = PositionsTotal();
    bool minPositionsMet = (totalPositions >= SmartCloseMinPositions);
    
    if(totalProfit >= portfolioTarget && minPositionsMet)
    {
        Print("üéØ SMART PORTFOLIO TARGET HIT!");
        Print("üí∞ Total Profit: $" + DoubleToString(totalProfit, 2));
        Print("üéØ Target: $" + DoubleToString(portfolioTarget, 2));
        Print("üìä Positions: " + IntegerToString(totalPositions) + " (Min: " + IntegerToString(SmartCloseMinPositions) + ")");
        Print("‚öôÔ∏è Using SmartCloseProfitTarget with conditions");
        
        // üö® ‡∏õ‡∏¥‡∏î‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
        CloseAllPositionsEx("SmartPortfolioTarget", 
                           "Smart Portfolio Target: $" + DoubleToString(totalProfit, 2) +
                           " | Positions: " + IntegerToString(totalPositions));
        
        // üî• ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏£‡∏∞‡∏ö‡∏ö
        ResetAllSystemsAfterTarget();
        
        Alert("üéâ SMART PORTFOLIO TARGET ACHIEVED!");
        Alert("üí∞ Profit: $" + DoubleToString(totalProfit, 2));
        Alert("üìä Positions: " + IntegerToString(totalPositions));
        Alert("üéØ Target: $" + DoubleToString(portfolioTarget, 2));
        
        return;
    }
    
    // üìà ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏õ‡πâ‡∏≤
    else if(totalProfit >= portfolioTarget * 0.8 && minPositionsMet)
    {
        Print("üìà APPROACHING SMART TARGET: " + DoubleToString((totalProfit/portfolioTarget)*100, 1) + "%");
        Print("üìä Positions: " + IntegerToString(totalPositions) + "/" + IntegerToString(SmartCloseMinPositions));
    }
    
    // ‚ö†Ô∏è ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ñ‡πâ‡∏≤‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡πÑ‡∏£‡πÅ‡∏ï‡πà‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÑ‡∏°‡πà‡∏ñ‡∏∂‡∏á
    else if(totalProfit >= portfolioTarget && !minPositionsMet)
    {
        Print("‚ö†Ô∏è Profit target reached but insufficient positions: " + 
              IntegerToString(totalPositions) + "/" + IntegerToString(SmartCloseMinPositions));
    }
}

//+------------------------------------------------------------------+
//| Close All Positions Immediately                                |
//+------------------------------------------------------------------+
void CloseAllPositionsEx(string callerName, string reason)
{
    // üö® ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏Å‡πà‡∏≠‡∏ô‡∏õ‡∏¥‡∏î
    Alert("üõë SMART PORTFOLIO CLOSURE - " + callerName);
    Alert("üéØ Reason: " + reason);
    Alert("üí∞ Current Profit: $" + DoubleToString(CalculateTotalProfit(), 2));
    Alert("üéØ Target: $" + DoubleToString(SmartCloseProfitTarget, 2));
    Alert("üìä Min Positions: " + IntegerToString(SmartCloseMinPositions));
    
    int closedCount = 0;
    int totalPositions = PositionsTotal();
    double totalClosedProfit = 0;
    
    // üî• ‡∏õ‡∏¥‡∏î‡πÅ‡∏ö‡∏ö‡πÄ‡∏£‡πà‡∏á‡∏î‡πà‡∏ß‡∏ô
    for(int i = totalPositions-1; i >= 0; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            double profit = PositionGetDouble(POSITION_PROFIT);
            string symbol = PositionGetString(POSITION_SYMBOL);
            long magic = PositionGetInteger(POSITION_MAGIC);
            double volume = PositionGetDouble(POSITION_VOLUME);
            
            if(trade.PositionClose(ticket))
            {
                closedCount++;
                totalClosedProfit += profit;
                Print("üîª CLOSED: " + symbol + 
                      " | Magic: " + IntegerToString(magic) + 
                      " | Lot: " + DoubleToString(volume, 2) +
                      " | P/L: $" + DoubleToString(profit, 2));
            }
        }
    }
    
    // üìä ‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•
    Alert("‚úÖ SMART PORTFOLIO CLOSURE COMPLETED");
    Alert("üìä Closed: " + IntegerToString(closedCount) + "/" + IntegerToString(totalPositions));
    Alert("üí∞ Final P/L: $" + DoubleToString(totalClosedProfit, 2));
    Alert("‚öôÔ∏è Settings: Target=$" + DoubleToString(SmartCloseProfitTarget, 2) + 
          " | MinPos=" + IntegerToString(SmartCloseMinPositions));
}
//+------------------------------------------------------------------+
//| Reset All Systems After Target Hit                             |
//+------------------------------------------------------------------+
void ResetAllSystemsAfterTarget()
{
    Print("üîÑ RESETTING ALL SYSTEMS AFTER SMART TARGET ACHIEVEMENT");
    Print("üéØ Target: $" + DoubleToString(SmartCloseProfitTarget, 2) + " (SmartCloseProfitTarget)");
    Print("üìä Min Positions: " + IntegerToString(SmartCloseMinPositions));
    
    // 1. ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï Cooperative System
    ResetCollaborativeSystem();
    
    // 2. ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï Recovery System
    ResetRecoverySystem();
    
    // 3. ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï Battle Mode
    currentFightingPhase = 0;
    isInBattleMode = false;
    
    // 4. ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏ï‡∏±‡∏ß‡∏ô‡∏±‡∏ö‡∏ï‡πà‡∏≤‡∏á‡πÜ
    recoveryLayerCount = 0;
    consecutiveLosses = 0;
    recoveryStopped = false;
    
    // 5. ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏ï‡πà‡∏≤‡∏á‡πÜ
    Current_Scalp1_Lot_Multiplier = Original_Scalp1_Multiplier;
    Current_Scalp2_LotMultiplier = Original_Scalp2_Multiplier;
    Current_TrendScalp_TP_Points = Original_Trend_TP;
    
    // 6. ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏ú‡∏•‡∏Å‡∏≥‡πÑ‡∏£
    scalp2TotalProfit = 0;
    scalp3TotalProfit = 0;
    recoveryTotalProfit = 0;
    breakoutTotalProfit = 0;
    
    Print("‚úÖ ALL SYSTEMS RESET - READY FOR NEW SESSION");
    Print("üéØ Next Target: $" + DoubleToString(SmartCloseProfitTarget, 2) + 
          " | Min Positions: " + IntegerToString(SmartCloseMinPositions));
}


void EmergencyRecoveryStop()
{
    if(!UseRecoverySafety) return;
    
    if(recoveryLayerCount >= localMaxSteps * 0.8)
    {
        double currentDD = CalculateTrueDrawdownPercent();
        double currentProfit = CalculateTotalProfit();
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡πÑ‡∏£‡∏ï‡∏≤‡∏° Target ‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
        bool profitTargetMet = (SmartCloseProfitTarget > 0 && currentProfit >= SmartCloseProfitTarget);
        
        if(currentDD > MaxDrawdownPercent * 1.5 && !profitTargetMet)
        {
            Print("üÜò EMERGENCY RECOVERY STOP - Excessive drawdown detected!");
            Print("üÜò Current Drawdown: " + DoubleToString(currentDD, 1) + "%");
            Print("üÜò Current Profit: " + DoubleToString(currentProfit, 2));
            Print("üÜò Profit Target: " + DoubleToString(SmartCloseProfitTarget, 2));
            
            CloseAllPositions("EmergencyRecoveryStop", "Emergency Recovery - Excessive Loss");
            ResetRecoverySystem();
            recoveryStopped = true;
        }
        else if(currentDD > MaxDrawdownPercent * 1.5 && profitTargetMet)
        {
            Print("‚úÖ Drawdown high but profit target already met!");
            Print("‚úÖ Current Profit: " + DoubleToString(currentProfit, 2) + 
                  " >= Target: " + DoubleToString(SmartCloseProfitTarget, 2));
            // ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏¢‡∏∏‡∏î ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡πÑ‡∏£‡∏ï‡∏≤‡∏°‡πÄ‡∏õ‡πâ‡∏≤‡πÅ‡∏•‡πâ‡∏ß
        }
    }
}
//---------MARKET ANALYSIS--------------------------//
// üî• ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Market Analysis ‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏î‡∏´‡∏≤‡∏¢
void UpdateMarketAnalysis()
{
    // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏•‡∏≤‡∏î‡∏ï‡∏•‡∏≠‡∏î‡πÄ‡∏ß‡∏•‡∏≤ (‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ó‡∏∏‡∏Å Tick)
    static datetime lastUpdate = 0;
    if(TimeCurrent() - lastUpdate < 1) return; // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ó‡∏∏‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
    
    // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏ï‡∏•‡∏≠‡∏î‡πÄ‡∏ß‡∏•‡∏≤
    UpdateVolatility();
    UpdateSpread();
    UpdateTrendStrength();
    
    lastUpdate = TimeCurrent();
}

string AnalyzeMarket()
{
    double volatility = GetVolatility();
    double trendStrength = GetTrendStrength();
    int spread = (int)SymbolInfoInteger(_Symbol, SYMBOL_SPREAD); // ‡πÅ‡∏Å‡πâ‡πÄ‡∏õ‡πá‡∏ô int
    double atr = GetATR();
    
    // ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î
    if(volatility > 150 && spread > 25)
    {
        return "HIGH_VOLATILITY";
    }
    else if(trendStrength > 0.7 && volatility < 100)
    {
        return "TRENDING";
    }
    else if(trendStrength < 0.3 && volatility < 80)
    {
        return "RANGING";
    }
    else if(IsBreakoutSignal())
    {
        return "BREAKOUT";
    }
    else
    {
        return "NORMAL";
    }
}

// üî• ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô
double GetVolatility()
{
    double atrBuffer[];
    ArraySetAsSeries(atrBuffer, true);
    int atrHandle = iATR(_Symbol, _Period, 14);
    
    if(CopyBuffer(atrHandle, 0, 0, 3, atrBuffer) > 0)
    {
        return atrBuffer[0] / _Point;
    }
    return 0;
}
double GetMAValue(string symbol, ENUM_TIMEFRAMES tf, int period, int shift, ENUM_MA_METHOD method)
{
    int maHandle = iMA(symbol, tf, period, 0, method, PRICE_CLOSE);
    double maValue[1];
    
    if(CopyBuffer(maHandle, 0, shift, 1, maValue) < 1)
    {
        IndicatorRelease(maHandle);
        return 0;
    }
    
    IndicatorRelease(maHandle);
    return maValue[0];
}
double GetTrendStrength(int direction = DIRECTION_DOWN)
{
    // Simple method using moving averages
    double ma20 = GetMAValue(Symbol(), PERIOD_CURRENT, 20, 0, MODE_EMA);
    double ma50 = GetMAValue(Symbol(), PERIOD_CURRENT, 50, 0, MODE_EMA);
    double ma200 = GetMAValue(Symbol(), PERIOD_CURRENT, 200, 0, MODE_EMA);
    
    if(direction == DIRECTION_DOWN)
    {
        // Downtrend strength: all MAs aligned downward
        if(ma20 < ma50 && ma50 < ma200)
            return 30.0; // Strong
        else if(ma20 < ma50)
            return 20.0; // Moderate
        else
            return 0;    // Weak or no trend
    }
    else if(direction == DIRECTION_UP)
    {
        // Uptrend strength: all MAs aligned upward
        if(ma20 > ma50 && ma50 > ma200)
            return 30.0; // Strong
        else if(ma20 > ma50)
            return 20.0; // Moderate
        else
            return 0;    // Weak or no trend
    }
    
    return 0;
}


double GetATR()
{
    double atrBuffer[];
    ArraySetAsSeries(atrBuffer, true);
    int atrHandle = iATR(_Symbol, _Period, 14);
    
    if(CopyBuffer(atrHandle, 0, 0, 3, atrBuffer) > 0)
    {
        return atrBuffer[0];
    }
    return 0;
}

bool IsBreakoutSignal()
{
    double highBuffer[], lowBuffer[];
    ArraySetAsSeries(highBuffer, true);
    ArraySetAsSeries(lowBuffer, true);
    
    CopyHigh(_Symbol, _Period, 0, 10, highBuffer);
    CopyLow(_Symbol, _Period, 0, 10, lowBuffer);
    
    double currentHigh = highBuffer[0];
    double currentLow = lowBuffer[0];
    double previousHigh = highBuffer[1];
    double previousLow = lowBuffer[1];
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Breakout
    if(currentHigh > previousHigh + (GetATR() * 0.5) || 
       currentLow < previousLow - (GetATR() * 0.5))
    {
        return true;
    }
    
    return false;
}

double GetDayHigh()
{
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    CopyRates(_Symbol, PERIOD_D1, 0, 1, rates);
    return rates[0].high;
}

double GetDayLow()
{
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    CopyRates(_Symbol, PERIOD_D1, 0, 1, rates);
    return rates[0].low;
}

void UpdateVolatility()
{
    // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô (‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏∑‡πà‡∏ô)
    currentVolatility = GetVolatility();
}

void UpdateSpread()
{
    // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ñ‡πà‡∏≤ Spread
    currentSpread = (int)SymbolInfoInteger(_Symbol, SYMBOL_SPREAD);
}

void UpdateTrendStrength()
{
    // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏Å‡∏£‡πà‡∏á‡∏Ç‡∏≠‡∏á‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå
    currentTrendStrength = GetTrendStrength();
}
//----------------ontick New system ---------------//
void OnTick()
{
   // ===== üî¥ SYSTEM CRITICAL (‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ó‡∏∏‡∏Å Tick) =====
   // 1. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏õ‡∏¥‡∏î‡∏Å‡∏≥‡πÑ‡∏£‡∏ó‡∏±‡∏ô‡∏ó‡∏µ (‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≥‡πÑ‡∏£‡∏ï‡∏≤‡∏° Target ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô)
   if(CalculateTotalProfit() >= SmartCloseProfitTarget && SmartCloseProfitTarget > 0) 
   {
      if(EnableDebugMode) Print("üéØ Profit target reached: " + DoubleToString(CalculateTotalProfit(), 2) + 
                                " >= " + DoubleToString(SmartCloseProfitTarget, 2));
      CloseAllPositions("ProfitTarget", "Target achieved");
      return;
   }
   
   // üî• ‡πÄ‡∏û‡∏¥‡πà‡∏° Market Analysis ‡πÉ‡∏ô Critical Section
   if(UseMarketAnalysis) 
   {
      UpdateMarketAnalysis(); // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏•‡∏≤‡∏î‡∏ï‡∏•‡∏≠‡∏î‡πÄ‡∏ß‡∏•‡∏≤
   }
   
   if(!IsMarketGoodForTrading(_Symbol)) 
   {
      if(EnableDebugMode) Print("‚ùå Market conditions not suitable - monitoring only");
      ExecuteEssentialManagementOnly(); // ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
      return;
   }
   
   // 2. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏†‡∏≤‡∏ß‡∏∞‡∏â‡∏∏‡∏Å‡πÄ‡∏â‡∏¥‡∏ô
   if(CalculateRecoveryRiskPressure() >= 1.0) 
   {
      ManageEmergencyPositions();
      EmergencyRecoveryStop();
      return;
   }
   
   // ===== üü° BAR DETECTION =====
   datetime currentBar = iTime(_Symbol, PERIOD_M1, 0);
   newBar = (currentBar != lastBarTime); // ‚úÖ ‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ global
   
   // ===== üü¢ LIGHT SYSTEMS (‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ó‡∏∏‡∏Å Tick) =====
   ManageScalp3PairClosing();  // ‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏ö‡∏≤
   RunSafetyCheck();           // ‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏ö‡∏≤
   
   // ===== üî• MARKET REGIME DETECTION (‡∏ó‡∏∏‡∏Å Tick) =====
   static ENUM_MARKET_REGIME lastRegime = MARKET_REGIME_NORMAL;
   ENUM_MARKET_REGIME currentRegime = DetectMarketRegime();
   
   // ‡∏ñ‡πâ‡∏≤‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô
   if(currentRegime != lastRegime)
   {
      if(EnableDebugMode) Print("üîÑ Market regime changed from " + EnumToString(lastRegime) + 
                                " to " + EnumToString(currentRegime));
      AdjustStrategyByRegime(currentRegime);
      lastRegime = currentRegime;
   }
   
   // ===== üéØ NEW BAR OPERATIONS =====
   if(newBar) 
   {
      ProcessNewBarOperations(currentRegime); // ‚úÖ ‡∏™‡πà‡∏á currentRegime ‡πÑ‡∏õ‡∏î‡πâ‡∏ß‡∏¢
      lastBarTime = currentBar;
   }
}

void ProcessNewBarOperations(ENUM_MARKET_REGIME currentRegime)
{
   // ‚úÖ ‡∏£‡∏∞‡∏ö‡∏ö‡∏´‡∏ô‡∏±‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏¢‡πâ‡∏≤‡∏¢‡∏°‡∏≤‡∏ó‡∏≥‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà (‡πÅ‡∏Ñ‡πà‡πÅ‡∏ó‡πà‡∏á‡πÉ‡∏´‡∏°‡πà)
   
   // 1. ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô
   UpdatePortfolioHealth();
   UpdateStrategyContributions();
   UpdateAllSetProfits();
   CheckAndCloseHedgedPairs();
   
   // üî• ‡∏õ‡∏£‡∏±‡∏ö Adaptive Logic ‡∏ï‡∏≤‡∏° Market Regime
   AdjustTradingPlanForNewRegime(currentRegime);
   
   // üî• ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ Market Analysis ‡∏Å‡πà‡∏≠‡∏ô‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à‡πÉ‡∏î‡πÜ
   if(UseMarketAnalysis) 
   {
      ExecuteAdaptiveStrategy(currentRegime); 
      AdaptiveParameterAdjustment(currentRegime); 
   }
   
   // 2. Cooperative System
   if(EnableCooperativeSystem) 
   {
      static bool teamInitialized = false;
      if(!teamInitialized) 
      {
         SetupMissionTeam();
         teamInitialized = true;
      }
      ManageCooperativeStrategies(currentRegime);
      DisplayCooperativeDashboard();
   }
   
   // 3. ‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏ó‡∏£‡∏î‡∏´‡∏•‡∏±‡∏Å (‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° Market Regime)
   if(SystemMode == MODE_RECOVERY) 
   {
      ExecuteRecoveryTrading(currentRegime);
   } 
   else 
   {
      ExecuteNormalTrading(currentRegime);
   }
   
   // 4. Orphan Monitoring
   if(needOrphanMonitoring) 
   {
      ManageOrphanedRecoverySets();
      ManageOrphanUniversal();
      ManageOrphanWorkers();
   }
   
   // 5. ‡∏£‡∏∞‡∏ö‡∏ö‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠
   if(EnableIndividualRecovery && SystemMode != MODE_RECOVERY) 
   {
      ManageIndividualRecoverySets();
   }
   
   if(StepUpRecoveryEnabled && SystemMode != MODE_RECOVERY) 
   {
      ManageStepUpRecovery();
   }
   
   // 6. Counter Position (‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÇ‡∏´‡∏°‡∏î‡∏õ‡∏Å‡∏ï‡∏¥)
   if(EnableCounterPosition && SystemMode != MODE_RECOVERY) 
   {
      ManageCounterPositions(currentRegime);
   }
   
   // 7. Portfolio Management
   if(CalculateTotalProfit() < 0 && SystemMode != MODE_RECOVERY) 
   {
      PrioritizeAndExecuteHelp();
   }
   
   ManageSmartPortfolioClosing();
}

// üî• ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏ó‡∏£‡∏î‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ Market Analysis
void ExecuteNormalTrading(ENUM_MARKET_REGIME currentRegime)
{
   // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡πÅ‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà: ‡∏™‡πà‡∏á currentRegime ‡πÑ‡∏õ‡∏î‡πâ‡∏ß‡∏¢
   // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç ShouldOpenTrade ‡∏Å‡πà‡∏≠‡∏ô
   
   // Scalp1 Strategy
   if(ShouldOpenTrade(ORDER_TYPE_BUY, currentRegime) && 
      ShouldOpenPosition("Scalp1", 0, NULL, currentRegime)) 
   {
      ExecuteScalp1(currentRegime);
   }
   
   if(ShouldOpenTrade(ORDER_TYPE_SELL, currentRegime) && 
      ShouldOpenPosition("Scalp1", 0, NULL, currentRegime)) 
   {
      ExecuteScalp1(currentRegime);
   }
      
   // Trend Strategy
   if(ShouldOpenTrade(ORDER_TYPE_BUY, currentRegime) && 
      ShouldOpenPosition("Trend", 0, NULL, currentRegime)) 
   {
      ExecuteSimpleTrendScalp(currentRegime);
   }
   
   if(ShouldOpenTrade(ORDER_TYPE_SELL, currentRegime) && 
      ShouldOpenPosition("Trend", 0, NULL, currentRegime)) 
   {
      ExecuteSimpleTrendScalp(currentRegime);
   }
      
   // Breakout Strategy
   if(ShouldOpenTrade(ORDER_TYPE_BUY, currentRegime) && 
      ShouldOpenPosition("Breakout", 0, NULL, currentRegime)) 
   {
      ExecuteAdvancedBreakout(currentRegime);
   }
   
   if(ShouldOpenTrade(ORDER_TYPE_SELL, currentRegime) && 
      ShouldOpenPosition("Breakout", 0, NULL, currentRegime)) 
   {
      ExecuteAdvancedBreakout(currentRegime);
   }
}


void ExecuteRecoveryTrading(ENUM_MARKET_REGIME currentRegime)
{
   // Recovery systems ‡∏Å‡∏±‡∏ö market condition
   
   // RecoveryScalp2
   if(ShouldOpenTrade(ORDER_TYPE_BUY, currentRegime) && 
      ShouldOpenPosition("RecoveryScalp2", 0, NULL, currentRegime) && 
      CalculateRiskPressure() < 0.5) 
   {
      ExecuteScalp1(currentRegime);
   }
   
   if(ShouldOpenTrade(ORDER_TYPE_SELL, currentRegime) && 
      ShouldOpenPosition("RecoveryScalp2", 0, NULL, currentRegime) && 
      CalculateRiskPressure() < 0.5) 
   {
      ExecuteScalp1(currentRegime);
   }
   
   // RecoveryScalp3
   if(ShouldOpenTrade(ORDER_TYPE_BUY, currentRegime) && 
      ShouldOpenPosition("RecoveryScalp3", 0, NULL, currentRegime) && 
      CalculateRiskPressure() < 0.6) 
   {
      ExecuteSimpleTrendScalp(currentRegime);
   }
   
   if(ShouldOpenTrade(ORDER_TYPE_SELL, currentRegime) && 
      ShouldOpenPosition("RecoveryScalp3", 0, NULL, currentRegime) && 
      CalculateRiskPressure() < 0.6) 
   {
      ExecuteSimpleTrendScalp(currentRegime);
   }
}
//----------------ontick New system ---------------//
//+------------------------------------------------------------------+
//| Open Test Position                                              |
//+------------------------------------------------------------------+
void OpenTestPosition()
{
   double lot = BaseLot;
   if(CheckMargin(lot))
   {
      trade.SetExpertMagicNumber(MAGIC_TEST_SIMPLE);
      
      // Random direction ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏≤‡∏°‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì
      bool buySignal = (MathRand() % 2 == 0);
      
      if(buySignal)
      {
         double tpPrice = GetTPPriceUniversal(true, Test_TP_Points);
         double slPrice = (Test_SL_Points > 0) ? GetSLPriceUniversal(true, Test_SL_Points) : 0;
         
         if(trade.Buy(lot, _Symbol, slPrice, 0, tpPrice, "Test-Buy-M1000"))
         {
            Print("?? TEST BUY | Magic 1000 | Lot: " + DoubleToString(lot, 2));
         }
      }
      else
      {
         double tpPrice = GetTPPriceUniversal(false, Test_TP_Points);
         double slPrice = (Test_SL_Points > 0) ? GetSLPriceUniversal(false, Test_SL_Points) : 0;
         
         if(trade.Sell(lot, _Symbol, slPrice, 0, tpPrice, "Test-Sell-M1000"))
         {
            Print("?? TEST SELL | Magic 1000 | Lot: " + DoubleToString(lot, 2));
         }
      }
   }
}
//+------------------------------------------------------------------+
//| Print System Status                                             |
//+------------------------------------------------------------------+
void PrintSystemStatus()
{
    string status = "=== SYSTEM STATUS ===\n";
    status += "Equity: $" + DoubleToString(AccountInfoDouble(ACCOUNT_EQUITY), 2) + "\n";
    status += "Positions: " + IntegerToString(PositionsTotal()) + "\n";
    status += "Risk Pressure: " + DoubleToString(CalculateRiskPressure(), 2) + "\n";
    status += "Cooperative Progress: " + DoubleToString((totalCollaborativeProfit/collaborativeTarget)*100, 1) + "%\n";
    DebugPrint(1, status);
}
//+------------------------------------------------------------------+
//| Check Battle Status                                             |
//+------------------------------------------------------------------+
void CheckBattleStatus()
{
   double currentEquity = accountInfo.Equity();
   double currentBalance = accountInfo.Balance();
   
   if(currentBalance <= 0) return;
   
   double drawdownPercent = (currentBalance - currentEquity) / currentBalance * 100.0;
   
   // Ultimate Fighting Mode - More aggressive phase transitions
   if(UltimateFightingMode)
   {
      int newPhase = 0;
      if(drawdownPercent >= Phase5Trigger) newPhase = 5;
      else if(drawdownPercent >= Phase4Trigger) newPhase = 4;
      else if(drawdownPercent >= Phase3Trigger) newPhase = 3;
      else if(drawdownPercent >= Phase2Trigger) newPhase = 2;
      else if(drawdownPercent >= Phase1Trigger) newPhase = 1;
      
      if(newPhase > currentFightingPhase)
      {
         currentFightingPhase = newPhase;
         phaseStartEquity = currentEquity;
         phaseStartTime = TimeCurrent();
         fightingTradesCount = 0;
         
         Print("?? ULTIMATE FIGHTING PHASE " + IntegerToString(currentFightingPhase) + " ACTIVATED!");
         Print("?? Drawdown: " + DoubleToString(drawdownPercent, 1) + "% | Equity: $" + DoubleToString(currentEquity, 2));
         Print("?? Aggression Level: " + DoubleToString(GetPhaseAggression(currentFightingPhase), 1));
      }
   }
   else
   {
      // Original battle mode logic
      if(currentEquity < currentBalance * 0.8)
      {
         if(!isInBattleMode)
         {
            isInBattleMode = true;
            battlePhase = 1;
            Print("?? ENTERING BATTLE MODE! Drawdown: " + 
                  DoubleToString((currentBalance-currentEquity)/currentBalance*100, 1) + "%");
         }
      }
      
      if(isInBattleMode)
      {
         if(drawdownPercent > 25.0 && battlePhase == 1)
         {
            battlePhase = 2;
            Print("?? BATTLE PHASE 2! Aggressive recovery activated!");
         }
         else if(drawdownPercent > 35.0 && battlePhase == 2)
         {
            battlePhase = 3;
            Print("?? BATTLE PHASE 3! LAST STAND mode!");
         }
      }
   }
   
   lastEquity = currentEquity;
}

//+------------------------------------------------------------------+
//| Get aggression multiplier for current phase                     |
//+------------------------------------------------------------------+
double GetPhaseAggression(int phase)
{
   double baseAggression = FightingAggressionLevel;
   
   switch(phase)
   {
      case 1: return baseAggression * 1.2;
      case 2: return baseAggression * 1.5;
      case 3: return baseAggression * 1.8;
      case 4: return baseAggression * 2.2;
      case 5: return baseAggression * 3.0;
      default: return baseAggression;
   }
}

//+------------------------------------------------------------------+
//| Manage Emergency Positions                                      |
//+------------------------------------------------------------------+
void ManageEmergencyPositions()
{
   int totalPos = PositionsTotal();
   if(totalPos == 0) return;
   
   for(int i = totalPos-1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         double profit = PositionGetDouble(POSITION_PROFIT);
         if(profit > 2.0)
         {
            trade.PositionClose(ticket);
            Print("?? Emergency close profit: $" + DoubleToString(profit, 2));
            break;
         }
      }
   }
   
   CheckAndCloseProfitPairs();
   
   if(totalPos < MaxTotalPositions)
   {
      TryEmergencyCounter();
   }
}

//+------------------------------------------------------------------+
//| Try Emergency Counter                                           |
//+------------------------------------------------------------------+
void TryEmergencyCounter(ENUM_MARKET_REGIME regime = MARKET_REGIME_NORMAL)
{
   // ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö regime ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏™‡πà‡∏á‡∏°‡∏≤
   if(regime == MARKET_REGIME_NORMAL)
   {
      regime = DetectMarketRegime();
   }
   
   ulong worstTicket = 0;
   double worstProfit = 0;
   ENUM_POSITION_TYPE worstType = (ENUM_POSITION_TYPE)WRONG_VALUE_CONST;
   double worstVolume = 0;
   string worstSymbol = "";
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         long magic = PositionGetInteger(POSITION_MAGIC);
         double profit = PositionGetDouble(POSITION_PROFIT);
         
         if(magic == MAGIC_COUNTER || magic == MAGIC_HEDGE || magic == MAGIC_RECOVERY) continue;
         
         if(profit < worstProfit)
         {
            worstTicket = ticket;
            worstProfit = profit;
            worstType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            worstVolume = PositionGetDouble(POSITION_VOLUME);
            worstSymbol = PositionGetString(POSITION_SYMBOL);
         }
      }
   }
   
   if(worstTicket == 0) return;
   
   double emergencyTrigger = localCounterTrigger;
   if(battlePhase >= 2) emergencyTrigger = localCounterTrigger * 0.7;
  
   if(worstProfit <= -emergencyTrigger)
   {
      // üî• ‡∏õ‡∏£‡∏±‡∏ö counter multiplier ‡∏ï‡∏≤‡∏° regime
      double counterMultiplier = GetEmergencyCounterMultiplierForRegime(regime);
      double counterLot = worstVolume * localCounterMultiplier * counterMultiplier;
      
      if(battlePhase >= 2) counterLot *= localAggressiveMult;
      
      counterLot = MathMin(counterLot, MaxLot);
      
      if(CheckMargin(counterLot))
      {
         // üî• ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏™‡πà‡∏á regime ‡πÑ‡∏õ‡∏î‡πâ‡∏ß‡∏¢
         OpenCounterPosition(worstTicket, worstType, worstVolume, worstSymbol, worstProfit, regime);
      }
   }
}
// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô helper ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö emergency counter
double GetEmergencyCounterMultiplierForRegime(ENUM_MARKET_REGIME regime)
{
    switch(regime)
    {
        case MARKET_REGIME_RANGING_VOLATILE:
            return 0.5; // ‡∏•‡∏î lot ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
            
        case MARKET_REGIME_TRENDING_STRONG:
            return 0.8; // ‡∏•‡∏î lot ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            return 0.6; // ‡∏•‡∏î lot ‡πÉ‡∏ô breakout
            
        case MARKET_REGIME_RANGING_CALM:
            return 1.2; // ‡∏≠‡∏≤‡∏à‡πÄ‡∏û‡∏¥‡πà‡∏° lot ‡πÉ‡∏ô sideways ‡πÄ‡∏á‡∏µ‡∏¢‡∏ö
            
        case MARKET_REGIME_NORMAL:
        default:
            return 1.0;
    }
}
//+------------------------------------------------------------------+
//| Open Counter Position                                           |
//+------------------------------------------------------------------+
bool OpenCounterPosition(ulong ticket, ENUM_POSITION_TYPE type, double volume, string symbol, double profit, ENUM_MARKET_REGIME regime)
{
    // ‡∏õ‡∏£‡∏±‡∏ö volume ‡∏ï‡∏≤‡∏° regime
    double adjustedVolume = AdjustCounterVolume(volume, regime);
    
    // ‡∏à‡∏≥‡∏Å‡∏±‡∏î volume ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥
    double minVolume = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MIN);
    adjustedVolume = MathMax(adjustedVolume, minVolume);
    
    // ‡∏à‡∏≥‡∏Å‡∏±‡∏î volume ‡∏Ç‡∏±‡πâ‡∏ô‡∏™‡∏π‡∏á
    double maxVolume = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MAX);
    adjustedVolume = MathMin(adjustedVolume, maxVolume);
    
    // ‡∏õ‡∏£‡∏±‡∏ö stop loss ‡∏ï‡∏≤‡∏° regime
    double slDistance = GetCounterStopLossDistance(regime);
    
    // ‡∏õ‡∏£‡∏±‡∏ö take profit ‡∏ï‡∏≤‡∏° regime
    double tpDistance = GetCounterTakeProfitDistance(regime);
    
    // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á counter
    ENUM_ORDER_TYPE counterType = (type == POSITION_TYPE_BUY) ? ORDER_TYPE_SELL : ORDER_TYPE_BUY;
    
    // ‡∏£‡∏±‡∏ö‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
    double currentPrice = SymbolInfoDouble(symbol, 
        (counterType == ORDER_TYPE_BUY) ? SYMBOL_ASK : SYMBOL_BID);
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì SL ‡πÅ‡∏•‡∏∞ TP price
    double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
    double slPrice = 0, tpPrice = 0;
    
    if(counterType == ORDER_TYPE_BUY)
    {
        slPrice = currentPrice - slDistance * point;
        tpPrice = currentPrice + tpDistance * point;
    }
    else // ORDER_TYPE_SELL
    {
        slPrice = currentPrice + slDistance * point;
        tpPrice = currentPrice - tpDistance * point;
    }
    
    // ‡∏õ‡∏±‡∏î‡πÄ‡∏®‡∏©‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏≤‡∏° digits
    int digits = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);
    slPrice = NormalizeDouble(slPrice, digits);
    tpPrice = NormalizeDouble(tpPrice, digits);
    adjustedVolume = NormalizeDouble(adjustedVolume, 2);
    
    Print("Opening counter position in ", EnumToString(regime), " regime");
    Print("Symbol: ", symbol, 
          " | Type: ", EnumToString(counterType),
          " | Volume: ", adjustedVolume,
          " | Original loss: ", profit);
    Print("SL Distance: ", slDistance, " points | TP Distance: ", tpDistance, " points");
    Print("Entry: ", currentPrice, " | SL: ", slPrice, " | TP: ", tpPrice);
    
    // ‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå
    trade.SetExpertMagicNumber(MAGIC_COUNTER);
    
    if(counterType == ORDER_TYPE_BUY)
    {
        if(trade.Buy(adjustedVolume, symbol, slPrice, 0, tpPrice, 
                     "Counter-Buy-" + EnumToString(regime) + "-For-" + IntegerToString((int)ticket)))
        {
            Print("‚úÖ Counter BUY opened successfully");
            return true;
        }
        else
        {
            Print("‚ùå Counter BUY failed: ", trade.ResultRetcodeDescription());
            return false;
        }
    }
    else // ORDER_TYPE_SELL
    {
        if(trade.Sell(adjustedVolume, symbol, slPrice, 0, tpPrice, 
                      "Counter-Sell-" + EnumToString(regime) + "-For-" + IntegerToString((int)ticket)))
        {
            Print("‚úÖ Counter SELL opened successfully");
            return true;
        }
        else
        {
            Print("‚ùå Counter SELL failed: ", trade.ResultRetcodeDescription());
            return false;
        }
    }
}
double AdjustCounterVolume(double originalVolume, ENUM_MARKET_REGIME regime)
{
    double multiplier = 1.0;
    
    switch(regime)
    {
        case MARKET_REGIME_RANGING_VOLATILE:
            multiplier = 0.5; // ‡∏•‡∏î volume ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
            break;
            
        case MARKET_REGIME_TRENDING_STRONG:
            multiplier = 0.7; // ‡∏•‡∏î volume ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á
            break;
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            multiplier = 0.6; // ‡∏•‡∏î volume ‡πÉ‡∏ô breakout
            break;
            
        default:
            multiplier = 1.0;
            break;
    }
    
    return originalVolume * multiplier;
}

//+------------------------------------------------------------------+
//| Execute Low Risk Opportunity                                    |
//+------------------------------------------------------------------+
void ExecuteLowRiskOpportunity()
{
   if(!newBar) return;
   
   MqlRates rates[];
   if(CopyRates(_Symbol, PERIOD_M5, 0, 10, rates) != 10) return;
   
   double atr = CalculateATR(14, 0, _Symbol);
   bool strongBuy = (rates[0].close > rates[1].high + atr * 0.5) && 
                    (rates[0].close > rates[0].open);
   bool strongSell = (rates[0].close < rates[1].low - atr * 0.5) && 
                     (rates[0].close < rates[0].open);
   
   if(strongBuy && CountPositionsByType(POSITION_TYPE_BUY) < 2)
   {
      double smallLot = BaseLot * 0.5;
      if(CheckMargin(smallLot))
      {
         trade.SetExpertMagicNumber(MAGIC_SCALP1);
         double tpPrice = GetTPPriceUniversal(true, LowRisk_TP_Points);
         if(trade.Buy(smallLot, _Symbol, 0, 0, tpPrice, "LowRisk-Buy"))
         {
            Print("?? Low Risk BUY opened, TP: " + IntegerToString(LowRisk_TP_Points) + " pips");
         }
      }
   }
   else if(strongSell && CountPositionsByType(POSITION_TYPE_SELL) < 2)
   {
      double smallLot = BaseLot * 0.5;
      if(CheckMargin(smallLot))
      {
         trade.SetExpertMagicNumber(MAGIC_SCALP1);
         double tpPrice = GetTPPriceUniversal(false, LowRisk_TP_Points);
         if(trade.Sell(smallLot, _Symbol, 0, 0, tpPrice, "LowRisk-Sell"))
         {
            Print("?? Low Risk SELL opened, TP: " + IntegerToString(LowRisk_TP_Points) + " pips");
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Manage Counter Positions                                        |
//+------------------------------------------------------------------+
void ManageCounterPositions(ENUM_MARKET_REGIME regime) 
{
   if(!EnableCounterPosition) return;
   
   // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ counter position ‡∏Ñ‡∏ß‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÉ‡∏ô regime ‡∏ô‡∏µ‡πâ‡πÑ‡∏´‡∏°
   if(!ShouldUseCounterPositionsInRegime(regime)) 
   {
      if(EnableDebugMode) Print("Counter positions disabled for regime: ", EnumToString(regime));
      return;
   }
   
   ulong worstTicket = 0;
   double worstProfit = 0;
   ENUM_POSITION_TYPE worstType = WRONG_VALUE;
   double worstVolume = 0;
   string worstSymbol = "";
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         long magic = PositionGetInteger(POSITION_MAGIC);
         double profit = PositionGetDouble(POSITION_PROFIT);
         
         if(magic == MAGIC_COUNTER || magic == MAGIC_HEDGE || magic == MAGIC_RECOVERY) continue;
         
         if(profit < worstProfit)
         {
            worstTicket = ticket;
            worstProfit = profit;
            worstType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            worstVolume = PositionGetDouble(POSITION_VOLUME);
            worstSymbol = PositionGetString(POSITION_SYMBOL);
         }
      }
   }
   
   if(worstTicket == 0) return;
   
   // ‡∏õ‡∏£‡∏±‡∏ö counter trigger ‡∏ï‡∏≤‡∏° regime
   double adjustedCounterTrigger = GetCounterTriggerForRegime(regime);
   
   if(worstProfit > -adjustedCounterTrigger) return;
   
   if(HasCounterPositionFor(worstTicket)) return;
   
   // ‡∏õ‡∏£‡∏±‡∏ö max counter positions ‡∏ï‡∏≤‡∏° regime
   int adjustedMaxCounter = GetMaxCounterPositionsForRegime(regime);
   
   if(CountCounterPositions() >= adjustedMaxCounter) 
   {
      Print("Maximum counter positions reached: " + IntegerToString(adjustedMaxCounter));
      return;
   }
   
   // ‡πÄ‡∏õ‡∏¥‡∏î counter position
   OpenCounterPosition(worstTicket, worstType, worstVolume, worstSymbol, worstProfit, regime);
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô (‡∏ï‡πâ‡∏≠‡∏á‡∏™‡πà‡∏á regime ‡πÑ‡∏õ‡∏î‡πâ‡∏ß‡∏¢)
void CheckAndManageCounterPositions()
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö market regime
    ENUM_MARKET_REGIME currentRegime = DetectMarketRegime();
    
    // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ ManageCounterPositions
    ManageCounterPositions(currentRegime);
}
double GetCounterStopLossDistance(ENUM_MARKET_REGIME regime)
{
    double baseSL = localCounterSL; // ‡∏Ñ‡πà‡∏≤ SL ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô (‡∏Ñ‡∏ß‡∏£‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡πÉ‡∏ô input parameters)
    
    if(baseSL <= 0) 
    {
        // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡πà‡∏≤ SL ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô ‡πÉ‡∏´‡πâ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≤‡∏Å ATR
        double atr = GetATRValue(_Symbol, PERIOD_H1, 14, 0);
        baseSL = atr * 2; // 2 * ATR
    }
    
    double multiplier = 1.0;
    
    switch(regime)
    {
        case MARKET_REGIME_RANGING_VOLATILE:
            multiplier = 0.7; // SL ‡πÅ‡∏Ñ‡∏ö‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
            break;
            
        case MARKET_REGIME_TRENDING_STRONG:
            multiplier = 1.3; // SL ‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á
            break;
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            multiplier = 1.2; // SL ‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡πÉ‡∏ô breakout
            break;
            
        case MARKET_REGIME_RANGING_CALM:
            multiplier = 0.9; // SL ‡πÅ‡∏Ñ‡∏ö‡πÉ‡∏ô sideways ‡πÄ‡∏á‡∏µ‡∏¢‡∏ö
            break;
            
        default:
            multiplier = 1.0;
    }
    
    return baseSL * multiplier;
}


double GetCounterTakeProfitDistance(ENUM_MARKET_REGIME regime)
{
    double baseTP = localCounterTP; // ‡∏Ñ‡πà‡∏≤ TP ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô
    
    if(baseTP <= 0) 
    {
        // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡πà‡∏≤ TP ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô ‡πÉ‡∏´‡πâ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≤‡∏Å ATR
        double atr = GetATRValue(_Symbol, PERIOD_H1, 14, 0);
        baseTP = atr * 3; // 3 * ATR
    }
    
    double multiplier = 1.0;
    
    switch(regime)
    {
        case MARKET_REGIME_TRENDING_STRONG:
            multiplier = 1.5; // TP ‡∏¢‡∏≤‡∏ß‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á
            break;
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            multiplier = 1.8; // TP ‡∏¢‡∏≤‡∏ß‡πÉ‡∏ô breakout
            break;
            
        case MARKET_REGIME_RANGING_VOLATILE:
            multiplier = 0.6; // TP ‡∏™‡∏±‡πâ‡∏ô‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
            break;
            
        case MARKET_REGIME_RANGING_CALM:
            multiplier = 0.8; // TP ‡∏™‡∏±‡πâ‡∏ô‡πÉ‡∏ô sideways ‡πÄ‡∏á‡∏µ‡∏¢‡∏ö
            break;
            
        default:
            multiplier = 1.0;
    }
    
    return baseTP * multiplier;
}
double GetCounterTriggerForRegime(ENUM_MARKET_REGIME regime)
{
    double baseTrigger = localCounterTrigger;
    
    switch(regime)
    {
        case MARKET_REGIME_TRENDING_STRONG:
            // ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á ‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö drawdown ‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤‡∏ô‡∏¥‡∏î‡∏´‡∏ô‡πà‡∏≠‡∏¢
            return baseTrigger * 1.3;
            
        case MARKET_REGIME_RANGING_VOLATILE:
            // ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô ‡πÉ‡∏ä‡πâ trigger ‡πÅ‡∏Ñ‡∏ö
            return baseTrigger * 0.6;
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            // ‡πÉ‡∏ô breakout ‡∏£‡∏∞‡∏ß‡∏±‡∏á
            return baseTrigger * 0.8;
            
        default:
            return baseTrigger;
    }
}
int GetMaxCounterPositionsForRegime(ENUM_MARKET_REGIME regime)
{
    int baseMax = localMaxCounter;
    
    switch(regime)
    {
        case MARKET_REGIME_RANGING_VOLATILE:
            // ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô ‡∏•‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô counter positions
            return MathMax(1, baseMax / 2);
            
        case MARKET_REGIME_TRENDING_STRONG:
            // ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á ‡∏≠‡∏≤‡∏à‡πÄ‡∏û‡∏¥‡πà‡∏° counter positions ‡πÑ‡∏î‡πâ
            return MathMin(baseMax + 1, 5);
            
        default:
            return baseMax;
    }
}
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Helper ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö counter positions
bool ShouldUseCounterPositionsInRegime(ENUM_MARKET_REGIME regime)
{
    switch(regime)
    {
        case MARKET_REGIME_RANGING_VOLATILE:
            // ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô ‡πÑ‡∏°‡πà‡∏Ñ‡∏ß‡∏£‡πÉ‡∏ä‡πâ counter positions
            return false;
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            // ‡πÉ‡∏ô breakout ‡∏£‡∏∞‡∏ß‡∏±‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ counter positions
            return (CalculateMarketStability() > 0.7);
            
        case MARKET_REGIME_TRENDING_STRONG:
            // ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á ‡πÉ‡∏ä‡πâ counter positions ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Å‡∏±‡∏ö pullback
            return IsInPullbackPhase();
            
        default:
            return true;
    }
}
double CalculateMarketStability()
{
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì market stability ‡∏à‡∏≤‡∏Å ATR ‡πÅ‡∏•‡∏∞ volatility
    double atr = GetATRValue(_Symbol, PERIOD_H1, 14, 0);
    double atrAvg = GetATRAverage(_Symbol, PERIOD_H1, 14, 20);
    
    if(atrAvg == 0) return 1.0;
    
    double stability = 1.0 - MathMin(MathAbs(atr - atrAvg) / atrAvg, 1.0);
    return MathMax(stability, 0.0);
}
bool IsInPullbackPhase()
{
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    // ‚úÖ ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á: ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ GetEMAValue ‡∏î‡πâ‡∏ß‡∏¢ 4 ‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå
    double ema20 = GetEMAValue(_Symbol, PERIOD_H1, 20, 0);
    
    if(ema20 <= 0) 
    {
        if(EnableDebugMode) Print("Failed to get EMA20 value");
        return false;
    }
    
    // ‚úÖ ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á: GetATRValue ‡πÉ‡∏ä‡πâ 4 ‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÄ‡∏ä‡πà‡∏ô‡∏Å‡∏±‡∏ô
    double atr = GetATRValue(_Symbol, PERIOD_H1, 14, 0);
    
    if(atr <= 0)
    {
        if(EnableDebugMode) Print("Failed to get ATR value");
        return false;
    }
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å EMA20
    double distance = MathAbs(currentPrice - ema20);
    
    // ‡∏ñ‡πâ‡∏≤‡∏£‡∏≤‡∏Ñ‡∏≤‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏Å‡∏•‡πâ EMA20 (‡∏†‡∏≤‡∏¢‡πÉ‡∏ô 0.5 * ATR)
    bool isNearEMA = (distance < atr * 0.5);
    
    if(EnableDebugMode)
    {
        Print("IsInPullbackPhase - Price: ", currentPrice, 
              " | EMA20: ", ema20, 
              " | ATR: ", atr,
              " | Distance: ", distance,
              " | IsNear: ", isNearEMA ? "Yes" : "No");
    }
    
    return isNearEMA;
}
//+------------------------------------------------------------------+
//| Check if counter position exists for main ticket                |
//+------------------------------------------------------------------+
bool HasCounterPositionFor(ulong mainTicket)
{
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         long magic = PositionGetInteger(POSITION_MAGIC);
         if(magic == MAGIC_COUNTER)
         {
            string comment = PositionGetString(POSITION_COMMENT);
            int foundPos = StringFind(comment, TicketToStr(mainTicket));
            if(foundPos != -1)
               return true;
         }
      }
   }
   return false;
}

//+------------------------------------------------------------------+
//| Count counter positions                                         |
//+------------------------------------------------------------------+
int CountCounterPositions()
{
    int count = 0;
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            long magic = PositionGetInteger(POSITION_MAGIC);
            if(magic == MAGIC_COUNTER)
            {
                count++;
            }
        }
    }
    return count;
}

bool OpenOrderWithParameters(ENUM_ORDER_TYPE orderType, double volume, string symbol, 
                            double slDistancePoints, double tpDistancePoints)
{
    double price = (orderType == ORDER_TYPE_BUY) ? 
                   SymbolInfoDouble(symbol, SYMBOL_ASK) : 
                   SymbolInfoDouble(symbol, SYMBOL_BID);
    
    double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
    double slPrice = 0, tpPrice = 0;
    
    if(orderType == ORDER_TYPE_BUY)
    {
        slPrice = price - slDistancePoints * point;
        tpPrice = price + tpDistancePoints * point;
    }
    else
    {
        slPrice = price + slDistancePoints * point;
        tpPrice = price - tpDistancePoints * point;
    }
    
    trade.SetExpertMagicNumber(MAGIC_COUNTER);
    
    if(orderType == ORDER_TYPE_BUY)
    {
        return trade.Buy(volume, symbol, slPrice, 0, tpPrice, "Counter-Buy");
    }
    else
    {
        return trade.Sell(volume, symbol, slPrice, 0, tpPrice, "Counter-Sell");
    }
}
//+------------------------------------------------------------------+
//| Check and close profit pairs                                    |
//+------------------------------------------------------------------+
void CheckAndCloseProfitPairs()
{
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         long magic = PositionGetInteger(POSITION_MAGIC);
         if(magic == MAGIC_COUNTER)
         {
            ulong mainTicket = FindMainTicketFromCounter(ticket);
            if(mainTicket > 0)
            {
               double pairProfit = CalculatePairProfit(mainTicket, ticket);
               
               if(pairProfit >= CounterProfitTarget)
               {
                  ClosePositionPair(mainTicket, ticket);
                  Print("?? Profit pair closed: $" + DoubleToString(pairProfit, 2));
               }
            }
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Find main ticket from counter                                   |
//+------------------------------------------------------------------+
ulong FindMainTicketFromCounter(ulong counterTicket)
{
   if(PositionSelectByTicket(counterTicket))
   {
      string comment = PositionGetString(POSITION_COMMENT);
      int startPos = StringFind(comment, "-");
      if(startPos != -1)
      {
         string ticketStr = StringSubstr(comment, startPos + 1);
         return StringToInteger(ticketStr);
      }
   }
   return 0;
}

//+------------------------------------------------------------------+
//| Calculate pair profit                                           |
//+------------------------------------------------------------------+
double CalculatePairProfit(ulong mainTicket, ulong counterTicket)
{
   double totalProfit = 0;
   
   if(PositionSelectByTicket(mainTicket))
      totalProfit += PositionGetDouble(POSITION_PROFIT);
   
   if(PositionSelectByTicket(counterTicket))
      totalProfit += PositionGetDouble(POSITION_PROFIT);
   
   return totalProfit;
}

//+------------------------------------------------------------------+
//| Close position pair                                             |
//+------------------------------------------------------------------+
void ClosePositionPair(ulong mainTicket, ulong counterTicket)
{
   bool mainClosed = false;
   bool counterClosed = false;
   
   if(PositionSelectByTicket(mainTicket))
   {
      mainClosed = trade.PositionClose(mainTicket);
      if(mainClosed) Print("? Main position closed: #" + TicketToStr(mainTicket));
   }
   
   if(PositionSelectByTicket(counterTicket))
   {
      counterClosed = trade.PositionClose(counterTicket);
      if(counterClosed) 
      {
         Print("? Counter position closed: #" + TicketToStr(counterTicket));
         counterPositionsCount = MathMax(0, counterPositionsCount - 1);
      }
   }
   
   if(mainClosed && counterClosed)
   {
      Print("?? Position pair successfully closed!");
   }
}

//+------------------------------------------------------------------+
//| ULTIMATE FIGHTING RECOVERY - NEVER GIVE UP                     |
//+------------------------------------------------------------------+
// ‚úÖ ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡∏ô‡∏µ‡πâ (‡∏≠‡∏±‡∏ô‡πÅ‡∏£‡∏Å) - ‡∏°‡∏µ implementation ‡πÄ‡∏ï‡πá‡∏°
void ExecuteUltimateFightingRecovery()
{
   double totalProfit = CalculateTotalProfit();
   double currentEquity = AccountInfoDouble(ACCOUNT_EQUITY);
   double currentBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   if(currentBalance <= 0) return;
   
   double drawdownPercent = (currentBalance - currentEquity) / currentBalance * 100.0;
   
   // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Ultimate Fighting Mode
   CheckUltimateFightingMode();
   
   if(currentFightingPhase == 0) return;
   
   // ‚úÖ AGGRESSIVE TARGET MANAGEMENT - Fight to break even first
   double phaseProgress = (currentEquity - phaseStartEquity) / MathAbs(phaseStartEquity) * 100.0;
   
   // ‚úÖ ‡∏õ‡∏¥‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏≥‡πÑ‡∏£‡∏à‡∏£‡∏¥‡∏á‡πÅ‡∏•‡∏∞‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô
   if(phaseProgress >= 25.0 && totalProfit > 0) // 25% recovery + ‡∏Å‡∏≥‡πÑ‡∏£‡∏£‡∏ß‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏ö‡∏ß‡∏Å
   {
      Print("üéâ STRONG RECOVERY ACHIEVED: " + DoubleToString(phaseProgress, 1) + "% in Phase " + IntegerToString(currentFightingPhase));
      Print("üí° Consider manual closure if desired");
      // ‚úÖ ‡πÑ‡∏°‡πà‡∏õ‡∏¥‡∏î‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ ‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à
   }
   
   // ‚úÖ ULTIMATE RECOVERY LOGIC - More aggressive and persistent
   if(newBar)
   {
      double aggression = GetPhaseAggression(currentFightingPhase);
      int maxRecoveryForPhase = localMaxSteps + (currentFightingPhase * 2);
      
      if(recoveryLayerCount < maxRecoveryForPhase)
      {
         double totalLoss = CalculateTotalPortfolioLoss();
         
         // Dynamic trigger based on phase and aggression
         double dynamicTrigger = RecoveryTrigger / (aggression * 0.8);
         
         if(totalLoss <= -dynamicTrigger)
         {
            OpenUltimateRecovery(aggression);
            fightingTradesCount++;
         }
      }
   }
   
   // ‚úÖ EMERGENCY COUNTER-ATTACK SYSTEM
   if(currentFightingPhase >= 3 && newBar)
   {
      ExecuteEmergencyCounterAttack();
   }
}
//+------------------------------------------------------------------+
//| Count Total Losing Positions                                    |
//+------------------------------------------------------------------+
int CountTotalLosingPositions()
{
   int count = 0;
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         if(PositionGetDouble(POSITION_PROFIT) < 0)
            count++;
      }
   }
   return count;
}

//+------------------------------------------------------------------+
//| Get Total Main Position Volume - ?????????????             |
//+------------------------------------------------------------------+
double GetTotalMainPositionVolume()
{
    double totalVolume = 0;
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            long magic = PositionGetInteger(POSITION_MAGIC);
            if(!IsHelperPosition(magic)) // ????????????????????
            {
                totalVolume += PositionGetDouble(POSITION_VOLUME);
            }
        }
    }
    return (totalVolume > 0) ? totalVolume : BaseLot;
}
//+------------------------------------------------------------------+
//| Enhanced Recovery System - NEVER GIVE UP                       |
//+------------------------------------------------------------------+
void ManageStepUpRecovery()
{
   if(!StepUpRecoveryEnabled) return;
   if(recoveryStopped && !NeverGiveUpMode) return;
   
   double totalPortfolioLoss = CalculateTotalPortfolioLoss();
   int totalLosingPositions = CountTotalLosingPositions();
   
   if(totalPortfolioLoss <= -RecoveryTrigger && 
      totalLosingPositions >= 1 &&
      recoveryLayerCount < localMaxSteps &&
      newBar)
   {
      double dynamicMultiplier = 1.0 + (recoveryLayerCount * 0.15);
      if(failedRecoveryCount > 0) dynamicMultiplier *= 0.9;
      
      double stepLot = CalculateDynamicRecoveryLot(recoveryLayerCount + 1);
      
      Print("üîÑ STEP-UP RECOVERY | Loss: $" + DoubleToString(totalPortfolioLoss, 2) +
            " | Step: " + IntegerToString(recoveryLayerCount + 1) +
            " | Lot: " + DoubleToString(stepLot, 2) +
            " | Multiplier: " + DoubleToString(dynamicMultiplier, 2));
      
      OpenStepUpRecovery();
   }
}

//+------------------------------------------------------------------+
//| Calculate Total Portfolio Loss - ??????????????             |
//+------------------------------------------------------------------+
double CalculateTotalPortfolioLoss()
{
    double totalLoss = 0;
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            double profit = PositionGetDouble(POSITION_PROFIT);
            if(profit < 0)
            {
                totalLoss += profit;
            }
        }
    }
    return totalLoss;
}
//+------------------------------------------------------------------+
//| Close All Portfolio Positions                                   |
//+------------------------------------------------------------------+
void CloseAllPortfolioPositions(string callerName = "Unknown", string reason = "Not Specified")
{

       // üö® ALERT: ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ú‡∏π‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å
    Alert("üõë CLOSE ALL POSITIONS ACTIVATED");
    Alert("üìû CALLED BY: " + callerName);
    Alert("üéØ REASON: " + reason);
    Alert("üíº POSITIONS: " + IntegerToString(PositionsTotal()));
    Alert("üí∞ EQUITY: $" + DoubleToString(AccountInfoDouble(ACCOUNT_EQUITY), 2));
    
    //----//
   int closedCount = 0;
   int total = PositionsTotal();
   double totalClosedProfit = 0;
   
   for(int i = total-1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         string symbol = PositionGetString(POSITION_SYMBOL);
         double profit = PositionGetDouble(POSITION_PROFIT);
         double volume = PositionGetDouble(POSITION_VOLUME);
         long magic = PositionGetInteger(POSITION_MAGIC);
         
         if(trade.PositionClose(ticket))
         {
            closedCount++;
            Print("? CLOSED: Magic " + IntegerToString(magic) + 
                  " | " + symbol + " | Lot " + DoubleToString(volume, 2) + 
                  " | P/L: $" + DoubleToString(profit, 2));
         }
      }
   }
   
   Print("?? Total closed: " + IntegerToString(closedCount) + " portfolio positions");
   
    // üö® ALERT: ‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•
    Alert("‚úÖ CLOSE ALL COMPLETED");
    Alert("üìä CLOSED: " + IntegerToString(closedCount) + "/" + IntegerToString(total));
    Alert("üí∞ TOTAL P/L: $" + DoubleToString(totalClosedProfit, 2));
    Alert("üë§ CALLED BY: " + callerName);
    Alert("üéØ REASON: " + reason);
}

//+------------------------------------------------------------------+
//| Calculate Recovery Positions Profit                            |
//+------------------------------------------------------------------+
double CalculateRecoveryPositionsProfit()
{
   double profit = 0;
   for(int i = 0; i < PositionsTotal(); i++) {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket)) {
         if(PositionGetInteger(POSITION_MAGIC) == MAGIC_RECOVERY) {
            profit += PositionGetDouble(POSITION_PROFIT);
         }
      }
   }
   return profit;
}

//+------------------------------------------------------------------+
//| Print Recovery Summary                                         |
//+------------------------------------------------------------------+
void PrintRecoverySummary()
{
   Print("=== RECOVERY SUMMARY ===");
   Print("Total Steps: " + IntegerToString(recoveryLayerCount));
   Print("Successful Recoveries: " + IntegerToString(successfulRecoveries));
   Print("Total Recovery Profit: $" + DoubleToString(totalRecoveryProfit, 2));
   Print("Failed Recovery Count: " + IntegerToString(failedRecoveryCount));
   Print("Success Rate: " + DoubleToString((double)successfulRecoveries/MathMax(recoveryLayerCount,1)*100, 1) + "%");
}

//+------------------------------------------------------------------+
//| Check if recovery is allowed                                    |
//+------------------------------------------------------------------+
bool IsRecoveryAllowed()
{
   if(!UseRecoverySafety) return true;
   
   if(NeverGiveUpMode && isInBattleMode) return true;
   
   if(recoveryStopped) return false;
   
   double totalEquity = accountInfo.Equity();
   double totalBalance = accountInfo.Balance();
   
   if(isInBattleMode)
   {
      double drawdownPercent = (totalBalance - totalEquity) / totalBalance * 100.0;
      if(drawdownPercent >= MaxDrawdownPercent * 1.2)
      {
         Print("?? High drawdown but continuing: " + DoubleToString(drawdownPercent, 1) + "%");
         return true;
      }
   }
   
   double totalProfitLoss = CalculateTotalProfit();
   
   if(totalProfitLoss <= -MaxTotalLoss && !NeverGiveUpMode)
   {
      Print("?? Max total loss reached: $" + DoubleToString(totalProfitLoss, 2));
      return false;
   }
   
   if(totalProfitLoss <= -SafetyStopThreshold && !NeverGiveUpMode)
   {
      Print("?? Safety stop threshold: $" + DoubleToString(totalProfitLoss, 2));
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| Open Step-Up Recovery                                           |
//+------------------------------------------------------------------+
void OpenStepUpRecovery()
{
   if(recoveryLayerCount >= localMaxSteps) 
   {
      Print("?? Maximum recovery steps reached: " + IntegerToString(recoveryLayerCount));
      recoveryStopped = true;
      return;
   }
   
   if(IsRecoveryCooldown()) 
   {
      DebugPrint(2, "Recovery in cooldown - waiting...");
      return;
   }
   
   double recoveryLot = CalculateDynamicRecoveryLot(recoveryLayerCount + 1);
   
   if(recoveryLot <= 0) 
   {
      Print("? Recovery lot calculation failed!");
      return;
   }
   
   if(!CheckMargin(recoveryLot)) 
   {
      Print("? Margin insufficient for recovery: " + DoubleToString(recoveryLot, 2));
      return;
   }
   
   ENUM_POSITION_TYPE mainType = GetMainPositionType();
   if(mainType == (ENUM_POSITION_TYPE)WRONG_VALUE_CONST)
   {
      Print("? No main position found");
      return;
   }
   
   trade.SetExpertMagicNumber(MAGIC_RECOVERY);
   bool success = false;
   string comment = "Recovery-" + IntegerToString(recoveryLayerCount + 1) + 
                    "-L" + DoubleToString(recoveryLot, 2);
   
   if(mainType == POSITION_TYPE_BUY) 
   {
      success = trade.Sell(recoveryLot, _Symbol, 0, 0, 0, comment);
   } 
   else if(mainType == POSITION_TYPE_SELL)
   {
      success = trade.Buy(recoveryLot, _Symbol, 0, 0, 0, comment);
   }
   
   if(success) 
   {
      recoveryLayerCount++;
      lastRecoveryTime = TimeCurrent();
      
      recoveryHistory[recoveryLayerCount-1].step = recoveryLayerCount;
      recoveryHistory[recoveryLayerCount-1].lot = recoveryLot;
      recoveryHistory[recoveryLayerCount-1].openTime = TimeCurrent();
      recoveryHistory[recoveryLayerCount-1].openEquity = accountInfo.Equity();
      recoveryHistory[recoveryLayerCount-1].isSuccessful = false;
      recoveryHistory[recoveryLayerCount-1].profitTarget = RecoveryTarget;
      
      Print("?? Recovery step " + IntegerToString(recoveryLayerCount) + 
            " opened! Lot: " + DoubleToString(recoveryLot, 2) +
            ", Equity: $" + DoubleToString(accountInfo.Equity(), 2));
      
      RecordRecoveryAction();
   } 
   else 
   {
      Print("? Failed to open recovery: " + IntegerToString(trade.ResultRetcode()));
      consecutiveLosses++;
      failedRecoveryCount++;
   }
}

//+------------------------------------------------------------------+
//| Calculate safe recovery lot                                     |
//+------------------------------------------------------------------+
double CalculateDynamicRecoveryLot(int stepNumber)
{
   double baseVolume = GetTotalMainPositionVolume();
   
   double dynamicMultiplier = 1.0;
   
   if(failedRecoveryCount == 0) {
      dynamicMultiplier = 1.0 + (stepNumber * 0.15);
      Print("?? Recovery: Aggressive mode, Multiplier: " + DoubleToString(dynamicMultiplier, 2));
   }
   else if(failedRecoveryCount == 1) {
      dynamicMultiplier = 1.0 + (stepNumber * 0.1);
      Print("?? Recovery: Conservative mode, Multiplier: " + DoubleToString(dynamicMultiplier, 2));
   }
   else {
      dynamicMultiplier = 1.0 + (stepNumber * 0.05);
      Print("?? Recovery: Super Conservative mode, Multiplier: " + DoubleToString(dynamicMultiplier, 2));
   }
   
   if(battlePhase >= 2) {
      dynamicMultiplier *= 1.2;
      Print("?? Recovery: Battle Phase " + IntegerToString(battlePhase) + " boost applied");
   }
   
   double recoveryLot = baseVolume * dynamicMultiplier;
   
   double maxSafeLot = baseVolume * 2.0;
   recoveryLot = MathMin(recoveryLot, maxSafeLot);
   recoveryLot = MathMin(recoveryLot, MaxRecoveryLot);
   recoveryLot = MathMax(recoveryLot, RecoveryStartLot);
   
   recoveryLot = NormalizeDouble(recoveryLot, 2);
   
   Print("?? Dynamic Lot Calculation: Step " + IntegerToString(stepNumber) + 
         ", Base: " + DoubleToString(baseVolume, 2) + 
         ", Multiplier: " + DoubleToString(dynamicMultiplier, 2) + 
         ", Result: " + DoubleToString(recoveryLot, 2));
   
   return recoveryLot;
}

//+------------------------------------------------------------------+
//| Check Recovery Cooldown                                        |
//+------------------------------------------------------------------+
bool IsRecoveryCooldown()
{
   if(failedRecoveryCount >= 2) {
      int cooldownMinutes = failedRecoveryCount * 30;
      if(TimeCurrent() - lastRecoveryTime < cooldownMinutes * 60) {
         int remaining = (int)(cooldownMinutes - (TimeCurrent() - lastRecoveryTime) / 60);
         DebugPrint(2, "Recovery cooldown active. " + IntegerToString(remaining) + " minutes remaining");
         return true;
      }
   }
   return false;
}

//+------------------------------------------------------------------+
//| Check Recovery Results                                         |
//+------------------------------------------------------------------+
void CheckRecoveryResults()
{
   if(recoveryLayerCount == 0) return;
   
   double currentEquity = accountInfo.Equity();
   
   if(!recoveryHistory[recoveryLayerCount-1].isSuccessful && 
      currentEquity > recoveryHistory[recoveryLayerCount-1].openEquity + recoveryHistory[recoveryLayerCount-1].profitTarget)
   {
      recoveryHistory[recoveryLayerCount-1].isSuccessful = true;
      successfulRecoveries++;
      totalRecoveryProfit += (currentEquity - recoveryHistory[recoveryLayerCount-1].openEquity);
      failedRecoveryCount = 0;
      
      Print("? Recovery Step " + IntegerToString(recoveryLayerCount) + " SUCCESS!" +
            " Profit: $" + DoubleToString(currentEquity - recoveryHistory[recoveryLayerCount-1].openEquity, 2) +
            ", Total Recovery Profit: $" + DoubleToString(totalRecoveryProfit, 2));
   }
   else if(!recoveryHistory[recoveryLayerCount-1].isSuccessful && 
           currentEquity < recoveryHistory[recoveryLayerCount-1].openEquity - (RecoveryTrigger * 2))
   {
      recoveryHistory[recoveryLayerCount-1].isSuccessful = false;
      failedRecoveryCount++;
      
      Print("? Recovery Step " + IntegerToString(recoveryLayerCount) + " FAILED!" +
            " Loss: $" + DoubleToString(recoveryHistory[recoveryLayerCount-1].openEquity - currentEquity, 2) +
            ", Failed Count: " + IntegerToString(failedRecoveryCount));
   }
}

//+------------------------------------------------------------------+
//| Get Recovery Performance Metrics                               |
//+------------------------------------------------------------------+
void GetRecoveryMetrics()
{
   if(recoveryLayerCount == 0) 
   {
      Print("?? No active recovery steps");
      return;
   }
   
   double successRate = (double)successfulRecoveries / recoveryLayerCount * 100;
   double avgProfitPerStep = totalRecoveryProfit / recoveryLayerCount;
   
   Print("=== RECOVERY METRICS ===");
   Print("Total Steps: " + IntegerToString(recoveryLayerCount));
   Print("Successful: " + IntegerToString(successfulRecoveries));
   Print("Failed: " + IntegerToString(failedRecoveryCount));
   Print("Success Rate: " + DoubleToString(successRate, 1) + "%");
   Print("Total Profit: $" + DoubleToString(totalRecoveryProfit, 2));
   Print("Avg Profit/Step: $" + DoubleToString(avgProfitPerStep, 2));
   Print("Current Step: " + IntegerToString(recoveryLayerCount));
}

//+------------------------------------------------------------------+
//| Auto-Recovery Parameter Adjustment                             |
//+------------------------------------------------------------------+
void AdjustRecoveryParameters()
{
   if(failedRecoveryCount >= 2)
   {
      Print("?? Auto-adjusting recovery parameters...");
      
      double adjustmentFactor = 1.0 - (failedRecoveryCount * 0.1);
      adjustmentFactor = MathMax(adjustmentFactor, 0.5);
      
      Print("?? Recovery lot size reduced by factor: " + DoubleToString(adjustmentFactor, 2));
   }
}
// ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Drawdown ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á (‡πÉ‡∏ä‡πâ Equity Peak)
double CalculateTrueDrawdownPercent()
{
    static double equityPeak = 0;
    static datetime lastPeakReset = 0;
    
    double currentEquity = AccountInfoDouble(ACCOUNT_EQUITY);
    double currentBalance = AccountInfoDouble(ACCOUNT_BALANCE);
    
    // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï Equity Peak ‡∏ó‡∏∏‡∏Å‡∏ß‡∏±‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏°‡∏∑‡πà‡∏≠ balance ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô (‡πÄ‡∏ä‡πà‡∏ô ‡∏ù‡∏≤‡∏Å/‡∏ñ‡∏≠‡∏ô)
    if(equityPeak == 0 || currentBalance != AccountInfoDouble(ACCOUNT_BALANCE) || 
       TimeCurrent() - lastPeakReset > 86400) // 86400 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ = 1 ‡∏ß‡∏±‡∏ô
    {
        equityPeak = currentEquity;
        lastPeakReset = TimeCurrent();
        Print("üîÑ Equity Peak Reset: $" + DoubleToString(equityPeak, 2));
    }
    
    // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó Equity Peak ‡∏ñ‡πâ‡∏≤ equity ‡∏™‡∏π‡∏á‡∏Ç‡∏∂‡πâ‡∏ô
    if(currentEquity > equityPeak)
    {
        equityPeak = currentEquity;
        Print("üìà New Equity Peak: $" + DoubleToString(equityPeak, 2));
    }
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Drawdown
    if(equityPeak <= 0) 
    {
        return 0; // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡∏£‡∏î‡πâ‡∏ß‡∏¢‡∏®‡∏π‡∏ô‡∏¢‡πå
    }
    
    double drawdownPercent = ((equityPeak - currentEquity) / equityPeak) * 100.0;
    drawdownPercent = MathMax(0, drawdownPercent); // ‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏Ñ‡πà‡∏≤‡∏ï‡∏¥‡∏î‡∏•‡∏ö
    
    return NormalizeDouble(drawdownPercent, 2);
}
// ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Safety Systems ‡∏´‡∏•‡∏±‡∏Å
void ManageSafetySystems()
{
    if(!UseRecoverySafety) 
    {
        // ‚úÖ ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏õ‡∏¥‡∏î UseRecoverySafety -> ‡πÑ‡∏°‡πà‡∏ó‡∏≥‡∏≠‡∏∞‡πÑ‡∏£‡πÄ‡∏•‡∏¢
        static datetime lastWarning = 0;
        if(TimeCurrent() - lastWarning > 300) // ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ó‡∏∏‡∏Å 5 ‡∏ô‡∏≤‡∏ó‡∏µ
        {
            double currentDrawdown = CalculateTrueDrawdownPercent();
            double totalProfit = CalculateTotalProfit();
            
            if(currentDrawdown > MaxDrawdownPercent) 
            {
                Print("‚ö†Ô∏è DRAWDOWN WARNING: " + DoubleToString(currentDrawdown, 1) + 
                      "% | UseRecoverySafety: OFF - No auto closure");
            }
            
            if(totalProfit <= -MaxTotalLoss)
            {
                Print("‚ö†Ô∏è LOSS WARNING: $" + DoubleToString(totalProfit, 2) + 
                      " | UseRecoverySafety: OFF - No auto closure");
            }
            lastWarning = TimeCurrent();
        }
        return; // ‚ùå ‡∏≠‡∏≠‡∏Å‡πÄ‡∏•‡∏¢‡∏ñ‡πâ‡∏≤ safety ‡∏õ‡∏¥‡∏î
    }

    // ‚úÖ ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏¥‡∏î UseRecoverySafety -> ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    double currentDrawdown = CalculateTrueDrawdownPercent();
    double totalProfit = CalculateTotalProfit();
    double currentEquity = AccountInfoDouble(ACCOUNT_EQUITY);
    
    // ‚úÖ ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç Safety Stop
    bool drawdownCondition = (currentDrawdown >= MaxDrawdownPercent);
    bool lossCondition = (totalProfit <= -MaxTotalLoss);
    bool safetyStopCondition = (totalProfit <= -SafetyStopThreshold);
    bool equityCondition = (currentEquity < MinEquityToTrade);
    
    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏¢‡∏∏‡∏î Recovery ‡∏´‡∏£‡∏∑‡∏≠‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    if(drawdownCondition || lossCondition || safetyStopCondition || equityCondition)
    {
        ExecuteSafetyActions(drawdownCondition, lossCondition, safetyStopCondition, equityCondition, currentDrawdown, totalProfit);
    }
    
    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Consecutive Losses
    CheckConsecutiveLosses();
    
    // ‚úÖ ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÉ‡∏Å‡∏•‡πâ‡∏ñ‡∏∂‡∏á‡∏Ç‡∏µ‡∏î‡∏à‡∏≥‡∏Å‡∏±‡∏î
    static datetime lastSafetyWarning = 0;
    if(TimeCurrent() - lastSafetyWarning > 60) // ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ó‡∏∏‡∏Å 1 ‡∏ô‡∏≤‡∏ó‡∏µ
    {
        if(currentDrawdown >= MaxDrawdownPercent * 0.8) // 80% ‡∏Ç‡∏≠‡∏á‡∏Ç‡∏µ‡∏î‡∏à‡∏≥‡∏Å‡∏±‡∏î
        {
            Print("‚ö†Ô∏è SAFETY WARNING: Drawdown " + DoubleToString(currentDrawdown, 1) + 
                  "% (Limit: " + DoubleToString(MaxDrawdownPercent, 1) + "%)");
        }
        
        if(totalProfit <= -MaxTotalLoss * 0.8) // 80% ‡∏Ç‡∏≠‡∏á‡∏Ç‡∏µ‡∏î‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô
        {
            Print("‚ö†Ô∏è SAFETY WARNING: Total Loss $" + DoubleToString(totalProfit, 2) + 
                  " (Limit: $" + DoubleToString(-MaxTotalLoss, 2) + ")");
        }
        lastSafetyWarning = TimeCurrent();
    }
}
//-----------//


// ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£ Safety Actions
void ExecuteSafetyActions(bool drawdownTrigger, bool lossTrigger, bool safetyStopTrigger, bool equityTrigger, double drawdown, double totalLoss)
{
    Print("üö® SAFETY SYSTEM ACTIVATED üö®");
    
    // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•
    string reason = "";
    if(drawdownTrigger) reason += "Drawdown " + DoubleToString(drawdown, 1) + "% > " + DoubleToString(MaxDrawdownPercent, 1) + "%";
    if(lossTrigger) reason += (reason != "" ? " | " : "") + "Total Loss $" + DoubleToString(totalLoss, 2);
    if(safetyStopTrigger) reason += (reason != "" ? " | " : "") + "Safety Stop $" + DoubleToString(totalLoss, 2);
    if(equityTrigger) reason += (reason != "" ? " | " : "") + "Equity < MinEquity";
    
    Print("?? Reason: " + reason);
    
    // ‚úÖ ‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÅ‡∏Ñ‡πà‡∏´‡∏¢‡∏∏‡∏î Recovery
    bool closeAllPositions = (drawdownTrigger || lossTrigger || equityTrigger);
    bool stopRecoveryOnly = (safetyStopTrigger && AutoStopRecovery);
    
    if(closeAllPositions)
    {
        Print("?? Closing ALL positions...");
        CloseAllPositionsSafety("ExecuteSafetyActions", "SAFETY SYSTEM-Close");
    }
    
    if(stopRecoveryOnly || closeAllPositions)
    {
        Print("?? Stopping recovery operations...");
        recoveryStopped = true;
        ResetRecoverySystem();
    }
    
    // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£
    Print("‚úÖ SAFETY ACTIONS COMPLETED");
    Print("üí° Close Positions: " + (closeAllPositions ? "YES" : "NO"));
    Print("üí° Stop Recovery: " + ((stopRecoveryOnly || closeAllPositions) ? "YES" : "NO"));
}

// ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÅ‡∏ö‡∏ö‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
void CloseAllPositionsSafety(string callerName = "Unknown", string reason = "Not Specified")
{

   // üö® ALERT: ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ú‡∏π‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å
    Alert("üõë CLOSE ALL POSITIONS ACTIVATED");
    Alert("üìû CALLED BY: " + callerName);
    Alert("üéØ REASON: " + reason);
    Alert("üíº POSITIONS: " + IntegerToString(PositionsTotal()));
    Alert("üí∞ EQUITY: $" + DoubleToString(AccountInfoDouble(ACCOUNT_EQUITY), 2));
    
    //----
    int closedCount = 0;
    int totalPositions = PositionsTotal();
    double totalClosedProfit = 0;
    
    
    for(int i = totalPositions-1; i >= 0; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            string symbol = PositionGetString(POSITION_SYMBOL);
            double profit = PositionGetDouble(POSITION_PROFIT);
            double volume = PositionGetDouble(POSITION_VOLUME);
            long magic = PositionGetInteger(POSITION_MAGIC);
            
            if(trade.PositionClose(ticket))
            {
                closedCount++;
                totalClosedProfit += profit;
                Print("? SAFETY CLOSE: #" + TicketToStr(ticket) + 
                      " | " + symbol + " | Magic " + IntegerToString(magic) + 
                      " | Lot " + DoubleToString(volume, 2) + 
                      " | P/L: $" + DoubleToString(profit, 2));
            }
        }
    }
    
    Print("‚úÖ SAFETY CLOSURE: Closed " + IntegerToString(closedCount) + 
          "/" + IntegerToString(totalPositions) + " positions");
    Print("üí∞ Total P/L from closure: $" + DoubleToString(totalClosedProfit, 2));
    
     // üö® ALERT: ‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•
    Alert("‚úÖ CLOSE ALL COMPLETED");
    Alert("üìä CLOSED: " + IntegerToString(closedCount) + "/" + IntegerToString(totalPositions));
    Alert("üí∞ TOTAL P/L: $" + DoubleToString(totalClosedProfit, 2));
    Alert("üë§ CALLED BY: " + callerName);
    Alert("üéØ REASON: " + reason);
    
}

// ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Consecutive Losses
void CheckConsecutiveLosses()
{

   if(!UseRecoverySafety || !AutoStopRecovery) 
    {
        return; // ‚ùå ‡πÑ‡∏°‡πà‡∏ó‡∏≥‡∏≠‡∏∞‡πÑ‡∏£‡∏ñ‡πâ‡∏≤ safety ‡∏õ‡∏¥‡∏î‡∏´‡∏£‡∏∑‡∏≠ AutoStopRecovery ‡∏õ‡∏¥‡∏î
    }
    
    static int currentLossStreak = 0;
    static double lastTotalProfit = 0;
    
    double totalProfit = CalculateTotalProfit();
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á (logic ‡πÅ‡∏ö‡∏ö‡∏á‡πà‡∏≤‡∏¢)
    if(totalProfit < lastTotalProfit)
    {
        // ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô
        currentLossStreak++;
        Print("üìâ Consecutive Loss Streak: " + IntegerToString(currentLossStreak) + 
              "/" + IntegerToString(MaxConsecutiveLosses));
        
        if(currentLossStreak >= MaxConsecutiveLosses && AutoStopRecovery)
        {
            Print("üõë MAX CONSECUTIVE LOSSES REACHED: " + IntegerToString(currentLossStreak));
            Print("?? Stopping recovery operations...");
            recoveryStopped = true;
            currentLossStreak = 0; // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏´‡∏¢‡∏∏‡∏î
        }
    }
    else if(totalProfit > lastTotalProfit)
    {
        // ‡∏Å‡∏≥‡πÑ‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô -> ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï streak
        if(currentLossStreak > 0)
        {
            Print("‚úÖ Consecutive losses reset - Profit improved");
            currentLossStreak = 0;
        }
    }
    
    lastTotalProfit = totalProfit;
}
//+------------------------------------------------------------------+
//| Recovery Emergency Stop                                        |
//+------------------------------------------------------------------+
void ExecuteSmartRecoveryWithMarketAwareness()
{
    // 1. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏†‡∏≤‡∏ß‡∏∞‡∏ï‡∏•‡∏≤‡∏î‡∏Å‡πà‡∏≠‡∏ô
    ENUM_MARKET_REGIME marketRegime = DetectMarketRegime(); // ‡πÉ‡∏ä‡πâ ENUM
    double recoveryPressure = CalculateRecoveryRiskPressure();
    
    // 2. ‡πÉ‡∏ä‡πâ Emergency Stop ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
    if(recoveryPressure >= 1.0) {
        EmergencyRecoveryStop(); // ‚úÖ ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
        return;
    }
    
    // 3. ‡∏õ‡∏£‡∏±‡∏ö Recovery ‡∏ï‡∏≤‡∏°‡∏™‡∏†‡∏≤‡∏ß‡∏∞‡∏ï‡∏•‡∏≤‡∏î
    switch(marketRegime) {
        case MARKET_REGIME_TRENDING_STRONG:
            // ‡∏ï‡∏•‡∏≤‡∏î‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏ä‡∏±‡∏î ‚Üí Recovery ‡πÅ Aggressive
            if(CanRecoverAggressively()) {
                ExecuteAggressiveRecovery();
            }
            break;
            
        case MARKET_REGIME_RANGING_CALM:
            // ‡∏ï‡∏•‡∏≤‡∏î‡πÄ‡∏á‡∏µ‡∏¢‡∏ö ‚Üí Recovery ‡πÅ‡∏ö‡∏ö Passive
            if(ShouldWaitForBetterConditions()) {
                EnablePassiveRecovery(true);
            }
            break;
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            // ‡πÇ‡∏≠‡∏Å‡∏≤‡∏™ Breakout ‚Üí Recovery ‡πÅ‡∏ö‡∏ö Opportunistic
            if(IsBreakoutLikely()) {
                ExecuteOpportunisticRecovery();
            }
            break;
            
        case MARKET_REGIME_RANGING_VOLATILE:
            // ‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô ‚Üí Recovery ‡πÅ‡∏ö‡∏ö‡∏£‡∏∞‡∏°‡∏±‡∏î‡∏£‡∏∞‡∏ß‡∏±‡∏á
            ExecuteCautiousRecovery();
            break;
            
        default: // MARKET_REGIME_NORMAL, MARKET_REGIME_TRENDING_WEAK
            ExecuteStandardRecovery();
    }
}
//---------------------------------//
bool CanRecoverAggressively()
{
    return (GetCurrentRecoveryStep() < localMaxSteps * 0.6) && 
           (CalculateTrueDrawdownPercent() < MaxDrawdownPercent * 0.8);
}

bool ShouldWaitForBetterConditions()
{
    return (GetCurrentRecoveryStep() < 2) && 
           (GetNetMomentum() < 5);
}

void ExecuteAggressiveRecovery()
{
    Print("   üí™ Executing Aggressive Recovery");
    currentRecoveryMultiplier = 1.8;
    currentMaxRecovery = 6;
}

void ExecuteOpportunisticRecovery()
{
    Print("   üéØ Executing Opportunistic Recovery");
    // ‡∏£‡∏≠‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏∞‡∏î‡∏µ‡πÜ ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢ Recovery
}

void ExecuteCautiousRecovery()
{
    Print("   üõ°Ô∏è Executing Cautious Recovery");
    currentRecoveryMultiplier = 1.2;
    currentMaxRecovery = 3;
}

void ExecuteStandardRecovery()
{
    Print("   üîÑ Executing Standard Recovery");
    // Recovery ‡πÅ‡∏ö‡∏ö‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô
}

// ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ safety systems
void PrintCompleteSafetyStatus()
{
    Print("=== COMPLETE SAFETY SYSTEMS STATUS ===");
    
    // ‚úÖ Configuration
    Print("--- CONFIGURATION ---");
    Print("UseRecoverySafety: " + (UseRecoverySafety ? "ENABLED üü¢" : "DISABLED üî¥"));
    Print("MaxDrawdownPercent: " + DoubleToString(MaxDrawdownPercent, 1) + "%");
    Print("MaxTotalLoss: $" + DoubleToString(MaxTotalLoss, 2));
    Print("MaxConsecutiveLosses: " + IntegerToString(MaxConsecutiveLosses));
    Print("AutoStopRecovery: " + (AutoStopRecovery ? "YES" : "NO"));
    Print("SafetyStopThreshold: $" + DoubleToString(SafetyStopThreshold, 2));
    Print("MinEquityToTrade: $" + DoubleToString(MinEquityToTrade, 2));
    
    // ‚úÖ Current Status
    Print("--- CURRENT STATUS ---");
    double currentDrawdown = CalculateTrueDrawdownPercent();
    double totalProfit = CalculateTotalProfit();
    double marginLevel = (AccountInfoDouble(ACCOUNT_EQUITY) / AccountInfoDouble(ACCOUNT_MARGIN)) * 100.0;
    double freeMargin = AccountInfoDouble(ACCOUNT_MARGIN_FREE);
    
    Print("Equity: $" + DoubleToString(AccountInfoDouble(ACCOUNT_EQUITY), 2));
    Print("Balance: $" + DoubleToString(AccountInfoDouble(ACCOUNT_BALANCE), 2));
    Print("Drawdown: " + DoubleToString(currentDrawdown, 1) + "%");
    Print("Total P/L: $" + DoubleToString(totalProfit, 2));
    Print("Margin Level: " + DoubleToString(marginLevel, 1) + "%");
    Print("Free Margin: $" + DoubleToString(freeMargin, 2));
    Print("Active Positions: " + IntegerToString(PositionsTotal()));
    Print("Recovery Stopped: " + (recoveryStopped ? "YES" : "NO"));
    
    // ‚úÖ Safety Conditions Status
    Print("--- SAFETY CONDITIONS ---");
    Print("Drawdown Limit: " + DoubleToString(currentDrawdown, 1) + "% / " + 
          DoubleToString(MaxDrawdownPercent, 1) + "% - " + 
          (currentDrawdown >= MaxDrawdownPercent ? "EXCEEDED üî¥" : "OK üü¢"));
    
    Print("Total Loss: $" + DoubleToString(totalProfit, 2) + " / $" + 
          DoubleToString(-MaxTotalLoss, 2) + " - " + 
          (totalProfit <= -MaxTotalLoss ? "EXCEEDED üî¥" : "OK üü¢"));
    
    Print("Safety Stop: $" + DoubleToString(totalProfit, 2) + " / $" + 
          DoubleToString(-SafetyStopThreshold, 2) + " - " + 
          (totalProfit <= -SafetyStopThreshold ? "EXCEEDED üî¥" : "OK üü¢"));
    
    Print("Margin Level: " + DoubleToString(marginLevel, 1) + "% - " + 
          (marginLevel < 100.0 ? "CRITICAL üî¥" : "OK üü¢"));
    
    // ‚úÖ System Status
    Print("--- SYSTEM STATUS ---");
    if(!UseRecoverySafety)
    {
        Print("üö´ ALL SAFETY SYSTEMS: DISABLED");
        Print("üí° No automatic position closure will occur");
        Print("üí° Manual trading only - System shows warnings only");
    }
    else
    {
        Print("üõ°Ô∏è RECOVERY SAFETY: FULLY OPERATIONAL");
        if(AutoStopRecovery)
        {
            Print("üí° Auto Stop Recovery: ENABLED");
        }
        Print("üí° Will close positions if:");
        Print("   ‚Ä¢ Drawdown exceeds " + DoubleToString(MaxDrawdownPercent, 1) + "%");
        Print("   ‚Ä¢ Total loss exceeds $" + DoubleToString(MaxTotalLoss, 2));
        Print("   ‚Ä¢ Margin level below 100%");
    }
}
void CheckAndPrintSafetyStatus()
{
    static datetime lastPrint = 0;
    if(TimeCurrent() - lastPrint > 600) // ‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ó‡∏∏‡∏Å 10 ‡∏ô‡∏≤‡∏ó‡∏µ
    {
        PrintCompleteSafetyStatus();
        lastPrint = TimeCurrent();
    }
}
double CalculateVolatility(int period = 14)
{
    // Simple ATR-based volatility
    int atrHandle = iATR(Symbol(), PERIOD_CURRENT, period);
    if(atrHandle == INVALID_HANDLE)
    {
        Print("Failed to create ATR indicator");
        return 0;
    }
    
    double atrValue[1];
    if(CopyBuffer(atrHandle, 0, 0, 1, atrValue) < 1)
    {
        IndicatorRelease(atrHandle);
        return 0;
    }
    
    IndicatorRelease(atrHandle);
    double currentPrice = SymbolInfoDouble(Symbol(), SYMBOL_BID);
    
    // Return as percentage
    return (atrValue[0] / currentPrice) * 100; // Convert to percentage
}
// ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ä‡∏∑‡πà‡∏≠
string DetectMarketRegimeForRecovery()
{
    // ‡πÇ‡∏Ñ‡πâ‡∏î‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Recovery
    double volatility = CalculateVolatility();
    double trendStrength = CalculateTrendStrength();
    
    if(volatility < 0.5 && trendStrength < 20) {
        return "RANGING_CALM";
    } else if(volatility > 1.5 && trendStrength > 60) {
        return "TRENDING_STRONG";
    } else {
        return "NORMAL";
    }
}


//+------------------------------------------------------------------+
//| Enhanced Recovery Health Check                                 |
//+------------------------------------------------------------------+
bool IsRecoveryHealthy()
{
   if(UltimateFightingMode) return true; // Always healthy in ultimate mode
   
   if(recoveryLayerCount == 0) return true;
   
   double currentEquity = accountInfo.Equity();
   double initialEquity = recoveryHistory[0].openEquity;
   double equityDrop = (initialEquity - currentEquity) / initialEquity * 100;
   
   if(equityDrop > 50)
   {
      Print("? Recovery health check FAILED - Large equity drop: " + DoubleToString(equityDrop, 1) + "%");
      return false;
   }
   
   if(failedRecoveryCount >= 2 && recoveryLayerCount <= 3)
   {
      Print("? Recovery health check FAILED - Too many early failures");
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| Get Fighting Status for Dashboard                              |
//+------------------------------------------------------------------+
string GetFightingStatus()
{
   if(UltimateFightingMode)
   {
      if(currentFightingPhase > 0)
      {
         return "ULTIMATE PHASE " + IntegerToString(currentFightingPhase) + 
                " | Aggression: " + DoubleToString(GetPhaseAggression(currentFightingPhase), 1);
      }
      return "ULTIMATE MODE READY";
   }
   else if(isInBattleMode)
   {
      return "BATTLE PHASE " + IntegerToString(battlePhase);
   }
   return "NORMAL";
}

//+------------------------------------------------------------------+
//| Record recovery action                                          |
//+------------------------------------------------------------------+
void RecordRecoveryAction()
{
   double currentProfit = CalculateTotalProfit();
   
   if(currentProfit < maxTotalLoss) 
   {
      maxTotalLoss = currentProfit;
   }
   
   if(currentProfit < 0) 
   {
      consecutiveLosses++;
   } 
   else 
   {
      consecutiveLosses = 0;
   }
}

//+------------------------------------------------------------------+
//| Enhanced Reset Recovery System - FIXED VERSION                |
//+------------------------------------------------------------------+
void ResetRecoverySystem()
{
   recoveryLayerCount = 0;
   consecutiveLosses = 0;
   recoveryStopped = false;
   failedRecoveryCount = 0;
   totalRecoveryProfit = 0;
   successfulRecoveries = 0;
   
   ClearRecoveryHistory();
   
   Print("?? Enhanced Recovery system reset complete");
   Print("?? Final Summary - Successful: " + IntegerToString(successfulRecoveries) + 
         ", Total Profit: $" + DoubleToString(totalRecoveryProfit, 2));
}

//+------------------------------------------------------------------+
//| Manual recovery reset                                           |
//+------------------------------------------------------------------+
void ManualRecoveryReset()
{
   if(PositionsTotal() == 0) 
   {
      ResetRecoverySystem();
      Print("?? Manual Recovery Reset completed");
   } 
   else 
   {
      Print("? Cannot reset while positions are open");
   }
}

//+------------------------------------------------------------------+
//| Close Recovery Positions Only - FIXED VERSION                  |
//+------------------------------------------------------------------+
void CloseRecoveryPositionsOnly()
{
   int closed = 0;
   double totalProfit = 0;
   
   for(int i = PositionsTotal()-1; i >= 0; i--) 
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket)) 
      {
         if(PositionGetInteger(POSITION_MAGIC) == MAGIC_RECOVERY) 
         {
            double profit = PositionGetDouble(POSITION_PROFIT);
            if(trade.PositionClose(ticket)) 
            {
               closed++;
               totalProfit += profit;
            }
         }
      }
   }
   Print("? Closed " + IntegerToString(closed) + " recovery positions, Profit: $" + DoubleToString(totalProfit, 2));
}

//+------------------------------------------------------------------+
//| Clear Recovery History - FIXED VERSION                         |
//+------------------------------------------------------------------+
void ClearRecoveryHistory()
{
   for(int i = 0; i < 100; i++) 
   {
      recoveryHistory[i].step = 0;
      recoveryHistory[i].lot = 0;
      recoveryHistory[i].openTime = 0;
      recoveryHistory[i].openEquity = 0;
      recoveryHistory[i].isSuccessful = false;
      recoveryHistory[i].profitTarget = 0;
   }
}

//+------------------------------------------------------------------+
//| Check and close all positions if target reached                 |
//+------------------------------------------------------------------+
void CheckAndCloseAllPositions()
{
   double totalProfit = CalculateTotalProfit();
   double recoveryProfit = CalculateRecoveryPositionsProfit();
   
   // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Å‡∏≥‡πÑ‡∏£‡∏£‡∏ß‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏ö‡∏ß‡∏Å‡∏Å‡πà‡∏≠‡∏ô‡∏õ‡∏¥‡∏î‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
   if(totalProfit >= RecoveryTarget && totalProfit > 0) 
   {
      Print("üéØ PORTFOLIO TARGET HIT - Closing ALL positions!");
      Print("üí∞ Total Portfolio Profit: $" + DoubleToString(totalProfit, 2));
      
      CloseAllPortfolioPositions("CheckAndCloseAllPositions", "Recovery System - totalProfit >= RecoveryTarget");
      PrintRecoverySummary();
      ResetRecoverySystem();
      return;
   }
   
   // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≥‡πÑ‡∏£‡∏Ç‡∏≠‡∏á recovery positions ‡πÄ‡∏õ‡πá‡∏ô‡∏ö‡∏ß‡∏Å‡∏Å‡πà‡∏≠‡∏ô‡∏õ‡∏¥‡∏î
   if(recoveryProfit >= RecoveryTarget * 0.6 && recoveryLayerCount >= 2 && recoveryProfit > 0) {
      Print("‚úÖ RECOVERY PROFIT TARGET - Closing recovery positions");
      Print("üí∞ Recovery Profit: $" + DoubleToString(recoveryProfit, 2));
      
      CloseRecoveryPositionsOnly();
      recoveryLayerCount = 0;
      
      ResetRecoverySystem();
   }
   
   // ‚úÖ ‡∏õ‡∏¥‡∏î‡∏ó‡∏µ‡πà‡∏à‡∏∏‡∏î‡∏Ñ‡∏∏‡πâ‡∏°‡∏ó‡∏∏‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏≥‡πÑ‡∏£‡∏£‡∏ß‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏ö‡∏ß‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏®‡∏π‡∏ô‡∏¢‡πå
   if(totalProfit >= 0 && recoveryLayerCount >= 2) {
      Print("‚öñÔ∏è PORTFOLIO BREAK-EVEN - Closing all positions");
      CloseAllPortfolioPositions("CheckAndCloseAllPositions", "PORTFOLIO BREAK-EVEN - Closing all positions");
      PrintRecoverySummary();
      ResetRecoverySystem();
   }
   
   // ‚úÖ ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡πÉ‡∏ô‡∏Å‡∏£‡∏ì‡∏µ‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢
   if(recoveryLayerCount >= 3 && totalProfit < -RecoveryTarget * 0.5)
   {
      double newTarget = MathAbs(totalProfit) * 1.2; 
      Print("üéØ AUTO-TARGET ADJUST: New target: $" + DoubleToString(newTarget, 2));
      
      // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Å‡∏≥‡πÑ‡∏£‡πÄ‡∏õ‡πá‡∏ô‡∏ö‡∏ß‡∏Å‡∏Å‡πà‡∏≠‡∏ô‡∏õ‡∏¥‡∏î
      if(totalProfit >= 0) 
      {
         Print("‚úÖ ADJUSTED TARGET HIT - Closing all portfolio positions");
         CloseAllPortfolioPositions("CheckAndCloseAllPositions", "totalProfit >= -newTarget");
         ResetRecoverySystem();
      }
   }
   
   // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô
   if(totalProfit < 0) {
      Print("‚è∏Ô∏è Portfolio is in loss. Waiting for profit before closing positions.");
      Print("üìâ Current Loss: $" + DoubleToString(totalProfit, 2));
      return;
   }
}
// ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Ultimate Fighting Mode
void CheckUltimateFightingMode()
{
   if(!UltimateFightingMode) return;
   
   double currentEquity = AccountInfoDouble(ACCOUNT_EQUITY);
   double currentBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   if(currentBalance <= 0) return;
   
   double drawdownPercent = (currentBalance - currentEquity) / currentBalance * 100.0;
   
   // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô Phase ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå
   int newPhase = 0;
   if(drawdownPercent >= Phase5Trigger) newPhase = 5;
   else if(drawdownPercent >= Phase4Trigger) newPhase = 4;
   else if(drawdownPercent >= Phase3Trigger) newPhase = 3;
   else if(drawdownPercent >= Phase2Trigger) newPhase = 2;
   else if(drawdownPercent >= Phase1Trigger) newPhase = 1;
   
   if(newPhase > currentFightingPhase)
   {
      currentFightingPhase = newPhase;
      phaseStartEquity = currentEquity;
      phaseStartTime = TimeCurrent();
      fightingTradesCount = 0;
      
      Print("üî• ULTIMATE FIGHTING PHASE " + IntegerToString(currentFightingPhase) + " ACTIVATED!");
      Print("üìâ Drawdown: " + DoubleToString(drawdownPercent, 1) + "% | Equity: $" + DoubleToString(currentEquity, 2));
      Print("üí™ Aggression Level: " + DoubleToString(GetPhaseAggression(currentFightingPhase), 1));
      
      // ‚úÖ ‡πÑ‡∏°‡πà‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà ‡πÅ‡∏ï‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£ Recovery
      ExecuteEnhancedRecoveryInFightingMode();
   }
   
   // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏∑‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞ Phase
   CheckFightingPhaseProgress();
}
// ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Recovery ‡πÉ‡∏ô‡πÇ‡∏´‡∏°‡∏î Fighting (‡πÑ‡∏°‡πà‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå)
void ExecuteEnhancedRecoveryInFightingMode()
{
   if(currentFightingPhase == 0) return;
   
   double totalLoss = CalculateTotalPortfolioLoss();
   double aggression = GetPhaseAggression(currentFightingPhase);
   
   // ‚úÖ ‡πÄ‡∏õ‡∏¥‡∏î Recovery ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå
   if(totalLoss <= -(RecoveryTrigger * aggression) && recoveryLayerCount < localMaxSteps)
   {
      Print("üîÑ ENHANCED RECOVERY IN FIGHTING MODE | Phase: " + IntegerToString(currentFightingPhase));
      OpenUltimateRecovery(aggression);
   }
}
// ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏∑‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞ Phase
void CheckFightingPhaseProgress()
{
   if(currentFightingPhase == 0) return;
   
   double currentEquity = AccountInfoDouble(ACCOUNT_EQUITY);
   double phaseProgress = (currentEquity - phaseStartEquity) / MathAbs(phaseStartEquity) * 100.0;
   
   // ‚úÖ ‡∏ñ‡πâ‡∏≤‡∏ü‡∏∑‡πâ‡∏ô‡∏ï‡∏±‡∏ß‡πÑ‡∏î‡πâ‡∏î‡∏µ‡πÉ‡∏ô Phase ‡∏ô‡∏µ‡πâ
   if(phaseProgress >= 15.0)
   {
      Print("üéâ PHASE " + IntegerToString(currentFightingPhase) + " RECOVERY PROGRESS: " + DoubleToString(phaseProgress, 1) + "%");
      // ‚úÖ ‡πÑ‡∏°‡πà‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ ‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏ñ‡∏∂‡∏á‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏à‡∏£‡∏¥‡∏á
   }
   
   // ‚úÖ ‡∏ñ‡πâ‡∏≤‡∏ü‡∏∑‡πâ‡∏ô‡∏ï‡∏±‡∏ß‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡πÑ‡∏î‡πâ‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 50% ‡∏Ç‡∏≠‡∏á Phase Start
   if(phaseProgress >= 50.0)
   {
      Print("üöÄ EXCELLENT RECOVERY IN PHASE " + IntegerToString(currentFightingPhase) + "!");
      // ‚úÖ ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏î aggression ‡πÑ‡∏î‡πâ ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå
      currentFightingPhase = MathMax(1, currentFightingPhase - 1);
      Print("üìâ Downgrading to Phase " + IntegerToString(currentFightingPhase) + " due to excellent recovery");
   }
}
// ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ï‡∏±‡πâ‡∏á‡πÉ‡∏à
void SafeCloseAllPositions(string callerName, string reason)
{
   double totalProfit = CalculateTotalProfit();
   
   // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏Å‡πà‡∏≠‡∏ô‡∏õ‡∏¥‡∏î
   if(totalProfit < 0)
   {
      Print("üö´ SAFETY BLOCK: Attempt to close positions while in loss prevented!");
      Print("üí° Caller: " + callerName + " | Reason: " + reason);
      Print("üìâ Current Loss: $" + DoubleToString(totalProfit, 2));
      return;
   }
   
   // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Å‡∏≥‡πÑ‡∏£‡∏ñ‡∏∂‡∏á‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥
   double minProfitThreshold = RecoveryTarget * 0.8; // 80% ‡∏Ç‡∏≠‡∏á target
   if(totalProfit < minProfitThreshold)
   {
      Print("‚ö†Ô∏è PROFIT TOO LOW: $" + DoubleToString(totalProfit, 2) + " < $" + DoubleToString(minProfitThreshold, 2));
      Print("üí° Required minimum profit not reached for closure");
      return;
   }
   
   // ‚úÖ ‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
   CloseAllPortfolioPositions(callerName + "_Safe", reason + " | Safe Closure");
}

//+------------------------------------------------------------------+
//| Close All Positions with Caller Info                           |
//+------------------------------------------------------------------+
void CloseAllPositions(string callerName = "Unknown", string reason = "Not Specified")
{
    // üö® ALERT: ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ú‡∏π‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å
    Alert("üõë CLOSE ALL POSITIONS ACTIVATED");
    Alert("üìû CALLED BY: " + callerName);
    Alert("üéØ REASON: " + reason);
    Alert("üíº POSITIONS: " + IntegerToString(PositionsTotal()));
    Alert("üí∞ EQUITY: $" + DoubleToString(AccountInfoDouble(ACCOUNT_EQUITY), 2));

    // ... ‡πÇ‡∏Ñ‡πâ‡∏î‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    int closedCount = 0;
    int total = PositionsTotal();
    double totalClosedProfit = 0;
    
    for(int i = total-1; i >= 0; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            double profit = PositionGetDouble(POSITION_PROFIT);
            string symbol = PositionGetString(POSITION_SYMBOL);
            
            if(trade.PositionClose(ticket))
            {
                closedCount++;
                totalClosedProfit += profit;
                Print("üîª CLOSED by " + callerName + ": " + symbol + " | P/L: $" + DoubleToString(profit, 2));
            }
        }
    }
    
    // üö® ALERT: ‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•
    Alert("‚úÖ CLOSE ALL COMPLETED");
    Alert("üìä CLOSED: " + IntegerToString(closedCount) + "/" + IntegerToString(total));
    Alert("üí∞ TOTAL P/L: $" + DoubleToString(totalClosedProfit, 2));
    Alert("üë§ CALLED BY: " + callerName);
    Alert("üéØ REASON: " + reason);
}

//+------------------------------------------------------------------+
//| Get main position type                                          |
//+------------------------------------------------------------------+
ENUM_POSITION_TYPE GetMainPositionType()
{
   for(int i = 0; i < PositionsTotal(); i++) {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket)) {
         long magic = PositionGetInteger(POSITION_MAGIC);
         if(magic != MAGIC_RECOVERY && magic != MAGIC_HEDGE && magic != MAGIC_COUNTER) {
            return (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
         }
      }
   }
   return (ENUM_POSITION_TYPE)WRONG_VALUE_CONST;
}

//+------------------------------------------------------------------+
//| Calculate main positions loss                                   |
//+------------------------------------------------------------------+
double CalculateMainPositionsLoss()
{
   double loss = 0;
   for(int i = 0; i < PositionsTotal(); i++) {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket)) {
         long magic = PositionGetInteger(POSITION_MAGIC);
         if(magic != MAGIC_RECOVERY && magic != MAGIC_HEDGE && magic != MAGIC_COUNTER) {
            loss += PositionGetDouble(POSITION_PROFIT);
         }
      }
   }
   return loss;
}

//+------------------------------------------------------------------+
//| Count main positions                                            |
//+------------------------------------------------------------------+
int CountMainPositions()
{
   int count = 0;
   for(int i = 0; i < PositionsTotal(); i++) {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket)) {
         long magic = PositionGetInteger(POSITION_MAGIC);
         if(magic != MAGIC_RECOVERY && magic != MAGIC_HEDGE && magic != MAGIC_COUNTER) {
            count++;
         }
      }
   }
   return count;
}

//+------------------------------------------------------------------+
//| Scalp1 High-Frequency - ?????????????                         |
//+------------------------------------------------------------------+
void ExecuteScalp1HighFrequency()
{
   if(!Scalp1AdvanceEnabled) 
   {
      DebugPrint(3, "Scalp1 High-Frequency disabled - skipping");
      return;
   }
   
  
   if(CountPositionsByMagic(MAGIC_SCALP1_HF) >= Scalp1_MaxPositions1) 
   {
      DebugPrint(3, "Max Scalp1 High-Frequency positions reached (" + IntegerToString(Scalp1_MaxPositions1) + ")");
      return;
   }

   DebugPrint(3, "Scalp1 High-Frequency Mode - Quick Analysis");
   
  
   MqlRates current_rates[];
   if(CopyRates(_Symbol, PERIOD_M1, 0, 2, current_rates) != 2) return;
   
   double ema5 = iMA(_Symbol, PERIOD_M1, 5, 0, MODE_EMA, PRICE_CLOSE);
   double ema10 = iMA(_Symbol, PERIOD_M1, 10, 0, MODE_EMA, PRICE_CLOSE);
   double current_rsi = iRSI(_Symbol, PERIOD_M1, 7, PRICE_CLOSE); // RSI ?????
   
   double current_price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) * _Point;
   
   
   bool quick_buy = (current_price > ema5 && 
                    current_rates[0].close > current_rates[0].open &&
                    current_rsi > 45 && current_rsi < 75);
   
   bool quick_sell = (current_price < ema5 && 
                     current_rates[0].close < current_rates[0].open &&
                     current_rsi < 55 && current_rsi > 25);

   DebugPrint(3, "Quick Signals - Buy: " + (quick_buy ? "YES" : "NO") + 
                ", Sell: " + (quick_sell ? "YES" : "NO"));

   if(!quick_buy && !quick_sell) 
   {
      DebugPrint(3, "No quick scalp signal");
      return;
   }

   // ???????????????????????
   double scalp_lot = CalculateScalpLot();
   
   if(!CheckMargin(scalp_lot)) 
   {
      DebugPrint(1, "Insufficient margin for Scalp1 High-Frequency: " + DoubleToString(scalp_lot, 2));
      return;
   }

   trade.SetExpertMagicNumber(MAGIC_SCALP1);
   
   if(quick_buy)
   {
      double tp_price = GetTPPriceUniversal(true, Scalp1_Quick_TP); // ??? Scalp1_Quick_TP
      double sl_price = GetSLPriceUniversal(true, Scalp1_Quick_SL); // ??? Scalp1_Quick_SL
      
      if(trade.Buy(scalp_lot, _Symbol, sl_price, 0, tp_price, "Scalp1-Quick-Buy"))
      {
         ulong ticket = trade.ResultOrder();
         Print("? SCALP1 HIGH-FREQUENCY BUY | Ticket: #" + TicketToStr(ticket) + 
               " | Lot: " + DoubleToString(scalp_lot, 2) + 
               " | TP: " + IntegerToString(Scalp1_Quick_TP) + "pips | SL: " + IntegerToString(Scalp1_Quick_SL) + "pips");
      }
   }
   else if(quick_sell)
   {
      double tp_price = GetTPPriceUniversal(false, Scalp1_Quick_TP); // ??? Scalp1_Quick_TP
      double sl_price = GetSLPriceUniversal(false, Scalp1_Quick_SL); // ??? Scalp1_Quick_SL
      
      if(trade.Sell(scalp_lot, _Symbol, sl_price, 0, tp_price, "Scalp1-Quick-Sell"))
      {
         ulong ticket = trade.ResultOrder();
         Print("? SCALP1 HIGH-FREQUENCY SELL | Ticket: #" + TicketToStr(ticket) + 
               " | Lot: " + DoubleToString(scalp_lot, 2) + 
               " | TP: " + IntegerToString(Scalp1_Quick_TP) + "pips | SL: " + IntegerToString(Scalp1_Quick_SL) + "pips");
      }
   }
}
// ===== ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå =====
ENUM_TREND_DIRECTION AnalyzeMultiTimeframeTrend()
{
    int bullishCount = 0;
    int bearishCount = 0;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏´‡∏•‡∏≤‡∏¢ timeframe
    ENUM_TIMEFRAMES timeframes[] = {PERIOD_M1, PERIOD_M5, PERIOD_M15};
    
    for(int i = 0; i < ArraySize(timeframes); i++)
    {
        ENUM_TREND_DIRECTION tfTrend = AnalyzeTrendOnTimeframe(timeframes[i]);
        if(tfTrend == TREND_UP) bullishCount++;
        else if(tfTrend == TREND_DOWN) bearishCount++;
    }
    
    // ‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏´‡∏•‡∏±‡∏Å
    if(bullishCount >= 2) return TREND_UP;
    if(bearishCount >= 2) return TREND_DOWN;
    return TREND_SIDEWAYS;
}
void AdaptToMarketRegime()
{
    ENUM_MARKET_REGIME regime = DetectMarketRegime(); // ‡πÉ‡∏ä‡πâ ENUM
    
    switch(regime) {
        case MARKET_REGIME_RANGING_CALM:
            ExecuteRangingCalmPlan();      // ‡∏•‡∏î‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏° ‡∏£‡∏≠‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì
            break;
        case MARKET_REGIME_TRENDING_STRONG:
            ExecuteTrendingStrongPlan();   // ‡∏•‡∏á‡∏ó‡∏∏‡∏ô‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏µ‡πà‡∏ï‡∏≤‡∏°‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå
            break;
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            ExecuteBreakoutPotentialPlan(); // ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏à‡∏±‡∏ö Breakout
            break;
        case MARKET_REGIME_RANGING_VOLATILE:
            ExecuteRangingVolatilePlan();  // ‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
            break;
        case MARKET_REGIME_TRENDING_WEAK:
            ExecuteTrendingWeakPlan();     // ‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏≠‡πà‡∏≠‡∏ô
            break;
        default: // MARKET_REGIME_NORMAL
            ExecuteNormalPlan();           // ‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏õ‡∏Å‡∏ï‡∏¥
    }
}

void ExecuteNormalPlan()
{
    Print("üìä EXECUTING NORMAL PLAN - Market Adaptive Strategy");
    
    // 1. ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô
    Current_TrendScalp_TP_Points = Original_Trend_TP;
    Current_Scalp1_Lot_Multiplier = Original_Scalp1_Multiplier;
    
    // 2. ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡πÇ‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡∏±‡∏°‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
    double netMomentum = GetNetMomentum();
    if(netMomentum > 5) {
        // ‡πÇ‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡∏±‡∏°‡∏ö‡∏ß‡∏Å‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢ ‚Üí ‡πÄ‡∏ô‡πâ‡∏ô Buy ‡∏ô‡∏¥‡∏î‡∏´‡∏ô‡πà‡∏≠‡∏¢
        AssignTeamWeights(35, 20, 25, 12, 8);
        Print("   üü¢ Slightly favoring BUY teams");
    } else if(netMomentum < -5) {
        // ‡πÇ‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡∏±‡∏°‡∏•‡∏ö‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢ ‚Üí ‡πÄ‡∏ô‡πâ‡∏ô Sell ‡∏ô‡∏¥‡∏î‡∏´‡∏ô‡πà‡∏≠‡∏¢
        AssignTeamWeights(20, 35, 25, 12, 8);
        Print("   üî¥ Slightly favoring SELL teams");
    } else {
        // ‡πÇ‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡∏±‡∏°‡∏™‡∏°‡∏î‡∏∏‡∏• ‚Üí ‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡πÄ‡∏ó‡πà‡∏≤‡πÜ ‡∏Å‡∏±‡∏ô
        AssignTeamWeights(30, 25, 20, 15, 10);
        Print("   ‚öñÔ∏è Balanced team distribution");
    }
    
    // 3. ‡πÉ‡∏ä‡πâ recovery settings ‡∏õ‡∏Å‡∏ï‡∏¥
    ResetRecoveryModes(); // ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÄ‡∏õ‡πá‡∏ô‡∏õ‡∏Å‡∏ï‡∏¥
    
    Print("   üìà Standard trading parameters activated");
}

void ResetRecoveryModes()
{
    currentRecoveryMultiplier = localRecoveryMultiplier;
    currentMaxRecovery = localMaxRecovery;
    currentEnableCounterPosition = EnableCounterPosition; // ‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å input
}

void ExecuteRangingVolatilePlan()
{
    Print("üé≠ EXECUTING RANGING VOLATILE PLAN");
    
    // 1. ‡πÄ‡∏ô‡πâ‡∏ô‡∏ó‡∏µ‡∏° Scalp ‡πÅ‡∏•‡∏∞ Counter
    Current_Scalp1_Lot_Multiplier = Original_Scalp1_Multiplier * 1.2; // +20%
    
    // 2. ‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡∏ó‡∏µ‡∏°‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏ù‡∏±‡πà‡∏á
    AssignTeamWeights(15, 15, 40, 20, 10); // Scalp 70%
    
    // 3. ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Counter Team ‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏µ‡πà
    EnableCounterPositionMode(true);
    
    // 4. Recovery ‡πÅ‡∏ö‡∏ö‡∏£‡∏ß‡∏î‡πÄ‡∏£‡πá‡∏ß
    EnableQuickRecovery(true);
    
    Print("   ‚ö° Quick scalp & counter strategies activated");
}

ENUM_MARKET_REGIME DetectMarketRegime() 
{
    // 1. ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤ ATR
    double atrArray[1];
    int atrHandle = iATR(_Symbol, _Period, 14);
    if(CopyBuffer(atrHandle, 0, 0, 1, atrArray) < 1) 
    {
        IndicatorRelease(atrHandle);
        return MARKET_REGIME_NORMAL;
    }
    double atr = atrArray[0];
    IndicatorRelease(atrHandle);
    
    // 2. ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤ ADX, +DI, -DI
    double adxArray[1], plusDIArray[1], minusDIArray[1];
    int adxHandle = iADX(_Symbol, _Period, 14);
    
    if(CopyBuffer(adxHandle, 0, 0, 1, adxArray) < 1 ||
       CopyBuffer(adxHandle, 1, 0, 1, plusDIArray) < 1 ||
       CopyBuffer(adxHandle, 2, 0, 1, minusDIArray) < 1)
    {
        IndicatorRelease(adxHandle);
        return MARKET_REGIME_NORMAL;
    }
    
    double adx = adxArray[0];
    double plusDI = plusDIArray[0];
    double minusDI = minusDIArray[0];
    IndicatorRelease(adxHandle);
    
    // 3. ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤ EMA50 ‡πÅ‡∏•‡∏∞ EMA200
    double ema50Array[1], ema200Array[1];
    int ema50Handle = iMA(_Symbol, _Period, 50, 0, MODE_EMA, PRICE_CLOSE);
    int ema200Handle = iMA(_Symbol, _Period, 200, 0, MODE_EMA, PRICE_CLOSE);
    
    if(CopyBuffer(ema50Handle, 0, 0, 1, ema50Array) < 1)
    {
        IndicatorRelease(ema50Handle);
        IndicatorRelease(ema200Handle);
        return MARKET_REGIME_NORMAL;
    }
    
    if(CopyBuffer(ema200Handle, 0, 0, 1, ema200Array) < 1)
    {
        IndicatorRelease(ema50Handle);
        IndicatorRelease(ema200Handle);
        return MARKET_REGIME_NORMAL;
    }
    
    double ema50 = ema50Array[0];
    double ema200 = ema200Array[0];
    
    IndicatorRelease(ema50Handle);
    IndicatorRelease(ema200Handle);
    
    // 4. ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
    double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    // 5. ‡∏Ñ‡πà‡∏≤ ATR ‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢ (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö)
    static double atrBuffer[];
    static int atrBufferSize = 100;
    static bool bufferInitialized = false;
    
    // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ç‡∏ô‡∏≤‡∏î buffer ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å
    if(!bufferInitialized)
    {
        ArrayResize(atrBuffer, atrBufferSize);
        ArrayInitialize(atrBuffer, atr); // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡∏Ñ‡πà‡∏≤ ATR ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
        bufferInitialized = true;
    }
    
    // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤ ATR ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î (shift array)
    for(int i = atrBufferSize - 1; i > 0; i--) 
    {
        atrBuffer[i] = atrBuffer[i - 1];
    }
    atrBuffer[0] = atr;
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì ATR ‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢
    double atrAvg = 0;
    for(int i = 0; i < atrBufferSize; i++) 
    {
        atrAvg += atrBuffer[i];
    }
    atrAvg /= atrBufferSize;
    
    // 6. ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î
    if(atr > atrAvg * 1.5) 
    {
        // ‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô‡∏™‡∏π‡∏á
        if(adx > 25) 
        {
            if(MathAbs(plusDI - minusDI) > 10) 
            {
                return MARKET_REGIME_TRENDING_STRONG;     // 1
            } 
            else 
            {
                return MARKET_REGIME_TRENDING_WEAK;       // 4
            }
        } 
        else 
        {
            return MARKET_REGIME_RANGING_VOLATILE;        // 3
        }
    } 
    else if(atr < atrAvg * 0.7) 
    {
        // ‡∏ï‡∏•‡∏≤‡∏î‡πÄ‡∏á‡∏µ‡∏¢‡∏ö‡∏™‡∏á‡∏ö
        if(adx < 20) 
        {
            return MARKET_REGIME_RANGING_CALM;            // 0
        } 
        else 
        {
            return MARKET_REGIME_TRENDING_WEAK;           // 4
        }
    }
    else 
    {
        // ‡∏™‡∏†‡∏≤‡∏û‡∏õ‡∏Å‡∏ï‡∏¥
        if(adx > 25 && MathAbs(plusDI - minusDI) > 15) 
        {
            return MARKET_REGIME_TRENDING_STRONG;         // 1
        }
        else if(adx > 20 && adx <= 25) 
        {
            return MARKET_REGIME_TRENDING_WEAK;           // 4
        }
        else if(adx < 20 && atr > atrAvg * 1.2) 
        {
            return MARKET_REGIME_BREAKOUT_POTENTIAL;      // 2
        }
        else 
        {
            return MARKET_REGIME_NORMAL;                  // 5
        }
    }
}
void AdjustStrategyByRegime(ENUM_MARKET_REGIME regime) 
{
    switch(regime) 
    {
        case MARKET_REGIME_RANGING_CALM:        // 0
            // Sideways ‡πÄ‡∏á‡∏µ‡∏¢‡∏ö
            g_TP_Multiplier = 0.8;      // TP ‡∏™‡∏±‡πâ‡∏ô‡∏•‡∏á
            g_Lot_Multiplier = 1.2;     // ‡∏≠‡∏≤‡∏à‡πÄ‡∏û‡∏¥‡πà‡∏° lot ‡∏ô‡∏¥‡∏î‡∏´‡∏ô‡πà‡∏≠‡∏¢
            g_Max_Orders = 5;           // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î
            g_Use_Grid = true;          // ‡πÉ‡∏ä‡πâ grid ‡πÑ‡∏î‡πâ
            g_Trend_Only = false;
            g_Strict_SL = false;
            Print("Strategy adjusted for RANGING_CALM market");
            break;
            
        case MARKET_REGIME_TRENDING_STRONG:     // 1
            // ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á
            g_TP_Multiplier = 1.5;      // TP ‡∏¢‡∏≤‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô
            g_Lot_Multiplier = 1.0;     // lot ‡∏õ‡∏Å‡∏ï‡∏¥
            g_Max_Orders = 3;           // ‡∏ô‡πâ‡∏≠‡∏¢‡πÅ‡∏ï‡πà‡∏°‡∏µ‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û
            g_Use_Grid = false;         // ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ grid
            g_Trend_Only = true;        // ‡πÄ‡∏ó‡∏£‡∏î‡∏ï‡∏≤‡∏°‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
            g_Strict_SL = false;
            Print("Strategy adjusted for TRENDING_STRONG market");
            break;
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:  // 2
            // ‡πÇ‡∏≠‡∏Å‡∏≤‡∏™ breakout
            g_TP_Multiplier = 2.0;      // TP ‡∏¢‡∏≤‡∏ß‡∏°‡∏≤‡∏Å
            g_Lot_Multiplier = 0.8;     // ‡∏•‡∏î lot ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á
            g_Max_Orders = 2;           // ‡∏ô‡πâ‡∏≠‡∏¢‡πÜ
            g_Use_Grid = false;
            g_Trend_Only = false;
            g_Strict_SL = true;
            Print("Strategy adjusted for BREAKOUT_POTENTIAL market");
            break;
            
        case MARKET_REGIME_RANGING_VOLATILE:    // 3
            // ‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô‡πÉ‡∏ô range
            g_TP_Multiplier = 0.7;      // TP ‡∏™‡∏±‡πâ‡∏ô‡∏°‡∏≤‡∏Å
            g_Lot_Multiplier = 0.7;     // ‡∏•‡∏î lot
            g_Max_Orders = 4;           // ‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á
            g_Use_Grid = true;
            g_Trend_Only = false;
            g_Strict_SL = true;         // SL ‡πÅ‡∏Ñ‡∏ö
            Print("Strategy adjusted for RANGING_VOLATILE market");
            break;
            
        case MARKET_REGIME_TRENDING_WEAK:       // 4
            // ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏≠‡πà‡∏≠‡∏ô
            g_TP_Multiplier = 1.2;      // TP ‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á
            g_Lot_Multiplier = 1.0;     // lot ‡∏õ‡∏Å‡∏ï‡∏¥
            g_Max_Orders = 4;           // ‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á
            g_Use_Grid = false;
            g_Trend_Only = true;
            g_Strict_SL = false;
            Print("Strategy adjusted for TRENDING_WEAK market");
            break;
            
        case MARKET_REGIME_NORMAL:              // 5
        default:
            // ‡∏™‡∏†‡∏≤‡∏û‡∏õ‡∏Å‡∏ï‡∏¥
            g_TP_Multiplier = 1.0;      // ‡∏õ‡∏Å‡∏ï‡∏¥
            g_Lot_Multiplier = 1.0;     // ‡∏õ‡∏Å‡∏ï‡∏¥
            g_Max_Orders = 5;           // ‡∏õ‡∏Å‡∏ï‡∏¥
            g_Use_Grid = true;
            g_Trend_Only = false;
            g_Strict_SL = false;
            Print("Strategy adjusted for NORMAL market");
            break;
    }
}
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠
string GetRegimeName(ENUM_MARKET_REGIME regime)
{
   switch(regime) {
      case MARKET_REGIME_RANGING_CALM: return "RANGING_CALM";
      case MARKET_REGIME_TRENDING_STRONG: return "TRENDING_STRONG";
      case MARKET_REGIME_BREAKOUT_POTENTIAL: return "BREAKOUT_POTENTIAL";
      case MARKET_REGIME_RANGING_VOLATILE: return "RANGING_VOLATILE";
      case MARKET_REGIME_TRENDING_WEAK: return "TRENDING_WEAK";
      case MARKET_REGIME_NORMAL: return "NORMAL";
      default: return "UNKNOWN";
   }
}
void ExecuteSmartRecovery()
{
    ENUM_MARKET_REGIME regime = DetectMarketRegime(); // ‡πÉ‡∏ä‡πâ ENUM
    double recoveryPressure = CalculateRecoveryRiskPressure();
    
    if(recoveryPressure >= 1.0) {
        EmergencyRecoveryStop(); // ‡∏†‡∏≤‡∏ß‡∏∞‡∏â‡∏∏‡∏Å‡πÄ‡∏â‡∏¥‡∏ô
        return;
    }
    
    switch(regime) {
        case MARKET_REGIME_TRENDING_STRONG:
            // ‡∏ï‡∏•‡∏≤‡∏î‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏ä‡∏±‡∏î ‚Üí Recovery ‡πÅ Aggressive
            if(g_netMomentum > 0) {
                OpenRecoveryPosition(POSITION_TYPE_BUY, 1.8); // Multiplier ‡∏™‡∏π‡∏á
            } else {
                OpenRecoveryPosition(POSITION_TYPE_SELL, 1.8);
            }
            break;
            
        case MARKET_REGIME_RANGING_CALM:
            // ‡∏ï‡∏•‡∏≤‡∏î‡πÄ‡∏á‡∏µ‡∏¢‡∏ö ‚Üí Recovery ‡πÅ‡∏ö‡∏ö Passive
            EnablePassiveRecovery(true);
            WaitForBetterConditions(); // ‡∏£‡∏≠‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏∞‡∏î‡∏µ‡πÜ
            break;
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            // ‡πÇ‡∏≠‡∏Å‡∏≤‡∏™ Breakout ‚Üí Recovery ‡πÅ‡∏ö‡∏ö Opportunistic
            EnableOpportunisticRecovery(true);
            if(IsBreakoutLikely()) {
                OpenRecoveryPosition(GetBreakoutDirection(), 1.5);
            }
            break;
            
        case MARKET_REGIME_RANGING_VOLATILE:
            // ‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô ‚Üí Recovery ‡πÅ‡∏ö‡∏ö‡∏£‡∏∞‡∏°‡∏±‡∏î‡∏£‡∏∞‡∏ß‡∏±‡∏á
            ExecuteCautiousRecovery();
            break;
            
        case MARKET_REGIME_TRENDING_WEAK:
            // ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏≠‡πà‡∏≠‡∏ô ‚Üí Recovery ‡πÅ‡∏ö‡∏ö‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô
            ExecuteStandardRecovery();
            break;
            
        default: // MARKET_REGIME_NORMAL
            // Recovery ‡∏õ‡∏Å‡∏ï‡∏¥
            ExecuteStandardRecovery();
    }
}


//---------//
ENUM_TREND_DIRECTION AnalyzeTrendOnTimeframe(ENUM_TIMEFRAMES tf)
{
    double emaFast = iMA(_Symbol, tf, 9, 0, MODE_EMA, PRICE_CLOSE);
    double emaMedium = iMA(_Symbol, tf, 21, 0, MODE_EMA, PRICE_CLOSE);
    double emaSlow = iMA(_Symbol, tf, 50, 0, MODE_EMA, PRICE_CLOSE);
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    // EMA ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏±‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô (Fast > Medium > Slow)
    bool bullishAlignment = (emaFast > emaMedium && emaMedium > emaSlow);
    bool priceAboveEMA = (currentPrice > emaMedium); // ‡πÉ‡∏ä‡πâ EMA medium ‡πÄ‡∏õ‡πá‡∏ô reference
    
    // EMA ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏±‡∏ß‡∏•‡∏á (Fast < Medium < Slow)
    bool bearishAlignment = (emaFast < emaMedium && emaMedium < emaSlow);
    bool priceBelowEMA = (currentPrice < emaMedium); // ‡πÉ‡∏ä‡πâ EMA medium ‡πÄ‡∏õ‡πá‡∏ô reference
    
    if(bullishAlignment && priceAboveEMA) return TREND_UP;
    if(bearishAlignment && priceBelowEMA) return TREND_DOWN;
    return TREND_SIDEWAYS;
}
// ===== ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏Å‡∏£‡πà‡∏á‡∏Ç‡∏≠‡∏á‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå =====
// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô iRSI ‡∏ô‡∏µ‡πâ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì
double iRSI(string symbol, ENUM_TIMEFRAMES timeframe, int period, int applied_price, int shift)
{
    int handle = iRSI(symbol, timeframe, period, applied_price);
    if(handle == INVALID_HANDLE)
    {
        Print("Error creating RSI indicator");
        return 0;
    }
    
    double buffer[];
    ArraySetAsSeries(buffer, true);
    
    if(CopyBuffer(handle, 0, shift, 1, buffer) < 1)
    {
        Print("Error copying RSI buffer");
        IndicatorRelease(handle);
        return 0;
    }
    
    IndicatorRelease(handle);
    return buffer[0];
}
double CalculateTrendStrength(int direction = DIRECTION_DOWN)
{
    int adxHandle = iADX(Symbol(), PERIOD_CURRENT, 14);
    double adxValue[1], plusDI[1], minusDI[1];
    
    if(CopyBuffer(adxHandle, 0, 0, 1, adxValue) < 1 ||
       CopyBuffer(adxHandle, 1, 0, 1, plusDI) < 1 ||
       CopyBuffer(adxHandle, 2, 0, 1, minusDI) < 1)
    {
        IndicatorRelease(adxHandle);
        return 0;
    }
    
    IndicatorRelease(adxHandle);
    
    if(direction == DIRECTION_DOWN)
    {
        // For downtrend: check if -DI > +DI
        return (minusDI[0] > plusDI[0]) ? adxValue[0] : 0;
    }
    else if(direction == DIRECTION_UP)
    {
        // For uptrend: check if +DI > -DI
        return (plusDI[0] > minusDI[0]) ? adxValue[0] : 0;
    }
    
    return adxValue[0]; // Return ADX value regardless of direction
}
// ===== ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î =====
bool ShouldTradeBasedOnTrend(ENUM_TREND_DIRECTION trend, double strength)
{



    if(trend == TREND_SIDEWAYS) 
    {
        DebugPrint(3, "Market is sideways - skipping trend scalp");
        return false;
    }
    if(strength < 2.5) 
    {
        DebugPrint(3, "Trend strength too weak: " + DoubleToString(strength, 1));
        return false;
    }
    
    
    // üî• ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö MQL5 - ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß!
    double rsi = iRSI(_Symbol, PERIOD_M1, 14, PRICE_CLOSE, 0);
    
    if(trend == TREND_UP)
    {
        if(!(rsi > 30 && rsi < 85)) 
        {
            DebugPrint(3, "RSI not in BUY range: " + DoubleToString(rsi, 1));
            return false;
        }
    }
    else if(trend == TREND_DOWN)
    {
        if(!(rsi < 70 && rsi > 15)) 
        {
            DebugPrint(3, "RSI not in SELL range: " + DoubleToString(rsi, 1));
            return false;
        }
    }
    
    int sameDirectionCount = CountPositionsInTrendDirection(trend);
    if(sameDirectionCount >= 1)
    {
        DebugPrint(3, "Already have " + IntegerToString(sameDirectionCount) + " positions in trend direction");
        return false;
    }
    
    DebugPrint(2, "Trend signal confirmed - Direction: " + GetTrendDirectionName(trend) + 
                ", Strength: " + DoubleToString(strength, 1) +
                ", RSI: " + DoubleToString(rsi, 1));
    return true;
}
// ===== ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏•‡πá‡∏≠‡∏ï‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏Å‡∏£‡πà‡∏á‡∏Ç‡∏≠‡∏á‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå =====
double CalculateTrendBasedLot(double trendStrength)
{
    double baseLot = BaseLot;
    
    // ‡∏õ‡∏£‡∏±‡∏ö‡∏•‡πá‡∏≠‡∏ï‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏Å‡∏£‡πà‡∏á‡∏Ç‡∏≠‡∏á‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå
    if(trendStrength > 7.0) 
        baseLot *= 1.5; // ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á ‚Üí ‡∏•‡πá‡∏≠‡∏ï‡πÉ‡∏´‡∏ç‡πà‡∏Ç‡∏∂‡πâ‡∏ô
    else if(trendStrength > 5.0) 
        baseLot *= 1.2; // ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á
    else if(trendStrength < 3.0)
        baseLot *= 0.8; // ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏≠‡πà‡∏≠‡∏ô ‚Üí ‡∏•‡πá‡∏≠‡∏ï‡πÄ‡∏•‡πá‡∏Å‡∏•‡∏á
    
    baseLot = MathMin(baseLot, MaxLot);
    baseLot = MathMax(baseLot, BaseLot);  // ‡πÉ‡∏ä‡πâ BaseLot ‡πÅ‡∏ó‡∏ô MinLot
    
    Print("Trend Strength: ", trendStrength, " | Calculated Lot: ", baseLot);
    return NormalizeDouble(baseLot, 2);
}
// ===== ‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î‡∏ï‡∏≤‡∏°‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå =====
void ExecuteTrendBuy(double lot)
{
    double tpPoints = Current_TrendScalp_TP_Points; // ‡πÉ‡∏ä‡πâ‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏Ç‡∏≠‡∏á Trend Scalp
    double slPoints = TrendScalp_SL_Points; // ‡πÉ‡∏ä‡πâ‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏Ç‡∏≠‡∏á Trend Scalp
    
    double tpPrice = GetTPPriceUniversal(true, tpPoints);
    double slPrice = GetSLPriceUniversal(true, slPoints);
    
    // ‡∏õ‡∏£‡∏±‡∏ö TP/SL ‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏Å‡∏£‡πà‡∏á‡∏Ç‡∏≠‡∏á‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå
    double trendStrength = CalculateTrendStrength();
    if(trendStrength > 7.0) 
    {
        // ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á ‚Üí TP ‡πÑ‡∏Å‡∏•‡∏Ç‡∏∂‡πâ‡∏ô
        tpPrice = GetTPPriceUniversal(true, tpPoints * 1.3);
        DebugPrint(2, "Strong trend detected - Increasing TP by 30%");
    }
    else if(trendStrength < 3.0)
    {
        // ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏≠‡πà‡∏≠‡∏ô ‚Üí TP ‡∏™‡∏±‡πâ‡∏ô‡∏•‡∏á
        tpPrice = GetTPPriceUniversal(true, tpPoints * 0.8);
        DebugPrint(2, "Weak trend detected - Decreasing TP by 20%");
    }
    
    if(trade.Buy(lot, _Symbol, slPrice, 0, tpPrice, "TrendScalp-Buy"))
     {
    ulong ticket = trade.ResultOrder();
    Print("üéØ TREND SCALP BUY | Trend: " + GetTrendDirectionName(TREND_UP) + 
          " | Strength: " + DoubleToString(trendStrength, 1) + 
          " | Lot: " + DoubleToString(lot, 2) + 
          " | TP: " + DoubleToString(tpPoints, 1) + "pips" +  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô IntegerToString ‡πÄ‡∏õ‡πá‡∏ô DoubleToString
          " | Ticket: #" + TicketToStr(ticket));
      }
    else
    {
        Print("‚ùå Trend Scalp BUY Error: " + trade.ResultRetcodeDescription());
    }
}

void ExecuteTrendSell(double lot)
{
    double tpPoints = Current_TrendScalp_TP_Points; // ‡πÉ‡∏ä‡πâ‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏Ç‡∏≠‡∏á Trend Scalp
    double slPoints = TrendScalp_SL_Points; // ‡πÉ‡∏ä‡πâ‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏Ç‡∏≠‡∏á Trend Scalp
    
    double tpPrice = GetTPPriceUniversal(false, tpPoints);
    double slPrice = GetSLPriceUniversal(false, slPoints);
    
    double trendStrength = CalculateTrendStrength();
    if(trendStrength > 7.0) 
    {
        tpPrice = GetTPPriceUniversal(false, tpPoints * 1.3);
        DebugPrint(2, "Strong trend detected - Increasing TP by 30%");
    }
    else if(trendStrength < 3.0)
    {
        tpPrice = GetTPPriceUniversal(false, tpPoints * 0.8);
        DebugPrint(2, "Weak trend detected - Decreasing TP by 20%");
    }
    
    if(trade.Sell(lot, _Symbol, slPrice, 0, tpPrice, "TrendScalp-Sell"))
      {
    ulong ticket = trade.ResultOrder();
    Print("üéØ TREND SCALP SELL | Trend: " + GetTrendDirectionName(TREND_DOWN) + 
          " | Strength: " + DoubleToString(trendStrength, 1) + 
          " | Lot: " + DoubleToString(lot, 2) + 
          " | TP: " + DoubleToString(tpPoints, 1) + "pips" +  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô IntegerToString ‡πÄ‡∏õ‡πá‡∏ô DoubleToString
          " | Ticket: #" + TicketToStr(ticket));
      }
    else
    {
        Print("‚ùå Trend Scalp SELL Error: " + trade.ResultRetcodeDescription());
    }
}
// ===== ‡∏ô‡∏±‡∏ö‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÉ‡∏ô‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå =====
int CountPositionsInTrendDirection(ENUM_TREND_DIRECTION trend)
{
    int count = 0;
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            if(PositionGetInteger(POSITION_MAGIC) == MAGIC_TREND_SCALP) // ‡πÉ‡∏ä‡πâ Magic ‡∏Ç‡∏≠‡∏á Trend Scalp
            {
                ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
                if((trend == TREND_UP && type == POSITION_TYPE_BUY) ||
                   (trend == TREND_DOWN && type == POSITION_TYPE_SELL))
                {
                    count++;
                }
            }
        }
    }
    return count;
}

// ===== ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠ =====
string GetTrendDirectionName(ENUM_TREND_DIRECTION trend)
{
    switch(trend)
    {
        case TREND_UP: return "UP";
        case TREND_DOWN: return "DOWN";
        default: return "SIDEWAYS";
    }
}

// üìç ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà
void BroadcastToAllSystems(string message) {
   Print("üì¢ SYSTEM BROADCAST: " + message);
   
   // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡∏≠‡∏∑‡πà‡∏ô‡πÜ
   LastSystemMessage = message;
   MessageTime = TimeCurrent();
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏´‡∏°‡πà
bool HasNewSystemMessage() {
   return (TimeCurrent() - MessageTime) < 5; // 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
}

//+------------------------------------------------------------------+
//| ExecuteScalp1 - Scalp1 Strategy Deepseek                         |
//+------------------------------------------------------------------+
void ExecuteScalp1(ENUM_MARKET_REGIME regime = MARKET_REGIME_NORMAL)
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö regime ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏™‡πà‡∏á‡∏°‡∏≤
    if(regime == MARKET_REGIME_NORMAL) 
    {
        regime = DetectMarketRegime();
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÇ‡∏´‡∏°‡∏î‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏ó‡∏£‡∏î
    if(SystemMode == MODE_RECOVERY) 
    {
        DebugPrint(2, "Scalp1: Reducing activity in Recovery mode");
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ regime ‡∏ô‡∏µ‡πâ‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö recovery ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        if(!IsRegimeSafeForRecovery(regime)) 
        {
            DebugPrint(1, "Scalp1: Unsafe regime for recovery - skipping");
            return;
        }
    }
    
    if(SystemMode == MODE_HIGH_RISK) 
    {
        DebugPrint(1, "Scalp1: Suspended in High Risk mode");
        return; // ‡∏´‡∏¢‡∏∏‡∏î‡πÄ‡∏ó‡∏£‡∏î‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÇ‡∏´‡∏°‡∏î‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏ó‡∏£‡∏î
    if(!Scalp1Enabled) 
    {
        DebugPrint(3, "Scalp1 disabled - skipping");
        return;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Scalp1 ‡∏Ñ‡∏ß‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÉ‡∏ô regime ‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if(!IsScalp1AllowedInRegime(regime)) 
    {
        DebugPrint(2, "Scalp1 not allowed in current market regime: " + EnumToString(regime));
        return;
    }
    
    // üîç DEBUG START - ‡∏ß‡∏≤‡∏á‡∏Å‡πà‡∏≠‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡πÄ‡∏î‡∏¥‡∏°
    if(EnableDebugMode) 
    {
        Print("=== üéØ SCALP1 DEBUG START ===");
        Print("Market Regime: " + EnumToString(regime));
        Print("1. Scalp1Enabled: ", Scalp1Enabled);
        Print("2. PositionsTotal: ", PositionsTotal());
        Print("3. Scalp1 Count: ", CountPositionsByMagic(MAGIC_SCALP1));
        Print("4. Max Positions: ", Scalp1_MaxPositions);
        Print("5. System Mode: ", (SystemMode == MODE_RECOVERY) ? "RECOVERY" : "NORMAL");
    }
    
    // ‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
    double ema9 = iMA(_Symbol, PERIOD_M1, 9, 0, MODE_EMA, PRICE_CLOSE);
    double ema21 = iMA(_Symbol, PERIOD_M1, 21, 0, MODE_EMA, PRICE_CLOSE);
    double rsi = iRSI(_Symbol, PERIOD_M1, 14, PRICE_CLOSE);
    
    if(EnableDebugMode) 
    {
        Print("6. EMA9: ", ema9, " | EMA21: ", ema21, " | RSI: ", rsi);
    }
    
    // üî• ‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç entry ‡∏ï‡∏≤‡∏° market regime
    bool buyCondition = GetScalp1BuyCondition(ema9, ema21, rsi, regime);
    bool sellCondition = GetScalp1SellCondition(ema9, ema21, rsi, regime);
    
    if(EnableDebugMode) 
    {
        Print("7. Buy Condition: ", buyCondition);
        Print("8. Sell Condition: ", sellCondition);
        Print("=== üéØ SCALP1 DEBUG END ===");
    }
    // üîç DEBUG END
    
    int scalp1Count = CountPositionsByMagic(MAGIC_SCALP1);
    
    // üî• ‡∏õ‡∏£‡∏±‡∏ö max positions ‡∏ï‡∏≤‡∏° regime
    int allowedPositions = GetScalp1MaxPositionsForRegime(regime);
    if(scalp1Count >= allowedPositions) 
    {
        DebugPrint(3, "Max Scalp1 positions reached for " + EnumToString(regime) + 
                  ": " + IntegerToString(scalp1Count) + "/" + IntegerToString(allowedPositions));
        return;
    }

    DebugPrint(3, "Starting Scalp1 analysis for regime: " + EnumToString(regime));
    
    DebugPrint(3, "Indicators - EMA9: " + DoubleToString(ema9, 5) + 
                ", EMA21: " + DoubleToString(ema21, 5) + 
                ", RSI: " + DoubleToString(rsi, 1));
    
    // ‡πÄ‡∏û‡∏¥‡πà‡∏° Price Action confirmation
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_M1, 0, 2, rates) == 2)
    {
        bool bullishCandle = (rates[0].close > rates[0].open);
        bool bearishCandle = (rates[0].close < rates[0].open);
        
        // üî• ‡∏õ‡∏£‡∏±‡∏ö price action ‡∏ï‡∏≤‡∏° regime
        buyCondition = buyCondition && ShouldUsePriceActionForBuy(regime, bullishCandle);
        sellCondition = sellCondition && ShouldUsePriceActionForSell(regime, bearishCandle);
    }

    DebugPrint(3, "Conditions - Buy: " + (buyCondition ? "YES" : "NO") + 
                ", Sell: " + (sellCondition ? "YES" : "NO"));

    if(!buyCondition && !sellCondition) 
    {
        DebugPrint(3, "No valid Scalp1 signal found for " + EnumToString(regime));
        return;
    }
    
    // üî• ‡∏õ‡∏£‡∏±‡∏ö lot size ‡∏ï‡∏≤‡∏° regime
    double baseLot = CalculateSafeScalpLot();
    double lotMultiplier = GetScalp1LotMultiplierForRegime(regime);
    double lot = NormalizeDouble(baseLot * lotMultiplier, 2);
    
    // üî• ‡∏õ‡∏£‡∏±‡∏ö TP/SL ‡∏ï‡∏≤‡∏° regime
    double tpMultiplier = GetScalp1TPMultiplierForRegime(regime);
    double slMultiplier = GetScalp1SLMultiplierForRegime(regime);
    
    if(!CheckMargin(lot)) 
    {
        DebugPrint(1, "Insufficient margin for Scalp1: " + DoubleToString(lot, 2));
        return;
    }

    trade.SetExpertMagicNumber(MAGIC_SCALP1);
    
    if(buyCondition)
    {
        // üî• ‡πÉ‡∏ä‡πâ TP/SL ‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° regime
        double tpPoints = MathMax(Scalp1_TP_Points * tpMultiplier, 5); // ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 5 points
        double slPoints = MathMax(Scalp1_SL_Points * slMultiplier, 10); // ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 10 points
        
        double tpPrice = GetTPPriceUniversal(true, (int)tpPoints);
        double slPrice = GetSLPriceUniversal(true, (int)slPoints);
        
        DebugPrint(2, "Scalp1 BUY Signal - Regime: " + EnumToString(regime) + 
                   ", Lot: " + DoubleToString(lot, 2) + 
                   ", TP: " + DoubleToString(tpPrice, GetDigits()) + 
                   " (" + DoubleToString(tpMultiplier, 2) + "x)");
                   
        if(trade.Buy(lot, _Symbol, slPrice, 0, tpPrice, "Scalp1-Buy-" + EnumToString(regime)))
        {
            ulong ticket = trade.ResultOrder();
            Print("‚úÖ SCALP1 BUY | Regime: " + EnumToString(regime) + 
                  " | Ticket: #" + TicketToStr(ticket) + 
                  " | Lot: " + DoubleToString(lot, 2) + 
                  " | TP: " + IntegerToString((int)tpPoints) + "pips" +
                  " | Multiplier: " + DoubleToString(lotMultiplier, 2) + "x");
        }
        else
        {
            Print("‚ùå Scalp1 BUY Error: " + trade.ResultRetcodeDescription());
        }
    }
    else if(sellCondition)
    {
        // üî• ‡πÉ‡∏ä‡πâ TP/SL ‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° regime
        double tpPoints = MathMax(Scalp1_TP_Points * tpMultiplier, 5);
        double slPoints = MathMax(Scalp1_SL_Points * slMultiplier, 10);
        
        double tpPrice = GetTPPriceUniversal(false, (int)tpPoints);
        double slPrice = GetSLPriceUniversal(false, (int)slPoints);
        
        DebugPrint(2, "Scalp1 SELL Signal - Regime: " + EnumToString(regime) + 
                   ", Lot: " + DoubleToString(lot, 2) + 
                   ", TP: " + DoubleToString(tpPrice, GetDigits()) + 
                   " (" + DoubleToString(tpMultiplier, 2) + "x)");
                   
        if(trade.Sell(lot, _Symbol, slPrice, 0, tpPrice, "Scalp1-Sell-" + EnumToString(regime)))
        {
            ulong ticket = trade.ResultOrder();
            Print("‚úÖ SCALP1 SELL | Regime: " + EnumToString(regime) + 
                  " | Ticket: #" + TicketToStr(ticket) + 
                  " | Lot: " + DoubleToString(lot, 2) + 
                  " | TP: " + IntegerToString((int)tpPoints) + "pips" +
                  " | Multiplier: " + DoubleToString(lotMultiplier, 2) + "x");
        }
        else
        {
            Print("‚ùå Scalp1 SELL Error: " + trade.ResultRetcodeDescription());
        }
    }
}
// üî• ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Helper ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Scalp1 ‡∏ï‡∏≤‡∏° Market Regime
bool IsScalp1AllowedInRegime(ENUM_MARKET_REGIME regime)
{
    switch(regime)
    {
        case MARKET_REGIME_RANGING_VOLATILE:
            // ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô ‡∏≠‡∏≤‡∏à‡∏õ‡∏¥‡∏î Scalp1 ‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏ä‡πâ strict rules
            return EnableScalp1InVolatileMarket;
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            // ‡πÉ‡∏ô breakout ‡∏£‡∏≠ confirmation
            return EnableScalp1InBreakout;
            
        case MARKET_REGIME_TRENDING_STRONG:
            // ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á ‡πÉ‡∏ä‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Å‡∏±‡∏ö trend direction
            return EnableScalp1InStrongTrend;
            
        default:
            return true;
    }
}
bool GetScalp1BuyCondition(double ema9, double ema21, double rsi, ENUM_MARKET_REGIME regime)
{
    switch(regime)
    {
        case MARKET_REGIME_TRENDING_STRONG:
            // ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á ‡πÉ‡∏ä‡πâ RSI range ‡πÅ‡∏Ñ‡∏ö‡∏Å‡∏ß‡πà‡∏≤
            return (ema9 > ema21 && rsi > 55 && rsi < 75);
            
        case MARKET_REGIME_RANGING_VOLATILE:
            // ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô ‡πÉ‡∏ä‡πâ RSI range ‡πÅ‡∏Ñ‡∏ö‡πÅ‡∏•‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ divergence
            return (ema9 > ema21 && rsi > 60 && rsi < 70);
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            // ‡πÉ‡∏ô breakout ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ confirmation ‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô
            return (ema9 > ema21 && rsi > 65 && rsi < 80);
            
        case MARKET_REGIME_RANGING_CALM:
            // ‡πÉ‡∏ô sideways ‡πÄ‡∏á‡∏µ‡∏¢‡∏ö ‡πÉ‡∏ä‡πâ RSI range ‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏Å‡∏ß‡πà‡∏≤
            return (ema9 > ema21 && rsi > 40 && rsi < 80);
            
        case MARKET_REGIME_TRENDING_WEAK:
            // ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏≠‡πà‡∏≠‡∏ô ‡πÉ‡∏ä‡πâ RSI range ‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á
            return (ema9 > ema21 && rsi > 50 && rsi < 75);
            
        case MARKET_REGIME_NORMAL:
        default:
            // ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÄ‡∏î‡∏¥‡∏°
            return (ema9 > ema21 && rsi > 35 && rsi < 80);
    }
}

bool GetScalp1SellCondition(double ema9, double ema21, double rsi, ENUM_MARKET_REGIME regime)
{
    switch(regime)
    {
        case MARKET_REGIME_TRENDING_STRONG:
            return (ema9 < ema21 && rsi < 45 && rsi > 25);
            
        case MARKET_REGIME_RANGING_VOLATILE:
            return (ema9 < ema21 && rsi < 40 && rsi > 30);
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            return (ema9 < ema21 && rsi < 35 && rsi > 20);
            
        case MARKET_REGIME_RANGING_CALM:
            return (ema9 < ema21 && rsi < 60 && rsi > 20);
            
        case MARKET_REGIME_TRENDING_WEAK:
            return (ema9 < ema21 && rsi < 50 && rsi > 25);
            
        case MARKET_REGIME_NORMAL:
        default:
            return (ema9 < ema21 && rsi < 65 && rsi > 20);
    }
}

int GetScalp1MaxPositionsForRegime(ENUM_MARKET_REGIME regime)
{
    int baseMax = Scalp1_MaxPositions;
    
    switch(regime)
    {
        case MARKET_REGIME_RANGING_VOLATILE:
            return MathMax(1, baseMax / 2); // ‡∏•‡∏î‡∏Ñ‡∏£‡∏∂‡πà‡∏á‡∏´‡∏ô‡∏∂‡πà‡∏á
        
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            return MathMax(2, (int)(baseMax * 0.7)); // ‡∏•‡∏î 30%
            
        case MARKET_REGIME_TRENDING_STRONG:
            return MathMin(baseMax + 1, 10); // ‡∏≠‡∏≤‡∏à‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏î‡πâ 1 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
            
        case MARKET_REGIME_RANGING_CALM:
            return baseMax; // ‡∏õ‡∏Å‡∏ï‡∏¥
            
        default:
            return baseMax;
    }
}

double GetScalp1LotMultiplierForRegime(ENUM_MARKET_REGIME regime)
{
    switch(regime)
    {
        case MARKET_REGIME_RANGING_VOLATILE:
            return 0.5; // ‡∏•‡∏î lot 50%
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            return 0.7; // ‡∏•‡∏î lot 30%
            
        case MARKET_REGIME_TRENDING_STRONG:
            return 1.2; // ‡πÄ‡∏û‡∏¥‡πà‡∏° lot 20%
            
        case MARKET_REGIME_RANGING_CALM:
            return 1.0; // ‡∏õ‡∏Å‡∏ï‡∏¥
            
        case MARKET_REGIME_TRENDING_WEAK:
            return 0.9; // ‡∏•‡∏î‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
            
        default:
            return 1.0;
    }
}

double GetScalp1TPMultiplierForRegime(ENUM_MARKET_REGIME regime)
{
    switch(regime)
    {
        case MARKET_REGIME_TRENDING_STRONG:
            return 1.5; // TP ‡∏¢‡∏≤‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á
            
        case MARKET_REGIME_RANGING_VOLATILE:
            return 0.7; // TP ‡∏™‡∏±‡πâ‡∏ô‡∏•‡∏á‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            return 2.0; // TP ‡∏¢‡∏≤‡∏ß‡∏°‡∏≤‡∏Å‡πÉ‡∏ô breakout
            
        case MARKET_REGIME_RANGING_CALM:
            return 0.8; // TP ‡∏™‡∏±‡πâ‡∏ô‡∏•‡∏á‡πÉ‡∏ô sideways ‡πÄ‡∏á‡∏µ‡∏¢‡∏ö
            
        case MARKET_REGIME_TRENDING_WEAK:
            return 1.2; // TP ‡∏¢‡∏≤‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
            
        default:
            return 1.0;
    }
}

double GetScalp1SLMultiplierForRegime(ENUM_MARKET_REGIME regime)
{
    switch(regime)
    {
        case MARKET_REGIME_RANGING_VOLATILE:
            return 0.8; // SL ‡πÅ‡∏Ñ‡∏ö‡∏•‡∏á‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
            
        case MARKET_REGIME_TRENDING_STRONG:
            return 1.3; // SL ‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            return 1.5; // SL ‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡πÉ‡∏ô breakout
            
        default:
            return 1.0;
    }
}

bool ShouldUsePriceActionForBuy(ENUM_MARKET_REGIME regime, bool bullishCandle)
{
    switch(regime)
    {
        case MARKET_REGIME_RANGING_VOLATILE:
            return bullishCandle; // ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ bullish candle ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            return true; // ‡πÉ‡∏ô breakout ‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ candle confirmation ‡πÄ‡∏™‡∏°‡∏≠‡πÑ‡∏õ
            
        default:
            return true; // ‡πÉ‡∏ä‡πâ‡∏ï‡∏≤‡∏°‡∏õ‡∏Å‡∏ï‡∏¥
    }
}

bool ShouldUsePriceActionForSell(ENUM_MARKET_REGIME regime, bool bearishCandle)
{
    switch(regime)
    {
        case MARKET_REGIME_RANGING_VOLATILE:
            return bearishCandle;
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            return true;
            
        default:
            return true;
    }
}

bool IsRegimeSafeForRecovery(ENUM_MARKET_REGIME regime)
{
    switch(regime)
    {
        case MARKET_REGIME_RANGING_VOLATILE:
            return false; // ‡πÑ‡∏°‡πà‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            return false; // ‡πÑ‡∏°‡πà‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡πÉ‡∏ô breakout
            
        default:
            return true;
    }
}
bool IsBreakoutStrategySuitableForRegime(ENUM_MARKET_REGIME regime)
{
    switch(regime)
    {
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            return true; // ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
            
        case MARKET_REGIME_TRENDING_STRONG:
            return EnableBreakoutInStrongTrend; // ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î‡πÑ‡∏î‡πâ
            
        case MARKET_REGIME_RANGING_VOLATILE:
            return EnableBreakoutInVolatileMarket; // ‡∏≠‡∏≤‡∏à‡∏≠‡∏±‡∏ô‡∏ï‡∏£‡∏≤‡∏¢
            
        case MARKET_REGIME_RANGING_CALM:
            return EnableBreakoutInCalmMarket; // ‡∏≠‡∏≤‡∏à‡πÄ‡∏Å‡∏¥‡∏î false breakout
            
        case MARKET_REGIME_TRENDING_WEAK:
            return EnableBreakoutInWeakTrend;
            
        default:
            return true;
    }
}
double GetBreakoutLotMultiplierForRegime(ENUM_MARKET_REGIME regime)
{
    switch(regime)
    {
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            return 1.2; // ‡πÄ‡∏û‡∏¥‡πà‡∏° lot ‡πÉ‡∏ô breakout ‡∏à‡∏£‡∏¥‡∏á
            
        case MARKET_REGIME_RANGING_VOLATILE:
            return 0.6; // ‡∏•‡∏î lot ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
            
        case MARKET_REGIME_TRENDING_STRONG:
            return 1.0; // ‡∏õ‡∏Å‡∏ï‡∏¥
            
        case MARKET_REGIME_RANGING_CALM:
            return 0.8; // ‡∏•‡∏î‡∏ô‡∏¥‡∏î‡∏´‡∏ô‡πà‡∏≠‡∏¢
            
        case MARKET_REGIME_TRENDING_WEAK:
            return 0.9; // ‡∏•‡∏î‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
            
        default:
            return 1.0;
    }
}
double GetBreakoutTPMultiplierForRegime(ENUM_MARKET_REGIME regime)
{
    switch(regime)
    {
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            return 2.0; // TP ‡∏¢‡∏≤‡∏ß‡πÉ‡∏ô breakout ‡∏à‡∏£‡∏¥‡∏á
            
        case MARKET_REGIME_TRENDING_STRONG:
            return 1.5; // TP ‡∏¢‡∏≤‡∏ß‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á
            
        case MARKET_REGIME_RANGING_VOLATILE:
            return 0.7; // TP ‡∏™‡∏±‡πâ‡∏ô‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
            
        case MARKET_REGIME_RANGING_CALM:
            return 1.0; // ‡∏õ‡∏Å‡∏ï‡∏¥
            
        default:
            return 1.0;
    }
}
double GetBreakoutSLMultiplierForRegime(ENUM_MARKET_REGIME regime)
{
    switch(regime)
    {
        case MARKET_REGIME_RANGING_VOLATILE:
            return 0.8; // SL ‡πÅ‡∏Ñ‡∏ö‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            return 1.3; // SL ‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡πÉ‡∏ô breakout
            
        case MARKET_REGIME_TRENDING_STRONG:
            return 1.2; // SL ‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á
            
        default:
            return 1.0;
    }
}
//+------------------------------------------------------------------+
//| ExecuteAdvancedBreakout - Use new TP function                   |
//+------------------------------------------------------------------+
void ExecuteAdvancedBreakout(ENUM_MARKET_REGIME regime = MARKET_REGIME_NORMAL)
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö regime ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏™‡πà‡∏á‡∏°‡∏≤
    if(regime == MARKET_REGIME_NORMAL) 
    {
        regime = DetectMarketRegime();
    }
    
    if(!BreakoutStrategy) 
    {
        DebugPrint(3, "Breakout strategy disabled - skipping");
        return;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ breakout strategy ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏Å‡∏±‡∏ö market regime ‡∏ô‡∏µ‡πâ‡πÑ‡∏´‡∏°
    if(!IsBreakoutStrategySuitableForRegime(regime))
    {
        DebugPrint(2, "Breakout strategy not suitable for " + EnumToString(regime) + " regime");
        return;
    }
    
    DebugPrint(3, "Starting Breakout analysis for regime: " + EnumToString(regime));
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ breakout position ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    bool hasBreakout = false;
    int total = (int)PositionsTotal();
    for(int i = 0; i < total; i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(ticket > 0 && PositionSelectByTicket(ticket))
        {
            if(PositionGetInteger(POSITION_MAGIC) == MAGIC_BREAKOUT)
            {
                hasBreakout = true;
                break;
            }
        }
    }
    
    if(hasBreakout) 
    {
        DebugPrint(3, "Breakout position already exists - skipping");
        return;
    }

    // ‡∏õ‡∏£‡∏±‡∏ö parameters ‡∏Ç‡∏≠‡∏á breakout detection ‡∏ï‡∏≤‡∏° regime
    bool buySignal = DetectAdvancedBreakoutBUY(regime);
    bool sellSignal = DetectAdvancedBreakoutSELL(regime);

    DebugPrint(3, "Breakout Signals for " + EnumToString(regime) + 
                " - Buy: " + (buySignal ? "YES" : "NO") + 
                ", Sell: " + (sellSignal ? "YES" : "NO"));

    // üî• ‡∏õ‡∏£‡∏±‡∏ö lot size ‡∏ï‡∏≤‡∏° regime
    double baseLot = BaseLot;
    double lotMultiplier = GetBreakoutLotMultiplierForRegime(regime);
    double lot = NormalizeDouble(baseLot * lotMultiplier, 2);
    
    // üî• ‡∏õ‡∏£‡∏±‡∏ö TP distance ‡∏ï‡∏≤‡∏° regime
    double tpMultiplier = GetBreakoutTPMultiplierForRegime(regime);
    int tpPoints = (int)(TP_Points_Breakout * tpMultiplier);
    tpPoints = MathMax(tpPoints, 10); // ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 10 points

    if(buySignal)
    {
        if(!CheckMargin(lot))
        {
            DebugPrint(1, "Insufficient margin for Breakout BUY");
            return;
        }
        
        trade.SetExpertMagicNumber(MAGIC_BREAKOUT);
        
        // üî• ‡πÉ‡∏ä‡πâ SL ‡∏ï‡∏≤‡∏° regime (‡∏ñ‡πâ‡∏≤‡πÉ‡∏ä‡πâ SL)
        double slPrice = 0;
        if(UseStopLossInBreakout)
        {
            double slMultiplier = GetBreakoutSLMultiplierForRegime(regime);
            int slPoints = (int)(SL_Points_Breakout * slMultiplier);
            slPrice = GetSLPriceUniversal(true, slPoints);
        }
        
        double tpPrice = GetTPPriceUniversal(true, tpPoints);
        
        DebugPrint(2, "Breakout BUY Signal - Regime: " + EnumToString(regime) + 
                   ", Lot: " + DoubleToString(lot, 2) + 
                   ", TP: " + DoubleToString(tpPrice, GetDigits()) +
                   " (" + DoubleToString(tpMultiplier, 2) + "x)");
        
        if(trade.Buy(lot, _Symbol, slPrice, 0, tpPrice, "Adv-Breakout-Buy-" + EnumToString(regime)))
        {
            Print("‚úÖ Advanced Breakout BUY | Regime: " + EnumToString(regime) + 
                  ", Lot: " + DoubleToString(lot, 2) + 
                  ", TP: " + IntegerToString(tpPoints) + "pips");
        }
        else
        {
            DebugPrint(1, "Failed to open Breakout BUY: " + IntegerToString(trade.ResultRetcode()));
            Print("‚ùå Breakout BUY Error: " + IntegerToString(trade.ResultRetcode()));
        }
    }
    else if(sellSignal)
    {
        if(!CheckMargin(lot))
        {
            DebugPrint(1, "Insufficient margin for Breakout SELL");
            return;
        }
        
        trade.SetExpertMagicNumber(MAGIC_BREAKOUT);
        
        // üî• ‡πÉ‡∏ä‡πâ SL ‡∏ï‡∏≤‡∏° regime
        double slPrice = 0;
        if(UseStopLossInBreakout)
        {
            double slMultiplier = GetBreakoutSLMultiplierForRegime(regime);
            int slPoints = (int)(SL_Points_Breakout * slMultiplier);
            slPrice = GetSLPriceUniversal(false, slPoints);
        }
        
        double tpPrice = GetTPPriceUniversal(false, tpPoints);
        
        DebugPrint(2, "Breakout SELL Signal - Regime: " + EnumToString(regime) + 
                   ", Lot: " + DoubleToString(lot, 2) + 
                   ", TP: " + DoubleToString(tpPrice, GetDigits()) +
                   " (" + DoubleToString(tpMultiplier, 2) + "x)");
        
        if(trade.Sell(lot, _Symbol, slPrice, 0, tpPrice, "Adv-Breakout-Sell-" + EnumToString(regime)))
        {
            Print("‚úÖ Advanced Breakout SELL | Regime: " + EnumToString(regime) + 
                  ", Lot: " + DoubleToString(lot, 2) + 
                  ", TP: " + IntegerToString(tpPoints) + "pips");
        }
        else
        {
            DebugPrint(1, "Failed to open Breakout SELL: " + IntegerToString(trade.ResultRetcode()));
            Print("‚ùå Breakout SELL Error: " + IntegerToString(trade.ResultRetcode()));
        }
    }
    else
    {
        DebugPrint(3, "No Breakout signals detected for " + EnumToString(regime));
    }
}
//----scalp1
bool IsMarketGoodForScalp1()
{
    double atr = CalculateATR(14, 0, _Symbol);
    double atrPercent = (atr / SymbolInfoDouble(_Symbol, SYMBOL_BID)) * 100;
    
    // ?????????????????????? ???? ????????????
    return (atrPercent > 0.08 && atrPercent < 0.2);
    
}
bool GetSimpleSwingSignal()
{
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_M1, 0, 3, rates) != 3) return false;
    
    // ???????????: Break High/Low ??? 2 candle ?????????
    bool buySignal = (rates[0].close > rates[1].high && rates[1].close > rates[1].open);
    bool sellSignal = (rates[0].close < rates[1].low && rates[1].close < rates[1].open);
    
    return (buySignal || sellSignal);
}
bool DetectBreakoutBuyInStrongTrend()
{
    // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á breakout ‡∏≠‡∏≤‡∏à‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ confirmation ‡∏ô‡πâ‡∏≠‡∏¢‡∏•‡∏á
    // ‡πÅ‡∏ï‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà pullback
    // ‡πÉ‡∏ä‡πâ GetEMAValue ‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÅ‡∏•‡πâ‡∏ß
    double ema20 = GetEMAValue(_Symbol, PERIOD_H1, 20, 0);
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    return (currentPrice > ema20);
    
}
double CalculateSupportLevel(int lookbackPeriod = 10, int method = 1)
{
    switch(method)
    {
        case 1: // Simple lowest price
            return iLow(Symbol(), PERIOD_CURRENT, iLowest(Symbol(), PERIOD_CURRENT, MODE_LOW, lookbackPeriod, 1));
        
        case 2: // Dynamic support with MA
        {
            double priceSupport = iLow(Symbol(), PERIOD_CURRENT, iLowest(Symbol(), PERIOD_CURRENT, MODE_LOW, lookbackPeriod, 1));
            double maSupport = iMA(Symbol(), PERIOD_CURRENT, 20, 0, MODE_SMA, PRICE_CLOSE);
            return MathMax(priceSupport, maSupport);
        }
            
        case 3: // Fibonacci support
        {
            double high = iHigh(Symbol(), PERIOD_CURRENT, iHighest(Symbol(), PERIOD_CURRENT, MODE_HIGH, 20, 1));
            double low = iLow(Symbol(), PERIOD_CURRENT, iLowest(Symbol(), PERIOD_CURRENT, MODE_LOW, 20, 1));
            double range = high - low;
            return high - (range * 0.382); // 38.2% Fibonacci level
        }
            
        default:
            return iLow(Symbol(), PERIOD_CURRENT, iLowest(Symbol(), PERIOD_CURRENT, MODE_LOW, lookbackPeriod, 1));
    }
}
bool PriceActionBreakdown()
{
    // Method 1: Break below recent low
    double recentLow = iLow(Symbol(), PERIOD_CURRENT, iLowest(Symbol(), PERIOD_CURRENT, MODE_LOW, 5, 1));
    double currentClose = iClose(Symbol(), PERIOD_CURRENT, 0);
    
    if(currentClose < recentLow)
        return true;
    
    // Method 2: Break below support level with confirmation
    double supportLevel = CalculateSupportLevel();
    if(currentClose < supportLevel && iClose(Symbol(), PERIOD_CURRENT, 1) < iClose(Symbol(), PERIOD_CURRENT, 2))
        return true;
        
    return false;
}
bool VolumeConfirmation()
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö volume spike
    int volumeHandle = iVolumes(Symbol(), PERIOD_CURRENT, VOLUME_TICK);
    double volumeValues[2];
    
    if(CopyBuffer(volumeHandle, 0, 0, 2, volumeValues) < 2)
    {
        IndicatorRelease(volumeHandle);
        return false;
    }
    
    IndicatorRelease(volumeHandle);
    
    // Current volume > 150% of previous volume
    return volumeValues[0] > (volumeValues[1] * 1.5);
}
bool DetectBreakoutSellInVolatileMarket(double volatilityThresholdHigh = 0.008)
{
    // Check for volatility
    double volatility = CalculateVolatility();
    if(volatility < volatilityThresholdHigh)
        return false;
    
    // More aggressive breakout criteria for volatile markets
    double atrValue = CalculateATR(20, 0, Symbol());  // ‡πÉ‡∏ä‡πâ shift = 0
    
    if(iClose(Symbol(), PERIOD_CURRENT, 1) < iLow(Symbol(), PERIOD_CURRENT, 2) - (atrValue * 1.5))
        return true;
    
    // Check for breakdown below recent support with high volume
    if(PriceActionBreakdown() && VolumeConfirmation())
        return true;
        
    return false;
}
bool DetectBreakoutBuyOriginal()
{
    if(!BreakoutStrategy) return false;
    
    // 1. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏£‡∏≤‡∏Ñ‡∏≤‡∏≠‡∏¢‡∏π‡πà‡πÄ‡∏´‡∏ô‡∏∑‡∏≠ resistance ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double resistanceLevel = GetResistanceLevel();
    
    if(currentPrice <= resistanceLevel) 
    {
        if(EnableDebugMode) Print("Price not above resistance level");
        return false;
    }
    
    // 2. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö volume confirmation
    if(!HasBreakoutVolumeConfirmation(true))
    {
        if(EnableDebugMode) Print("No volume confirmation for breakout buy");
        return false;
    }
    
    // 3. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö momentum - ‡πÉ‡∏ä‡πâ GetRSIValue ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì
    double rsi = GetRSIValue(_Symbol, PERIOD_H1, 14, PRICE_CLOSE, 0);
    if(rsi > 70) // ‡πÑ‡∏°‡πà‡∏ã‡∏∑‡πâ‡∏≠‡πÉ‡∏ô overbought
    {
        if(EnableDebugMode) Print("RSI overbought: ", rsi);
        return false;
    }
    
    // 4. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö volatility
    double atr = GetATRValue(_Symbol, PERIOD_H1, 14, 0);
    double atrAvg = GetATRAverage(_Symbol, PERIOD_H1, 14, 20);
    
    if(atr > atrAvg * 2.0) // volatility ‡∏™‡∏π‡∏á‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
    {
        if(EnableDebugMode) Print("High volatility for breakout");
        return false;
    }
    
    // 5. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö candle confirmation
    if(!HasBullishBreakoutCandle())
    {
        if(EnableDebugMode) Print("No bullish breakout candle");
        return false;
    }
    
    if(EnableDebugMode) Print("Breakout BUY signal confirmed");
    return true;
}
double GetSupportLevel()
{
    // ‡∏´‡∏≤ support ‡∏à‡∏≤‡∏Å recent low
    MqlRates rates[20];
    if(CopyRates(_Symbol, PERIOD_H1, 0, 20, rates) < 20) 
        return SymbolInfoDouble(_Symbol, SYMBOL_BID) * 0.99; // default
    
    double lowest = rates[0].low;
    for(int i = 1; i < 20; i++)
    {
        if(rates[i].low < lowest) lowest = rates[i].low;
    }
    
    return lowest;
}
bool HasBreakoutVolumeConfirmation(bool isBuy)
{
    MqlRates rates[3];
    if(CopyRates(_Symbol, PERIOD_H1, 0, 3, rates) < 3) return false;
    
    // ‡πÅ‡∏õ‡∏•‡∏á volume ‡∏à‡∏≤‡∏Å long ‡πÄ‡∏õ‡πá‡∏ô double
    double currentVolume = (double)rates[0].tick_volume;
    double prevVolume1 = (double)rates[1].tick_volume;
    double prevVolume2 = (double)rates[2].tick_volume;
    
    double avgPrevVolume = (prevVolume1 + prevVolume2) / 2.0;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ volume ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢ 2 ‡πÅ‡∏ó‡πà‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if(avgPrevVolume == 0) return true; // ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• volume ‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤
    
    return (currentVolume > avgPrevVolume * 1.5);
}
bool HasBullishBreakoutCandle()
{
    MqlRates rates[2];
    if(CopyRates(_Symbol, PERIOD_H1, 0, 2, rates) < 2) return false;
    
    // ‡πÅ‡∏ó‡πà‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÄ‡∏õ‡πá‡∏ô bullish
    bool currentBullish = (rates[0].close > rates[0].open);
    
    // ‡πÅ‡∏ó‡πà‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô bearish ‡∏´‡∏£‡∏∑‡∏≠ doji
    bool prevBearish = (rates[1].close < rates[1].open);
    bool prevDoji = (MathAbs(rates[1].close - rates[1].open) < 
                     (rates[1].high - rates[1].low) * 0.1);
    
    return currentBullish && (prevBearish || prevDoji);
}
double GetResistanceLevel()
{
    // ‡∏´‡∏≤ resistance ‡∏à‡∏≤‡∏Å recent high
    MqlRates rates[20];
    if(CopyRates(_Symbol, PERIOD_H1, 0, 20, rates) < 20) 
        return SymbolInfoDouble(_Symbol, SYMBOL_BID) * 1.01; // default
    
    double highest = rates[0].high;
    for(int i = 1; i < 20; i++)
    {
        if(rates[i].high > highest) highest = rates[i].high;
    }
    
    return highest;
}
bool DetectBreakoutSellOriginal()
{
    if(!BreakoutStrategy) return false;
    
    // 1. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏£‡∏≤‡∏Ñ‡∏≤‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ï‡πâ support ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double supportLevel = GetSupportLevel();
    
    if(currentPrice >= supportLevel) 
    {
        if(EnableDebugMode) Print("Price not below support level");
        return false;
    }
    
    // 2. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö volume confirmation
    if(!HasBreakoutVolumeConfirmation(false))
    {
        if(EnableDebugMode) Print("No volume confirmation for breakout sell");
        return false;
    }
    
    // 3. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö momentum - ‡πÉ‡∏ä‡πâ GetRSIValue ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì
    double rsi = GetRSIValue(_Symbol, PERIOD_H1, 14, PRICE_CLOSE, 0);
    if(rsi < 30) // ‡πÑ‡∏°‡πà‡∏Ç‡∏≤‡∏¢‡πÉ‡∏ô oversold
    {
        if(EnableDebugMode) Print("RSI oversold: ", rsi);
        return false;
    }
    
    // 4. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö volatility
    double atr = GetATRValue(_Symbol, PERIOD_H1, 14, 0);
    double atrAvg = GetATRAverage(_Symbol, PERIOD_H1, 14, 20);
    
    if(atr > atrAvg * 2.0)
    {
        if(EnableDebugMode) Print("High volatility for breakout");
        return false;
    }
    
    // 5. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö candle confirmation
    if(!HasBearishBreakoutCandle())
    {
        if(EnableDebugMode) Print("No bearish breakout candle");
        return false;
    }
    
    if(EnableDebugMode) Print("Breakout SELL signal confirmed");
    return true;
}
bool HasBearishBreakoutCandle()
{
    MqlRates rates[2];
    if(CopyRates(_Symbol, PERIOD_H1, 0, 2, rates) < 2) return false;
    
    // ‡πÅ‡∏ó‡πà‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÄ‡∏õ‡πá‡∏ô bearish
    bool currentBearish = (rates[0].close < rates[0].open);
    
    // ‡πÅ‡∏ó‡πà‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô bullish ‡∏´‡∏£‡∏∑‡∏≠ doji
    bool prevBullish = (rates[1].close > rates[1].open);
    bool prevDoji = (MathAbs(rates[1].close - rates[1].open) < 
                     (rates[1].high - rates[1].low) * 0.1);
    
    return currentBearish && (prevBullish || prevDoji);
}

bool DetectBreakoutBuyInVolatileMarket()
{
    // ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ confirmation ‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô
    // ‡πÅ‡∏•‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà volatility spike
    
    // 1. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö volatility ‡πÑ‡∏°‡πà‡∏™‡∏π‡∏á‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
    double atr = GetATRValue(_Symbol, PERIOD_H1, 14, 0);
    double atrAvg = GetATRAverage(_Symbol, PERIOD_H1, 14, 20);
    
    if(atr > atrAvg * 2.0) 
    {
        DebugPrint(2, "Too volatile for breakout buy");
        return false;
    }
    
    // 2. ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ volume confirmation
    if(!HasVolumeConfirmation()) 
    {
        DebugPrint(2, "No volume confirmation for breakout in volatile market");
        return false;
    }
    
    // 3. ‡πÉ‡∏ä‡πâ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÄ‡∏î‡∏¥‡∏°
    return DetectBreakoutBuyOriginal();
}
bool DetectBreakoutBuyInCalmMarket()
{
    // ‡πÉ‡∏ô sideways ‡πÄ‡∏á‡∏µ‡∏¢‡∏ö breakout ‡∏≠‡∏≤‡∏à‡πÄ‡∏õ‡πá‡∏ô false signal
    // ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ confirmation ‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ market ‡πÑ‡∏°‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô tight range ‡∏ô‡∏≤‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
    if(IsMarketInTightRange(20, 0.002)) // range ‡πÅ‡∏Ñ‡∏ö‡∏Å‡∏ß‡πà‡∏≤ 20 pips
    {
        DebugPrint(2, "Market in tight range - potential false breakout");
        return false;
    }
    
    return DetectBreakoutBuyOriginal();
}
// Function to check if market is in tight range
bool IsMarketInTightRange(int period, double threshold) 
{
    double high = iHigh(Symbol(), PERIOD_CURRENT, iHighest(Symbol(), PERIOD_CURRENT, MODE_HIGH, period, 1));
    double low = iLow(Symbol(), PERIOD_CURRENT, iLowest(Symbol(), PERIOD_CURRENT, MODE_LOW, period, 1));
    double currentPrice = SymbolInfoDouble(Symbol(), SYMBOL_BID);
    
    // Calculate the range as percentage of current price
    double rangePercentage = (high - low) / currentPrice;
    
    // Check if range is below threshold (e.g., 0.002 = 0.2%)
    return rangePercentage <= threshold;
}
//+------------------------------------------------------------------+
//| Detect Advanced Breakout BUY                                    |
//+------------------------------------------------------------------+
bool DetectAdvancedBreakoutBUY(ENUM_MARKET_REGIME regime = MARKET_REGIME_NORMAL)
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö regime ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏™‡πà‡∏á‡∏°‡∏≤
    if(regime == MARKET_REGIME_NORMAL) 
    {
        regime = DetectMarketRegime();
    }
    
    // üî• ‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç breakout detection ‡∏ï‡∏≤‡∏° regime
    switch(regime)
    {
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            // ‡πÉ‡∏ô breakout potential ‡πÉ‡∏ä‡πâ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏õ‡∏Å‡∏ï‡∏¥
            return DetectBreakoutBuyOriginal();
            
        case MARKET_REGIME_TRENDING_STRONG:
            // ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á breakout ‡∏≠‡∏≤‡∏à‡πÄ‡∏Å‡∏¥‡∏î‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô
            return DetectBreakoutBuyInStrongTrend();
            
        case MARKET_REGIME_RANGING_VOLATILE:
            // ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ confirmation ‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô
            return DetectBreakoutBuyInVolatileMarket();
            
        case MARKET_REGIME_RANGING_CALM:
            // ‡πÉ‡∏ô sideways ‡πÄ‡∏á‡∏µ‡∏¢‡∏ö breakout ‡∏≠‡∏≤‡∏à‡πÄ‡∏õ‡πá‡∏ô false signal
            return DetectBreakoutBuyInCalmMarket();
            
        default:
            return DetectBreakoutBuyOriginal();
    }
}

bool MomentumConfirmation(int method = 1)
{
    switch(method)
    {
        case 1: // RSI confirmation
        {
            int rsiHandle = iRSI(Symbol(), PERIOD_CURRENT, 14, PRICE_CLOSE);
            double rsiValues[2];
            
            if(CopyBuffer(rsiHandle, 0, 0, 2, rsiValues) < 2)
            {
                IndicatorRelease(rsiHandle);
                return false;
            }
            
            IndicatorRelease(rsiHandle);
            // RSI below 40 and declining
            return (rsiValues[0] < 40) && (rsiValues[0] < rsiValues[1]);
        }
        
        case 2: // MACD confirmation
        {
            int macdHandle = iMACD(Symbol(), PERIOD_CURRENT, 12, 26, 9, PRICE_CLOSE);
            double macdValues[2], signalValues[2];
            
            if(CopyBuffer(macdHandle, 0, 0, 2, macdValues) < 2 ||
               CopyBuffer(macdHandle, 1, 0, 2, signalValues) < 2)
            {
                IndicatorRelease(macdHandle);
                return false;
            }
            
            IndicatorRelease(macdHandle);
            // MACD below signal and declining
            return (macdValues[0] < signalValues[0]) && (macdValues[0] < macdValues[1]);
        }
        
        default:
            return true; // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ momentum confirmation
    }
}
bool DetectBreakoutSellInCalmMarket()
{
    // Check for low volatility
    double volatility = CalculateVolatility();
    if(volatility > VOLATILITY_THRESHOLD_LOW) // Define your threshold
        return false;
    
    // More conservative breakout criteria for calm markets
    // Require clearer signals
    if(iClose(Symbol(), PERIOD_CURRENT, 1) < iLow(Symbol(), PERIOD_CURRENT, 10) && 
       iClose(Symbol(), PERIOD_CURRENT, 0) < iClose(Symbol(), PERIOD_CURRENT, 1))
        return true;
    
    // Check for breakdown with momentum confirmation
    if(PriceActionBreakdown() && MomentumConfirmation())
        return true;
        
    return false;
}
bool DetectBreakoutSellInStrongTrend(double trendStrengthThreshold = 25.0)
{
    // 1. Check trend strength with ADX
    double trendStrength = CalculateTrendStrength(DIRECTION_DOWN);
    if(trendStrength < trendStrengthThreshold)
    {
        // Print("Trend strength too weak: ", trendStrength);
        return false;
    }
    
    // 2. Check MA alignment
    double maFast = GetMAValue(Symbol(), PERIOD_CURRENT, 50, 0, MODE_EMA);
    double maSlow = GetMAValue(Symbol(), PERIOD_CURRENT, 200, 0, MODE_EMA);
    
    if(maFast >= maSlow)  // Not in downtrend
    {
        // Print("MA not aligned for downtrend");
        return false;
    }
    
    // 3. Price below both MAs
    double currentClose = iClose(Symbol(), PERIOD_CURRENT, 0);
    if(currentClose >= maFast)  // Price not below fast MA
    {
        // Print("Price not below fast MA");
        return false;
    }
    
    // 4. Break below recent support
    double supportLevel = CalculateSupportLevel(10);
    if(currentClose >= supportLevel)
    {
        // Print("Price not below support level");
        return false;
    }
    
    // 5. Volume confirmation (optional)
    bool volumeOK = VolumeConfirmation();
    
    // 6. Momentum confirmation
    bool momentumOK = MomentumConfirmation();
    
    // Return true if all conditions met (volume optional)
    return momentumOK; // Require at least momentum confirmation
}

//+------------------------------------------------------------------+
//| Detect Advanced Breakout SELL                                   |
//+------------------------------------------------------------------+
bool DetectAdvancedBreakoutSELL(ENUM_MARKET_REGIME regime = MARKET_REGIME_NORMAL)
{
    if(regime == MARKET_REGIME_NORMAL) 
    {
        regime = DetectMarketRegime();
    }
    
    switch(regime)
    {
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            return DetectBreakoutSellOriginal();
            
        case MARKET_REGIME_TRENDING_STRONG:
            return DetectBreakoutSellInStrongTrend();
            
        case MARKET_REGIME_RANGING_VOLATILE:
            return DetectBreakoutSellInVolatileMarket();
            
        case MARKET_REGIME_RANGING_CALM:
            return DetectBreakoutSellInCalmMarket();
            
        default:
            return DetectBreakoutSellOriginal();
    }
}
//+------------------------------------------------------------------+
//| Check Multi-Timeframe Bullish Alignment                         |
//+------------------------------------------------------------------+
bool CheckMultiTimeframeBullish()
{
   bool m5 = IsTrendBullish(PERIOD_M5);
   bool m15 = IsTrendBullish(PERIOD_M15);
   bool m30 = IsTrendBullish(PERIOD_M30);
   
   int bullishCount = 0;
   if(m5) bullishCount++;
   if(m15) bullishCount++;
   if(m30) bullishCount++;
   
   return (bullishCount >= 2);
}

//+------------------------------------------------------------------+
//| Check Multi-Timeframe Bearish Alignment                         |
//+------------------------------------------------------------------+
bool CheckMultiTimeframeBearish()
{
   bool m5 = IsTrendBearish(PERIOD_M5);
   bool m15 = IsTrendBearish(PERIOD_M15);
   bool m30 = IsTrendBearish(PERIOD_M30);
   
   int bearishCount = 0;
   if(m5) bearishCount++;
   if(m15) bearishCount++;
   if(m30) bearishCount++;
   
   return (bearishCount >= 2);
}

//+------------------------------------------------------------------+
//| Check if trend is bullish                                       |
//+------------------------------------------------------------------+
bool IsTrendBullish(ENUM_TIMEFRAMES tf)
{
   double ema20 = iMA(_Symbol, tf, 20, 0, MODE_EMA, PRICE_CLOSE);
   double ema50 = iMA(_Symbol, tf, 50, 0, MODE_EMA, PRICE_CLOSE);
   double currentClose = iClose(_Symbol, tf, 0);
   
   return (ema20 > ema50 && currentClose > ema20);
}

//+------------------------------------------------------------------+
//| Check if trend is bearish                                       |
//+------------------------------------------------------------------+
bool IsTrendBearish(ENUM_TIMEFRAMES tf)
{
   double ema20 = iMA(_Symbol, tf, 20, 0, MODE_EMA, PRICE_CLOSE);
   double ema50 = iMA(_Symbol, tf, 50, 0, MODE_EMA, PRICE_CLOSE);
   double currentClose = iClose(_Symbol, tf, 0);
   
   return (ema20 < ema50 && currentClose < ema20);
}

//+------------------------------------------------------------------+
//| Check Price Breakout BUY                                        |
//+------------------------------------------------------------------+
bool CheckPriceBreakoutBUY()
{
   MqlRates rates[];
   if(CopyRates(_Symbol, BO_Timeframe, 0, 20, rates) != 20) return false;
   
   double resistance = 0;
   for(int i = 1; i <= 5; i++)
   {
      if(rates[i].high > resistance) resistance = rates[i].high;
   }
   
   bool breakResistance = (rates[0].high > resistance);
   bool closeAbove = (rates[0].close > resistance);
   bool bullishCandle = (rates[0].close > rates[0].open);
   
   return (breakResistance && closeAbove && bullishCandle);
}

//+------------------------------------------------------------------+
//| Check Price Breakout SELL                                       |
//+------------------------------------------------------------------+
bool CheckPriceBreakoutSELL()
{
   MqlRates rates[];
   if(CopyRates(_Symbol, BO_Timeframe, 0, 20, rates) != 20) return false;
   
   double support = 999999;
   for(int i = 1; i <= 5; i++)
   {
      if(rates[i].low < support) support = rates[i].low;
   }
   
   bool breakSupport = (rates[0].low < support);
   bool closeBelow = (rates[0].close < support);
   bool bearishCandle = (rates[0].close < rates[0].open);
   
   return (breakSupport && closeBelow && bearishCandle);
}

//+------------------------------------------------------------------+
//| Check Volume Confirmation BUY                                   |
//+------------------------------------------------------------------+
bool CheckVolumeConfirmationBUY()
{
   MqlRates rates[];
   if(CopyRates(_Symbol, BO_Timeframe, 0, 10, rates) != 10) return false;
   
   double avgVolume = 0;
   for(int i = 1; i <= 5; i++)
   {
      avgVolume += (double)rates[i].tick_volume;
   }
   avgVolume /= 5.0;
   
   return ((double)rates[0].tick_volume > avgVolume * 1.2);
}
//+------------------------------------------------------------------+
//| ?????????????????????? Scalp1                                 |
//+------------------------------------------------------------------+
double CalculateSafeScalpLot()
{
   double lot = BaseLot;
   
   // ?????????????????????????????
   int currentPositions = CountPositionsByMagic(MAGIC_SCALP1);
   if(currentPositions >= 2)
   {
      lot = BaseLot * 0.7; // ?????????????????????????
   }
   
   lot = MathMin(lot, MaxLot);
   lot = MathMax(lot, BaseLot);
   
   return NormalizeDouble(lot, 2);
}
//+------------------------------------------------------------------+
//| Check Volume Confirmation SELL                                  |
//+------------------------------------------------------------------+
bool CheckVolumeConfirmationSELL()
{
   MqlRates rates[];
   if(CopyRates(_Symbol, BO_Timeframe, 0, 10, rates) != 10) return false;
   
   double avgVolume = 0;
   for(int i = 1; i <= 5; i++)
   {
      avgVolume += (double)rates[i].tick_volume;
   }
   avgVolume /= 5.0;
   
   return ((double)rates[0].tick_volume > avgVolume * 1.2);
}

//+------------------------------------------------------------------+
//| Check Breakout Strength BUY                                     |
//+------------------------------------------------------------------+
bool CheckBreakoutStrengthBUY()
{
   MqlRates rates[];
   if(CopyRates(_Symbol, BO_Timeframe, 0, 10, rates) != 10) return false;
   
   double atr = CalculateATR(14, 0, _Symbol);
   double breakoutSize = rates[0].high - rates[1].high;
   
   return (breakoutSize >= atr * MinBreakoutStrength);
}

//+------------------------------------------------------------------+
//| Check Breakout Strength SELL                                    |
//+------------------------------------------------------------------+
bool CheckBreakoutStrengthSELL()
{
   MqlRates rates[];
   if(CopyRates(_Symbol, BO_Timeframe, 0, 10, rates) != 10) return false;
   
   double atr = CalculateATR(14, 0, _Symbol);
   double breakoutSize = rates[1].low - rates[0].low;
   
   return (breakoutSize >= atr * MinBreakoutStrength);
}

//+------------------------------------------------------------------+
//| Update Strategy Profits - Fixed Version                        |
//+------------------------------------------------------------------+
void UpdateStrategyProfits()
{
   
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         long magic = PositionGetInteger(POSITION_MAGIC);
         double profit = PositionGetDouble(POSITION_PROFIT);
         
         if(magic == MAGIC_SCALP2)
         {
            scalp2TotalProfit += profit;
         }
         else if(magic == MAGIC_SCALP3)
         {
            scalp3TotalProfit += profit;
         }
         else if(magic == MAGIC_RECOVERY)
         {
            recoveryTotalProfit += profit;
         }
         else if(magic == MAGIC_BREAKOUT)
         {
            breakoutTotalProfit += profit;
         }
      }
   }
}

//+------------------------------------------------------------------+
//| ExecuteScalp2 - Fixed Version                                  |
//+------------------------------------------------------------------+
void ExecuteScalp2()
{


   if(!Scalp2Enabled) 
   {
      DebugPrint(3, "Scalp2 disabled - skipping");
      return;
   }
   
  
   
   //-----------check debug-----------------//
   // üîç DEBUG START
    Print("=== üéØ SCALP2 DEBUG START ===");
    Print("1. Scalp2Enabled: ", Scalp2Enabled);
    Print("2. scalp2TotalProfit: ", scalp2TotalProfit);
    Print("3. Target: ", Scalp2_TargetProfit);
    Print("4. MinLossToHelp: ", MinLossToHelp);
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            long magic = PositionGetInteger(POSITION_MAGIC);
            double profit = PositionGetDouble(POSITION_PROFIT);
            Print("Position ", i, ": Magic=", magic, " | Profit=", profit);
        }
    }
    Print("=== üéØ SCALP2 DEBUG END ===");
    // üîç DEBUG END
   //-----------check debug-----------------//
   
   UpdateStrategyProfits();
   if(scalp2TotalProfit >= Scalp2_TargetProfit)
   {
      DebugPrint(2, "Scalp2 target reached: $" + DoubleToString(scalp2TotalProfit, 2));
      return;
   }
   
   ulong worstTicket = 0;
   double worstProfit = 0;
   ENUM_POSITION_TYPE worstType = (ENUM_POSITION_TYPE)WRONG_VALUE_CONST;
   double worstVolume = 0;
   
   int total = (int)PositionsTotal();
   for(int i = 0; i < total; i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0 && PositionSelectByTicket(ticket))
      {
         long magic = PositionGetInteger(POSITION_MAGIC);
         if(magic == MAGIC_SCALP2 || magic == MAGIC_HEDGE) 
            continue;
            
         double profit = PositionGetDouble(POSITION_PROFIT);
         
         if(profit <= -MinLossToHelp && profit < worstProfit)
         {
            worstProfit = profit;
            worstTicket = ticket;
            worstType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            worstVolume = PositionGetDouble(POSITION_VOLUME);
         }
      }
   }
   
   if(worstTicket == 0) 
   {
      DebugPrint(3, "No positions need help (min loss: $" + DoubleToString(MinLossToHelp, 2) + ")");
      return;
   }
   
   if(WaitNewBarForScalp2 && !newBar) 
   {
      DebugPrint(3, "Waiting for new bar for Scalp2");
      return;
   }
   
   double helpLot = CalculateScalp2HelpLot(worstVolume, worstProfit);
   
   if(!CheckMargin(helpLot)) 
   {
      DebugPrint(1, "Insufficient margin for Scalp2: " + DoubleToString(helpLot, 2));
      return;
   }
   
   trade.SetExpertMagicNumber(MAGIC_SCALP2);
   
   if(worstType == POSITION_TYPE_BUY)
   {
      double tpPrice = GetTPPriceUniversal(false, Scalp2_TP_Points);
      if(trade.Sell(helpLot, _Symbol, 0, 0, tpPrice, "Scalp2-Help-BUY"))
      {
         Print("?? SCALP2 HELP SELL | Ticket: " + TicketToStr(worstTicket) +
               " | Loss: $" + DoubleToString(worstProfit, 2) + 
               " | Lot: " + DoubleToString(helpLot, 2) + " | TP: " + IntegerToString(Scalp2_TP_Points) + "pips");
      }
   }
   else if(worstType == POSITION_TYPE_SELL)
   {
      double tpPrice = GetTPPriceUniversal(true, Scalp2_TP_Points);
      if(trade.Buy(helpLot, _Symbol, 0, 0, tpPrice, "Scalp2-Help-SELL"))
      {
         Print("?? SCALP2 HELP BUY | Ticket: " + TicketToStr(worstTicket) +
               " | Loss: $" + DoubleToString(worstProfit, 2) + 
               " | Lot: " + DoubleToString(helpLot, 2) + " | TP: " + IntegerToString(Scalp2_TP_Points) + "pips");
      }
   }
}

//+------------------------------------------------------------------+
//| Calculate Scalp2 Help Lot - FIXED Lot Version                 |
//+------------------------------------------------------------------+
double CalculateScalp2HelpLot(double baseVolume, double lossAmount)
{
   double helpLot;
   
   if(UseFixedLot) {
      helpLot = MaxHelpLot;
   } else {
      helpLot = baseVolume * Current_Scalp2_LotMultiplier;  // ‚úÖ ‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÉ‡∏´‡∏°‡πà
   }
   
   helpLot = MathMin(helpLot, MaxHelpLot);
   helpLot = MathMax(helpLot, MinHelpLot);
   
   if(lossAmount < -15.0) {
      helpLot = MathMin(helpLot, baseVolume * 0.7);
   }
   
   return NormalizeDouble(helpLot, 2);
}

int CountHelperPositions()
{
   int count = 0;
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         long magic = PositionGetInteger(POSITION_MAGIC);
         if(IsHelperPosition(magic))
            count++;
      }
   }
   return count;
}
void PrintMagicNumbersStatus()
{
   Print("=== MAGIC NUMBERS STATUS ===");
   Print("Scalp1: " + IntegerToString(MAGIC_SCALP1));
   Print("Scalp2: " + IntegerToString(MAGIC_SCALP2)); 
   Print("Scalp3: " + IntegerToString(MAGIC_SCALP3));
   Print("Recovery: " + IntegerToString(MAGIC_RECOVERY));
   Print("Individual: " + IntegerToString(MAGIC_INDIVIDUAL));
   Print("Orphan: " + IntegerToString(MAGIC_ORPHAN));
   Print("Hedge: " + IntegerToString(MAGIC_HEDGE));
   Print("Counter: " + IntegerToString(MAGIC_COUNTER));
   Print("Breakout: " + IntegerToString(MAGIC_BREAKOUT));
}
//+------------------------------------------------------------------+
//| ?????????????????????????????????????                         |
//+------------------------------------------------------------------+
bool IsHelperPosition(long magic)
{
    return (magic == MAGIC_SCALP3 || magic == MAGIC_RECOVERY || 
            magic == MAGIC_HEDGE || magic == MAGIC_COUNTER ||
            magic == MAGIC_INDIVIDUAL || magic == MAGIC_ORPHAN); // ? ????? Magic ????
}

//+------------------------------------------------------------------+
//| ???????????????????????????????????????                      |
//+------------------------------------------------------------------+
int CountHelpForMain(ulong mainTicket)
{
    int count = 0;
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            long magic = PositionGetInteger(POSITION_MAGIC);
            string comment = PositionGetString(POSITION_COMMENT);
            
            if(magic == MAGIC_SCALP3 && StringFind(comment, TicketToStr(mainTicket)) != -1)
            {
                count++;
            }
        }
    }
    return count;
}

//+------------------------------------------------------------------+
//| ???????????????????????????????????                         |
//+------------------------------------------------------------------+
ulong FindHelpNeededPosition()
{
    // üîç DEBUG START
    Print("=== üîç FIND HELP DEBUG ===");
    ulong bestCandidate = 0;
    double bestScore = 0;
    int qualifiedCount = 0;
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            long magic = PositionGetInteger(POSITION_MAGIC);
            double profit = PositionGetDouble(POSITION_PROFIT);
            
            Print("Check Ticket ", ticket, ": Magic=", magic, " | Profit=", profit);
            
            if(profit <= -localScalp3Trigger)
            {
                qualifiedCount++;
                double score = CalculateHelpScore(ticket, profit, 0, _Symbol, TimeCurrent());
                Print("‚úÖ QUALIFIED - Score: ", score);
                if(score > bestScore)
                {
                    bestScore = score;
                    bestCandidate = ticket;
                }
            }
        }
    }
    Print("Total Qualified: ", qualifiedCount, " | Best Candidate: ", bestCandidate);
    Print("=== üîç FIND HELP DEBUG END ===");
    // üîç DEBUG END
    
    return bestCandidate;
}

//+------------------------------------------------------------------+
//| ??????????????????????????                                    |
//+------------------------------------------------------------------+
double GetSymbolVolatility(string symbol)
{
    double atr = CalculateATR(14, 0, symbol);
    double currentPrice = SymbolInfoDouble(symbol, SYMBOL_BID);
    return (atr / currentPrice) * 100;
}

//+------------------------------------------------------------------+
//| ?????????????????????? (????????)                           |
//+------------------------------------------------------------------+
double CalculateHelpScore(ulong ticket, double profit, double volume, string symbol, double currentTime)
{
    double score = 0;
    
    // 1. ????????? = ??????????? (??????????)
    score += MathAbs(profit) * 15;
    
    // 2. ???????? = ???????????  
    score += volume * 120;
    
    // 3. ??????????????? = ???????????
    datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
    double hoursOpen = (currentTime - (double)openTime) / 3600.0;
    score += hoursOpen * 8;
    
    // 4. ????????????????????? (?????????????????)
    double volatility = GetSymbolVolatility(symbol);
    score += volatility * 50;
    
    return score;
}

//+------------------------------------------------------------------+
//| ?????????????? (????????????, ????? SL)                     |
//+------------------------------------------------------------------+
bool ShouldCloseScalp3Pair(ulong mainTicket, ulong helpTicket, double mainProfit, double helpProfit, double pairProfit, string symbol = NULL)
{
    // 1. ????????????????????
    if(Close_OnTarget && pairProfit >= Scalp3_TargetProfit)
    {
        DebugPrint(1, "Closing pair: Target profit reached");
        return true;
    }
    
   
    if(Close_OnBreakEven && mainProfit >= 0)
    {
        DebugPrint(1, "Closing pair: Main position break-even");
        return true;
    }
    
    /*
    // 3. ??????????????????????? (80% ?????????????)
   if(Close_OnHelpProfit && helpProfit >= MathAbs(mainProfit) * 0.8 && helpProfit > 1.0)
    {
        DebugPrint(1, "Closing pair: Help profit covers main loss");
        return true;
    }
    
    // 4. ???????????? + ?????????????????????
    if(Close_OnReversal && pairProfit > 0.3 && IsStrongReversalSignal(symbol))
    {
        DebugPrint(1, "Closing pair: Strong reversal signal");
        return true;
    }
   
   */
    
    return false;
}

//+------------------------------------------------------------------+
//| ????????????????????????????????                            |
//+------------------------------------------------------------------+
bool IsStrongReversalSignal(string symbol = NULL)
{
    string sym = (symbol == NULL) ? _Symbol : symbol;
    
    double rsi = iRSI(sym, PERIOD_M1, 14, PRICE_CLOSE);
    MqlRates rates[];
    
    if(CopyRates(sym, PERIOD_M1, 0, 3, rates) == 3)
    {
        bool bullishReversal = (rates[1].close < rates[1].open && rates[0].close > rates[0].open);
        bool bearishReversal = (rates[1].close > rates[1].open && rates[0].close < rates[0].open);
        
        if((bullishReversal && rsi < 30) || (bearishReversal && rsi > 70))
            return true;
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| ???????????? Scalp3 - ?????????????????                      |
//+------------------------------------------------------------------+
void ManageScalp3Pairs()
{
   // --- Fallback thresholds (‡∏´‡∏ô‡πà‡∏ß‡∏¢‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏Å‡∏∏‡∏•‡πÄ‡∏á‡∏¥‡∏ô‡∏ö‡∏±‡∏ç‡∏ä‡∏µ) ---
   // ‡∏´‡∏≤‡∏Å‡∏Ñ‡∏∏‡∏ì‡∏°‡∏µ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ global inputs ‡∏ä‡∏∑‡πà‡∏≠ Scalp3_PairCloseProfit / Scalp3_PairCloseLoss
   // ‡πÉ‡∏´‡πâ‡∏•‡∏ö‡∏™‡∏≠‡∏á‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ global ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏ó‡∏ô
   double pairCloseProfit = 10.0; // ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á: ‡∏õ‡∏¥‡∏î‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏£‡∏ß‡∏°‡∏Å‡∏≥‡πÑ‡∏£ >= $10
   double pairCloseLoss   = 50.0; // ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á: ‡∏õ‡∏¥‡∏î‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏£‡∏ß‡∏°‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô <= -$50

   // --- Prepare indicator handles and read EMA(50) on M5 and ATR(14) on M5 ---
   int emaPeriod = 50;
   int atrPeriod = 14;

   int emaHandle = iMA(_Symbol, PERIOD_M5, emaPeriod, 0, MODE_EMA, PRICE_CLOSE);
   if(emaHandle == INVALID_HANDLE)
   {
      DebugPrint(1, "ManageScalp3Pairs: Failed to get EMA handle");
      return;
   }
   double emaBuf[];
   if(CopyBuffer(emaHandle, 0, 0, 1, emaBuf) <= 0)
   {
      DebugPrint(1, "ManageScalp3Pairs: CopyBuffer EMA failed");
      IndicatorRelease(emaHandle);
      return;
   }
   double emaM5 = emaBuf[0];
   IndicatorRelease(emaHandle);

   int atrHandle = iATR(_Symbol, PERIOD_M5, atrPeriod);
   if(atrHandle == INVALID_HANDLE)
   {
      DebugPrint(1, "ManageScalp3Pairs: Failed to get ATR handle");
      return;
   }
   double atrBuf[];
   if(CopyBuffer(atrHandle, 0, 0, 1, atrBuf) <= 0)
   {
      DebugPrint(1, "ManageScalp3Pairs: CopyBuffer ATR failed");
      IndicatorRelease(atrHandle);
      return;
   }
   double atrM5 = atrBuf[0];
   IndicatorRelease(atrHandle);

   // --- Iterate positions to find Scalp3 HELP positions that reference MAIN ---
   int total = PositionsTotal();
   for(int idx = total - 1; idx >= 0; idx--)
   {
      ulong ticket = PositionGetTicket(idx);
      if(ticket == 0) continue;

      if(!PositionSelectByTicket(ticket))
      {
         DebugPrint(2, "ManageScalp3Pairs: cannot select ticket " + TicketToStr(ticket));
         continue;
      }

      long magic = (long)PositionGetInteger(POSITION_MAGIC);
      if(magic != MAGIC_SCALP3) continue;

      string comment = PositionGetString(POSITION_COMMENT);
      ulong mainTicket = ExtractMainTicketFromComment(comment);
      if(mainTicket == 0)
      {
         DebugPrint(3, "ManageScalp3Pairs: HELP " + TicketToStr(ticket) + " has no mainTicket in comment -> skip");
         continue;
      }

      // read help profit (position currently selected)
      double helpProfit = PositionGetDouble(POSITION_PROFIT);

      // read main profit by selecting mainTicket explicitly
      double mainProfit = 0.0;
      if(PositionSelectByTicket(mainTicket))
      {
         mainProfit = PositionGetDouble(POSITION_PROFIT);
      }
      else
      {
         DebugPrint(1, "ManageScalp3Pairs: MAIN ticket " + TicketToStr(mainTicket) + " referenced by HELP " + TicketToStr(ticket) + " NOT FOUND -> skip");
         continue;
      }

      double pairProfit = helpProfit + mainProfit;
      DebugPrint(2, StringFormat("ManageScalp3Pairs: HELP %s (%.2f) MAIN %s (%.2f) => pairProfit=%.2f",
                                TicketToStr(ticket), helpProfit, TicketToStr(mainTicket), mainProfit, pairProfit));

      // Decide close condition using local pairCloseProfit / pairCloseLoss
      if(pairProfit >= pairCloseProfit || pairProfit <= -pairCloseLoss)
      {
         DebugPrint(2, "ManageScalp3Pairs: Pair close triggered for MAIN " + TicketToStr(mainTicket) + " / HELP " + TicketToStr(ticket) + " | pairProfit=" + DoubleToString(pairProfit,2));

         bool helpClosed = false;
         bool mainClosed = false;

         // Close HELP first
         if(PositionSelectByTicket(ticket))
         {
            helpClosed = trade.PositionClose(ticket);
            if(!helpClosed)
               DebugPrint(1, "ManageScalp3Pairs: Failed to close HELP " + TicketToStr(ticket) + " | rc=" + IntegerToString(trade.ResultRetcode()));
            else
               DebugPrint(2, "ManageScalp3Pairs: HELP closed " + TicketToStr(ticket));
         }
         else
         {
            helpClosed = true; // already not present
            DebugPrint(3, "ManageScalp3Pairs: HELP already gone " + TicketToStr(ticket));
         }

         // Close MAIN
         if(PositionSelectByTicket(mainTicket))
         {
            mainClosed = trade.PositionClose(mainTicket);
            if(!mainClosed)
               DebugPrint(1, "ManageScalp3Pairs: Failed to close MAIN " + TicketToStr(mainTicket) + " | rc=" + IntegerToString(trade.ResultRetcode()));
            else
               DebugPrint(2, "ManageScalp3Pairs: MAIN closed " + TicketToStr(mainTicket));
         }
         else
         {
            mainClosed = true;
            DebugPrint(3, "ManageScalp3Pairs: MAIN already gone " + TicketToStr(mainTicket));
         }

         if(!helpClosed || !mainClosed)
            DebugPrint(1, "ManageScalp3Pairs: Closing pair incomplete for MAIN " + TicketToStr(mainTicket) + " / HELP " + TicketToStr(ticket));
         else
            DebugPrint(1, "ManageScalp3Pairs: Pair successfully closed for MAIN " + TicketToStr(mainTicket) + " / HELP " + TicketToStr(ticket) + " | pairProfit=" + DoubleToString(pairProfit,2));
      } // end if close condition
   } // end for positions
}

//+------------------------------------------------------------------+
//| ?????????????????? (?????)                                  |
//+------------------------------------------------------------------+
double CalculateSimpleHelpLot(double baseVolume, double mainLoss)
{
    double multiplier = localScalp3Multiplier;
    
    double lossAmount = MathAbs(mainLoss);
    if(lossAmount > 8.0) multiplier *= 1.3;
    if(lossAmount > 15.0) multiplier *= 1.5;
    
    double helpLot = baseVolume * multiplier;
    helpLot = MathMin(helpLot, MaxLot);
    helpLot = MathMax(helpLot, baseVolume * 1.2);
    
    return NormalizeDouble(helpLot, 2);
}

//+------------------------------------------------------------------+
//| ??? ticket ???????????????????????                          |
//+------------------------------------------------------------------+
ulong GetMainTicketFromHelp(string symbol)
{
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            long magic = PositionGetInteger(POSITION_MAGIC);
            if(magic != MAGIC_SCALP3 && !IsHelperPosition(magic))
                return ticket;
        }
    }
    return 0;
}

//+------------------------------------------------------------------+
//| ???????????????????????????                                  |
//+------------------------------------------------------------------+
double GetMaxLot(string symbol)
{
    return MaxLot;
}

//+------------------------------------------------------------------+
//| ?????????????????????????????                                |
//+------------------------------------------------------------------+
double NormalizeLot(double lot, string symbol)
{
    double minLot = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MIN);
    double maxLot = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MAX);
    double step = SymbolInfoDouble(symbol, SYMBOL_VOLUME_STEP);
    
    lot = MathMax(lot, minLot);
    lot = MathMin(lot, maxLot);
    lot = MathRound(lot / step) * step;
    
    return NormalizeDouble(lot, 2);
}

//+------------------------------------------------------------------+
//| ?????????????????? (????????)                               |
//+------------------------------------------------------------------+
double CalculateOptimalHelpLot(double baseVolume, double mainLoss, string symbol, ENUM_POSITION_TYPE type)
{
    double multiplier = localScalp3Multiplier;
    double lossAmount = MathAbs(mainLoss);
    
    if(lossAmount > 8.0) multiplier *= 1.3;
    if(lossAmount > 15.0) multiplier *= 1.5;
    if(lossAmount > 25.0) multiplier *= 1.8;
    
    ulong mainTicket = GetMainTicketFromHelp(symbol);
    if(mainTicket > 0 && PositionSelectByTicket(mainTicket))
    {
        double currentPrice = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(symbol, SYMBOL_BID) : SymbolInfoDouble(symbol, SYMBOL_ASK);
        double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        double distance = MathAbs(currentPrice - openPrice) / SymbolInfoDouble(symbol, SYMBOL_POINT);
        
        if(distance > 300) multiplier *= 1.3;
        if(distance > 500) multiplier *= 1.5;
    }
    
    double helpLot = baseVolume * multiplier;
    helpLot = MathMin(helpLot, GetMaxLot(symbol));
    helpLot = MathMax(helpLot, baseVolume * 1.2);
    
    return NormalizeLot(helpLot, symbol);
}

//+------------------------------------------------------------------+
//| ??????????? Scalp3 ???????????                                |
//+------------------------------------------------------------------+
int CountScalp3Pairs()
{
    int count = 0;
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket) && PositionGetInteger(POSITION_MAGIC) == MAGIC_SCALP3)
            count++;
    }
    return count;
}

//+------------------------------------------------------------------+
//| ???????????????????????????????????????????                   |
//+------------------------------------------------------------------+
bool HasScalp3Help(ulong mainTicket)
{
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket) && PositionGetInteger(POSITION_MAGIC) == MAGIC_SCALP3)
        {
            string comment = PositionGetString(POSITION_COMMENT);
            if(StringFind(comment, IntegerToString((int)mainTicket)) >= 0)
                return true;
        }
    }
    return false;
}

//+------------------------------------------------------------------+
//| ???????????????????????????                                  |
//+------------------------------------------------------------------+
void RecordHelpOperation(ulong mainTicket, ulong helpTicket, double lot)
{
    scalp3HelpOperations++;
    DebugPrint(1, "Help operation recorded: Main=" + TicketToStr(mainTicket) + 
                  ", Help=" + TicketToStr(helpTicket) + ", Lot=" + DoubleToString(lot, 2));
}

//+------------------------------------------------------------------+
//| ????????????? Scalp3 (?????? SL/TP)                          |
//+------------------------------------------------------------------+
void OpenScalp3Help(ulong mainTicket)
{
    if(!PositionSelectByTicket(mainTicket)) return;
    
    double mainVolume = PositionGetDouble(POSITION_VOLUME);
    double mainProfit = PositionGetDouble(POSITION_PROFIT);
    ENUM_POSITION_TYPE mainType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
    string symbol = PositionGetString(POSITION_SYMBOL);
    
    if(HasScalp3Help(mainTicket)) 
    {
        DebugPrint(3, "Scalp3 help already exists for: " + TicketToStr(mainTicket));
        return;
    }
    
    if(CountScalp3Pairs() >= Scalp3_MaxActivePairs)
    {
        DebugPrint(2, "Max Scalp3 pairs reached: " + IntegerToString(Scalp3_MaxActivePairs));
        return;
    }
    
    if(Scalp3_UseSignal)
    {
        ENUM_SIGNAL_STRENGTH signal = GetOptimalSignalForHelp(mainType, symbol);
        if(signal < SIGNAL_MEDIUM)
        {
            DebugPrint(2, "Scalp3 signal too weak: " + GetSignalStrengthName(signal));
            return;
        }
    }
    
    double helpLot = CalculateOptimalHelpLot(mainVolume, mainProfit, symbol, mainType);
    
    if(!CheckMargin(helpLot, symbol)) 
    {
        DebugPrint(1, "Scalp3 margin insufficient: " + DoubleToString(helpLot, 2));
        return;
    }
    
    trade.SetExpertMagicNumber(MAGIC_SCALP3);
    string comment = "SCALP3-HELP-" + IntegerToString((int)mainTicket);
    
    bool success = false;
    
    if(mainType == POSITION_TYPE_BUY)
    {
        success = trade.Sell(helpLot, symbol, 0, 0, 0, comment);
    }
    else
    {
        success = trade.Buy(helpLot, symbol, 0, 0, 0, comment);
    }
    
    if(success)
    {
        string direction = (mainType == POSITION_TYPE_BUY) ? "SELL" : "BUY";
        Print("?? SCALP3 HELP OPENED | Main: " + TicketToStr(mainTicket) +
              " | Loss: $" + DoubleToString(mainProfit, 2) +
              " | " + direction + " Lot: " + DoubleToString(helpLot, 2) +
              " | Target: $" + DoubleToString(Scalp3_TargetProfit, 2));
              
        RecordHelpOperation(mainTicket, trade.ResultOrder(), helpLot);
    }
    else
    {
        DebugPrint(1, "Scalp3 help failed: " + trade.ResultRetcodeDescription());
    }
}

//+------------------------------------------------------------------+
//| Execute Scalp3 Integrated -               |
//+------------------------------------------------------------------+
void ExecuteScalp3Integrated()
{
 if(!Scalp3_Enabled) return;
    
    // ---------------üîç DEBUG START---------------//
    Print("=== üéØ SCALP3 DEBUG START ===");
    Print("1. Scalp3_Enabled: ", Scalp3_Enabled);
    
    ulong helpTicket = FindHelpNeededPosition();  // ‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏î‡∏¥‡∏°
    Print("2. Found Help Ticket: ", helpTicket);
    
    if(helpTicket > 0)
    {
        PositionSelectByTicket(helpTicket);
        double profit = PositionGetDouble(POSITION_PROFIT);
        Print("3. Help Needed - Ticket: ", helpTicket, " | Profit: ", profit);
        Print("4. Trigger Level: ", localScalp3Trigger);
    }
    else
    {
        Print("3. No help ticket found - checking conditions...");
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
        for(int i = 0; i < PositionsTotal(); i++)
        {
            ulong ticket = PositionGetTicket(i);
            if(PositionSelectByTicket(ticket))
            {
                double profit = PositionGetDouble(POSITION_PROFIT);
                Print("   Ticket ", ticket, ": Profit=", profit, " | Trigger=", -localScalp3Trigger);
            }
        }
    }
    Print("=== üéØ SCALP3 DEBUG END ===");
    //--------------- üîç DEBUG END----------------------//
    
    ManageScalp3Pairs();
    
    //ulong helpTicket = FindHelpNeededPosition();
    if(helpTicket == 0) return;
    
    OpenScalp3Help(helpTicket);
}

//+------------------------------------------------------------------+
//| Find Worst Position For Help - USD Based                       |
//+------------------------------------------------------------------+
ulong FindWorstPosition()
{
    ulong worstTicket = 0;
    double worstProfit = 0;
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            long magic = PositionGetInteger(POSITION_MAGIC);
            // ?????????????????????
            if(IsHelperPosition(magic)) continue;
            
            double profit = PositionGetDouble(POSITION_PROFIT);
            if(profit < worstProfit)
            {
                worstProfit = profit;
                worstTicket = ticket;
            }
        }
    }
    
    return worstTicket;
}

//+------------------------------------------------------------------+
//| Count positions by Magic Number                              |
//+------------------------------------------------------------------+
int CountPositionsByMagic(long magicNumber)
{
   int count = 0;
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         // ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡∏ô‡∏µ‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏£‡∏±‡∏ö parameter
         if(PositionGetInteger(POSITION_MAGIC) == magicNumber)
            count++;
      }
   }
   return count;
}

//+------------------------------------------------------------------+
//| Get signal strength name                                        |
//+------------------------------------------------------------------+
string GetSignalStrengthName(ENUM_SIGNAL_STRENGTH strength)
{
    switch(strength)
    {
        case SIGNAL_STRONG: return "STRONG";
        case SIGNAL_MEDIUM: return "MEDIUM";
        case SIGNAL_WEAK: return "WEAK";
        default: return "NONE";
    }
}

//+------------------------------------------------------------------+
//| ??????? Volume Spike                                          |
//+------------------------------------------------------------------+
bool CheckVolumeSpike(bool isBuy)
{
   MqlRates rates[];
   if(CopyRates(_Symbol, PERIOD_M1, 0, 10, rates) != 10) return false;
   
   double avgVolume = 0;
   for(int i = 1; i <= 5; i++)
      avgVolume += (double)rates[i].tick_volume;
   avgVolume /= 5.0;
   
   return ((double)rates[0].tick_volume > avgVolume * 1.5);
}

//+------------------------------------------------------------------+
//| ????????? Buy ?????? Scalp3                                 |
//+------------------------------------------------------------------+
ENUM_SIGNAL_STRENGTH GetScalp3BuySignalStrength()
{
   int score = 0;
   
   MqlRates current_rates[];
   if(CopyRates(_Symbol, PERIOD_M1, 0, 5, current_rates) == 5)
   {
      if(current_rates[1].close < current_rates[1].open && current_rates[0].close > current_rates[0].open)
         score += 25;
      
      double candleSize = (current_rates[0].close - current_rates[0].open) / (current_rates[0].high - current_rates[0].low);
      if(candleSize > 0.6) score += 15;
   }
   
   double current_rsi = iRSI(_Symbol, PERIOD_M1, 9, PRICE_CLOSE);
   
   if(current_rsi > 30 && current_rsi < 45) score += 40;
   
   double emaFast = iMA(_Symbol, PERIOD_M1, 5, 0, MODE_EMA, PRICE_CLOSE);
   double emaSlow = iMA(_Symbol, PERIOD_M1, 15, 0, MODE_EMA, PRICE_CLOSE);
   if(SymbolInfoDouble(_Symbol, SYMBOL_ASK) > emaFast && emaFast > emaSlow)
      score += 20;
   
   if(score >= 70) return SIGNAL_STRONG;
   if(score >= 50) return SIGNAL_MEDIUM;
   if(score >= 30) return SIGNAL_WEAK;
   return SIGNAL_NONE;
}

//+------------------------------------------------------------------+
//| ????????? Sell ?????? Scalp3                                |
//+------------------------------------------------------------------+
ENUM_SIGNAL_STRENGTH GetScalp3SellSignalStrength()
{
   int score = 0;
   
   MqlRates current_rates[];
   if(CopyRates(_Symbol, PERIOD_M1, 0, 5, current_rates) == 5)
   {
      if(current_rates[1].close > current_rates[1].open && current_rates[0].close < current_rates[0].open)
         score += 25;
      
      double candleSize = (current_rates[0].open - current_rates[0].close) / (current_rates[0].high - current_rates[0].low);
      if(candleSize > 0.6) score += 15;
   }
   
   double current_rsi = iRSI(_Symbol, PERIOD_M1, 9, PRICE_CLOSE);
   
   if(current_rsi > 65 && current_rsi < 80) score += 40;
   
   double emaFast = iMA(_Symbol, PERIOD_M1, 5, 0, MODE_EMA, PRICE_CLOSE);
   double emaSlow = iMA(_Symbol, PERIOD_M1, 15, 0, MODE_EMA, PRICE_CLOSE);
   if(SymbolInfoDouble(_Symbol, SYMBOL_BID) < emaFast && emaFast < emaSlow)
      score += 20;
   
   if(score >= 70) return SIGNAL_STRONG;
   if(score >= 50) return SIGNAL_MEDIUM;
   if(score >= 30) return SIGNAL_WEAK;
   return SIGNAL_NONE;
}

// +------------------------------------------------------------------+
//| Extract Main Ticket From Comment                                |
//+------------------------------------------------------------------+
ulong ExtractMainTicketFromComment(string comment)
{
    // ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö Comment: "Recovery-123456" ‡∏´‡∏£‡∏∑‡∏≠ "Individual-Recov-123456"
    int startPos = -1;
    
    if(StringFind(comment, "Recovery-") != -1)
    {
        startPos = StringFind(comment, "Recovery-") + 9;
    }
    else if(StringFind(comment, "Individual-Recov-") != -1)
    {
        startPos = StringFind(comment, "Individual-Recov-") + 17;
    }
    else if(StringFind(comment, "Indiv-Recov-") != -1)
    {
        startPos = StringFind(comment, "Indiv-Recov-") + 12;
    }
    
    if(startPos != -1)
    {
        string ticketStr = StringSubstr(comment, startPos);
        // ‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á '-' ‡∏ï‡πà‡∏≠‡πÑ‡∏õ (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
        int endPos = StringFind(ticketStr, "-");
        if(endPos != -1)
        {
            ticketStr = StringSubstr(ticketStr, 0, endPos);
        }
        return StringToInteger(ticketStr);
    }
    
    return 0;
}
//+------------------------------------------------------------------+
//| ?????? Scalp3 ????????                                      |
//+------------------------------------------------------------------+
bool CloseScalp3Pair(ulong mainTicket, ulong helpTicket)
{
    bool mainClosed = false;
    bool helpClosed = false;
    
    if(PositionSelectByTicket(helpTicket))
    {
        string symbol = PositionGetString(POSITION_SYMBOL);
        double volume = PositionGetDouble(POSITION_VOLUME);
        ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        
        trade.SetExpertMagicNumber(MAGIC_SCALP3);
        if(type == POSITION_TYPE_BUY)
            helpClosed = trade.Sell(volume, symbol, 0, 0, 0, "SCALP3-CLOSE");
        else
            helpClosed = trade.Buy(volume, symbol, 0, 0, 0, "SCALP3-CLOSE");
    }
    
    if(PositionSelectByTicket(mainTicket))
    {
        mainClosed = true;
    }
    
    return (mainClosed && helpClosed);
}

//+------------------------------------------------------------------+
//| Manage Scalp3 Pair Closing                                      |
//+------------------------------------------------------------------+
void ManageScalp3PairClosing()
{
   for(int i = PositionsTotal()-1; i >= 0; i--)
   {
      ulong helpTicket = PositionGetTicket(i);
      if(!PositionSelectByTicket(helpTicket)) continue;
      
      // 1. ‡∏Å‡∏£‡∏≠‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå Scalp3
      if(PositionGetInteger(POSITION_MAGIC) == MAGIC_SCALP3)
      {
         // 2. ‡∏≠‡πà‡∏≤‡∏ô Comment ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏≤ Main Ticket
         string comment = PositionGetString(POSITION_COMMENT);
         ulong mainTicket = ExtractMainTicketFromComment(comment);
         
         // 3. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Main ‡∏¢‡∏±‡∏á‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
         if(mainTicket > 0 && PositionSelectByTicket(mainTicket))
         {
            // 4. ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Å‡∏≥‡πÑ‡∏£‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏π‡πà
            double helpProfit = PositionGetDouble(POSITION_PROFIT);
            double mainProfit = PositionGetDouble(POSITION_PROFIT);
            double pairProfit = helpProfit + mainProfit;
            
            // 5. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏õ‡∏¥‡∏î
            if(pairProfit >= Scalp3_TargetProfit || 
               (mainProfit >= 0 && helpProfit > 0) ||
               pairProfit >= MathAbs(mainProfit) * 0.8)
            {
               CloseScalp3Pair(mainTicket, helpTicket);
            }
         }
      }
   }
}
//+------------------------------------------------------------------+
//| Check if market is good for Scalp3                             |
//+------------------------------------------------------------------+
bool IsMarketGoodForScalp3()
{
   double atr = CalculateATR(14, 0, _Symbol);
   double atrPercent = (atr / SymbolInfoDouble(_Symbol, SYMBOL_BID)) * 100;
   
   if(atrPercent < 0.05 || atrPercent > 0.3) 
   {
      DebugPrint(3, "Scalp3: ATR not suitable - " + DoubleToString(atrPercent, 3) + "%");
      return false;
   }
   
   double spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) * _Point;
   double spreadPips = spread / GetPipSize(_Symbol);
   
   if(spreadPips > 2.0) 
   {
      DebugPrint(3, "Scalp3: Spread too high - " + DoubleToString(spreadPips, 1) + " pips");
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| ?????????????????????????????????                               |
//+------------------------------------------------------------------+
bool IsTradingAllowed()
{
    if(accountInfo.Equity() < MinEquityToTrade) 
    {
        static datetime lastWarning = 0;
        if(TimeCurrent() - lastWarning > 60)
        {
            Print("? TRADING STOPPED: Equity $" + DoubleToString(accountInfo.Equity(), 2) + 
                  " below minimum $" + DoubleToString(MinEquityToTrade, 2));
            lastWarning = TimeCurrent();
        }
        return false;
    }
    return true;
}

//+------------------------------------------------------------------+
//| ????????? Buy ?????? Scalp3                                 |
//+------------------------------------------------------------------+
bool GetScalp3BuySignal()
{
   double ema5 = iMA(_Symbol, PERIOD_M1, 5, 0, MODE_EMA, PRICE_CLOSE);
   double ema10 = iMA(_Symbol, PERIOD_M1, 10, 0, MODE_EMA, PRICE_CLOSE);
   double rsi = iRSI(_Symbol, PERIOD_M1, 14, PRICE_CLOSE);
   
   return (ema5 > ema10 && rsi > 30 && rsi < 70);
}

//+------------------------------------------------------------------+
//| Helper Functions - Add missing implementations                  |
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//| Calculate ATR - Fixed implementation                           |
//+------------------------------------------------------------------+
double CalculateATR(int period = 14, int shift = 0, string symbol = NULL)
{
    if(symbol == NULL || symbol == "") symbol = Symbol();
    
    int atrHandle = iATR(symbol, PERIOD_CURRENT, period);
    if(atrHandle == INVALID_HANDLE)
    {
        Print("Error creating ATR indicator");
        return 0;
    }
    
    double atrValue[1];
    if(CopyBuffer(atrHandle, 0, shift, 1, atrValue) < 1)
    {
        IndicatorRelease(atrHandle);
        return 0;
    }
    
    IndicatorRelease(atrHandle);
    return atrValue[0];
}
//+------------------------------------------------------------------+
//| Calculate Risk Pressure - Fixed implementation                 |
//+------------------------------------------------------------------+
double CalculateRiskPressure()
{
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   if(balance <= 0) return 0;
   double drawdown = (balance - equity) / balance;
   return MathMin(drawdown / (MaxDrawdownPercent / 100.0), 2.0);
}
double CalculateEnhancedRiskPressure() {
    double basePressure = CalculateRiskPressure(); // ‡πÉ‡∏ä‡πâ‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Volatility Pressure
    double atr = iATR(_Symbol, PERIOD_H1, 14);
    double atrPercent = (atr / SymbolInfoDouble(_Symbol, SYMBOL_BID)) * 100;
    double volatilityPressure = MathMin(atrPercent / 0.2, 1.0);
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Position Pressure
    int totalPositions = PositionsTotal();
    double positionPressure = MathMin((double)totalPositions / MathMax(MaxTotalPositions, 1), 1.0);
    
    return (basePressure + volatilityPressure + positionPressure) / 3.0;
}
//----------------Adaptive Strategy Selection-----------//
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠


void ExecuteRangeCalmStrategy(ENUM_MARKET_REGIME regime = MARKET_REGIME_NORMAL)
{
    // Now you can use 'regime' parameter
    if(regime == MARKET_REGIME_RANGING_CALM)
    {
        // Execute calm range strategy
    }
    else if(regime == MARKET_REGIME_RANGING_VOLATILE)
    {
        // Execute volatile range strategy
    }
}
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏µ‡πà‡∏£‡∏ß‡∏°‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á
void ExecuteStrategy(ENUM_MARKET_REGIME regime)
{
    switch(regime)
    {
        case MARKET_REGIME_RANGING_CALM:
            // Execute calm range strategy
            // ExecuteRangeCalmStrategy();
            break;
            
        case MARKET_REGIME_RANGING_VOLATILE:
            // Execute volatile range strategy  
            // ExecuteRangeVolatileStrategy();
            break;
            
        case MARKET_REGIME_TRENDING_STRONG:
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
        case MARKET_REGIME_NORMAL:
        default:
            ExecuteBreakoutStrategy();
            break;
    }
}
// ===== BREAKOUT STRATEGY EXECUTION =====
void ExecuteBreakoutStrategy(ENUM_MARKET_REGIME regime = MARKET_REGIME_NORMAL)
{
    // Only trade during market hours (optional)
    if(!IsTradingTime()) 
        return;
    
    // Check if we already have an open position
    if(HasOpenPosition())
    {
        // Manage existing position
        ManageOpenPosition();
        return;
    }
    
    // Use regime to adjust strategy
    double riskMultiplier = 1.0;
    
    switch(regime)
    {
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            riskMultiplier = 1.2; // More aggressive
            break;
            
        case MARKET_REGIME_TRENDING_STRONG:
            riskMultiplier = 1.0; // Normal
            break;
            
        case MARKET_REGIME_RANGING_VOLATILE:
            riskMultiplier = 0.5; // Less aggressive
            break;
            
        case MARKET_REGIME_RANGING_CALM:
            riskMultiplier = 0.3; // Conservative
            return; // Or don't trade in calm range
            
        case MARKET_REGIME_NORMAL:
        default:
            riskMultiplier = 1.0;
            break;
    }
    
    // Detect breakout signal with regime parameter
    bool sellSignal = DetectAdvancedBreakoutSELL(regime);
    bool buySignal = false; // You can add DetectAdvancedBreakoutBUY(regime) if you have it
    
    // Execute based on signal
    if(sellSignal)
    {
        ExecuteBreakoutSell(riskMultiplier);
    }
    else if(buySignal)
    {
        ExecuteBreakoutBuy(riskMultiplier);
    }
}
// ===== SPECIFIC TRADE EXECUTION =====
void ExecuteBreakoutSell(double riskMultiplier = 1.0)
{
    double entryPrice = SymbolInfoDouble(Symbol(), SYMBOL_BID);
    double baseStopLossPips = 50;
    double baseTakeProfitPips = 100;
    double baseLotSize = 0.1;
    
    double stopLossPips = baseStopLossPips / riskMultiplier;
    double takeProfitPips = baseTakeProfitPips * riskMultiplier;
    double lotSize = baseLotSize * riskMultiplier;
    
    double stopLoss = entryPrice + (stopLossPips * Point());
    double takeProfit = entryPrice - (takeProfitPips * Point());
    
    Print("SELL Signal: Entry=", entryPrice,
          " SL=", stopLoss, " (", stopLossPips, " pips)",
          " TP=", takeProfit, " (", takeProfitPips, " pips)",
          " LotSize=", lotSize,
          " RiskMultiplier=", riskMultiplier);
}

void ExecuteBreakoutBuy(double riskMultiplier = 1.0)
{
    // Trading parameters
    double entryPrice = SymbolInfoDouble(Symbol(), SYMBOL_ASK);
    double baseStopLossPips = 50;
    double baseTakeProfitPips = 100;
    double baseLotSize = 0.1;
    
    // Adjust based on risk multiplier
    double stopLossPips = baseStopLossPips / riskMultiplier;
    double takeProfitPips = baseTakeProfitPips * riskMultiplier;
    double lotSize = baseLotSize * riskMultiplier;
    
    double stopLoss = entryPrice - (stopLossPips * Point());
    double takeProfit = entryPrice + (takeProfitPips * Point());
    
    Print("BUY Signal: Entry=", entryPrice,
          " SL=", stopLoss, " (", stopLossPips, " pips)",
          " TP=", takeProfit, " (", takeProfitPips, " pips)",
          " LotSize=", lotSize,
          " RiskMultiplier=", riskMultiplier);
    
    // Order execution code here
    // OrderSend(Symbol(), OP_BUY, lotSize, entryPrice, 3, stopLoss, takeProfit, 
    //           "Breakout Buy", 0, 0, clrGreen);
}

// ===== HELPER FUNCTIONS =====
bool IsTradingTime()
{
    // Check if current time is within trading hours
    // Example: trade only between 9 AM and 5 PM
    MqlDateTime timeStruct;
    TimeCurrent(timeStruct);
    
    return (timeStruct.hour >= 9 && timeStruct.hour < 17);
}

bool HasOpenPosition()
{
    // Check for open positions
    // This is a simple check - you need to implement properly
    return false;
}

void ManageOpenPosition()
{
    // Manage existing position (trailing stop, etc.)
}
void ExecuteBreakoutStrategyByRegime(ENUM_MARKET_REGIME regime)
{
    // Check if we should execute breakout strategy
    bool shouldExecute = false;
    
    switch(regime)
    {
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
        case MARKET_REGIME_TRENDING_STRONG:
        case MARKET_REGIME_NORMAL:
            shouldExecute = true;
            break;
            
        case MARKET_REGIME_RANGING_CALM:
        case MARKET_REGIME_RANGING_VOLATILE:
            // Usually avoid breakout in ranging markets
            shouldExecute = false;
            break;
    }
    
    if(shouldExecute)
    {
        ExecuteBreakoutStrategy();  // Call the original function
    }
}
// ===== VOLATILE RANGE STRATEGY =====
void ExecuteRangeVolatileStrategy(ENUM_MARKET_REGIME regime = MARKET_REGIME_RANGING_VOLATILE)
{
    // Only execute if regime is volatile range
    if(regime != MARKET_REGIME_RANGING_VOLATILE)
        return;
    
    // Check trading conditions
    if(!IsTradingTime() || HasOpenPosition())
        return;
    
    // Use tighter stops and smaller position size for volatile markets
    double riskMultiplier = 0.5; // Half the normal risk
    
    // Check for trading signals
    bool sellSignal = DetectBreakoutSellInVolatileMarket();
    // bool buySignal = DetectBreakoutBuyInVolatileMarket(); // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
    
    if(sellSignal)
    {
        // Execute with adjusted parameters for volatility
        ExecuteRangeVolatileSell(riskMultiplier);
    }
    // else if(buySignal) ...
}

void ExecuteRangeVolatileSell(double riskMultiplier = 0.5)
{
    // Trading parameters for volatile market
    double entryPrice = SymbolInfoDouble(Symbol(), SYMBOL_BID);
    double baseStopLossPips = 30; // Tighter stop
    double baseTakeProfitPips = 60; // Smaller target
    double baseLotSize = 0.05; // Smaller position
    
    double stopLoss = entryPrice + (baseStopLossPips * Point());
    double takeProfit = entryPrice - (baseTakeProfitPips * Point());
    double lotSize = baseLotSize * riskMultiplier;
    
    Print("Volatile Range SELL: Entry=", entryPrice,
          " SL=", stopLoss, " TP=", takeProfit,
          " LotSize=", lotSize);
    
    // Order execution
    // OrderSend(Symbol(), OP_SELL, lotSize, entryPrice, 3, stopLoss, takeProfit, 
    //           "Volatile Range Sell", 0, 0, clrRed);
}
// Get all Bollinger Bands at once
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤ Bollinger Bands
bool GetBollingerBands(string symbol, ENUM_TIMEFRAMES tf, int period, 
                       double deviation, int shift, 
                       double &upper, double &middle, double &lower)
{
    int handle = iBands(symbol, tf, period, 0, deviation, PRICE_CLOSE);
    if(handle == INVALID_HANDLE) return false;
    
    double upperArr[1], middleArr[1], lowerArr[1];
    
    bool success = (CopyBuffer(handle, 1, shift, 1, upperArr) >= 1 &&
                    CopyBuffer(handle, 0, shift, 1, middleArr) >= 1 &&
                    CopyBuffer(handle, 2, shift, 1, lowerArr) >= 1);
    
    IndicatorRelease(handle);
    
    if(success)
    {
        upper = upperArr[0];
        middle = middleArr[0];
        lower = lowerArr[0];
    }
    
    return success;
}
void ExecuteTrendWeakStrategy(ENUM_MARKET_REGIME regime)
{
    // 1. ‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ
    double upperBand, lowerBand, currentPrice, bandWidth;
    
    // 2. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô
    if(!IsTradingTime() || HasOpenPosition())
        return;
    
    // 3. ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô (‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡πâ‡∏ß)
    upperBand = GetUpperBollingerBand(20, 2.0, 0);
    lowerBand = GetLowerBollingerBand(20, 2.0, 0);
    
    // 4. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ñ‡πà‡∏≤ valid
    if(upperBand <= 0 || lowerBand <= 0)
        return;
    
    // 5. ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
    currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    // 6. ‡∏ï‡∏£‡∏£‡∏Å‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î
    bandWidth = (upperBand - lowerBand) / currentPrice;
    
    if(currentPrice >= upperBand && bandWidth > 0.01)
    {
        Print("SELL: Price at upper Bollinger Band");
    }
    else if(currentPrice <= lowerBand && bandWidth > 0.01)
    {
        Print("BUY: Price at lower Bollinger Band");
    }
}
// ‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡∏ó‡∏µ‡πà‡∏™‡πà‡∏ß‡∏ô‡∏ö‡∏ô‡∏Ç‡∏≠‡∏á‡πÑ‡∏ü‡∏•‡πå
double GetUpperBollingerBand(int period = 20, double deviation = 2.0, int shift = 0)
{
    int handle = iBands(_Symbol, _Period, period, 0, deviation, PRICE_CLOSE);
    if(handle == INVALID_HANDLE) return 0;
    
    double value[1];
    bool success = CopyBuffer(handle, 1, shift, 1, value) >= 1;
    IndicatorRelease(handle);
    
    return success ? value[0] : 0;
}

double GetLowerBollingerBand(int period = 20, double deviation = 2.0, int shift = 0)
{
    int handle = iBands(_Symbol, _Period, period, 0, deviation, PRICE_CLOSE);
    if(handle == INVALID_HANDLE) return 0;
    
    double value[1];
    bool success = CopyBuffer(handle, 2, shift, 1, value) >= 1;
    IndicatorRelease(handle);
    
    return success ? value[0] : 0;
}
void ExecuteAdaptiveStrategy(ENUM_MARKET_REGIME regime = MARKET_REGIME_NORMAL) 
{
    if(regime == MARKET_REGIME_NORMAL) 
    {
        // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏™‡πà‡∏á regime ‡∏°‡∏≤ ‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡πÉ‡∏´‡∏°‡πà
        regime = DetectMarketRegime();
    }
    
    switch(regime) 
    {
        case MARKET_REGIME_TRENDING_STRONG:
            Print("Market: TRENDING STRONG - Using aggressive trend strategy");
            if(ShouldOpenPosition("TrendStrong", 0, NULL, regime)) 
                ExecuteSimpleTrendScalp(regime);
            break;
            
        case MARKET_REGIME_RANGING_CALM:
            Print("Market: RANGING CALM - Reduced trading activity");
            if(ShouldOpenPosition("RangeCalm", 0, NULL, regime) && GetMarketScore() > 70) 
            {
                ExecuteRangeCalmStrategy(regime);
            }
            break;
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            Print("Market: BREAKOUT POTENTIAL - Preparing for breakout");
            if(ShouldOpenPosition("Breakout", 0, NULL, regime)) 
            {
                ExecuteBreakoutStrategy(regime);
            }
            break;
            
        case MARKET_REGIME_RANGING_VOLATILE:
            Print("Market: RANGING VOLATILE - Using tight stop strategy");
            if(ShouldOpenPosition("RangeVolatile", 0, NULL, regime)) 
            {
                ExecuteRangeVolatileStrategy(regime);
            }
            break;
            
        case MARKET_REGIME_TRENDING_WEAK:
            Print("Market: TRENDING WEAK - Using conservative trend strategy");
            if(ShouldOpenPosition("TrendWeak", 0, NULL, regime)) 
            {
                ExecuteTrendWeakStrategy(regime);
            }
            break;
            
        case MARKET_REGIME_NORMAL:
        default:
            Print("Market: NORMAL - Using standard strategies");
            ExecuteNormalStrategy(regime);
            break;
    }
}
void ExecuteNormalStrategy(ENUM_MARKET_REGIME regime = MARKET_REGIME_NORMAL)
{
    // Only execute if regime is normal
    if(regime != MARKET_REGIME_NORMAL)
    {
        // For other regimes, use appropriate strategy
        switch(regime)
        {
            case MARKET_REGIME_TRENDING_STRONG:
                ExecuteBreakoutStrategy(regime);
                break;
            case MARKET_REGIME_RANGING_CALM:
                ExecuteRangeCalmStrategy();
                break;
            case MARKET_REGIME_RANGING_VOLATILE:
                // ExecuteRangeVolatileStrategy(regime);
                break;
            case MARKET_REGIME_BREAKOUT_POTENTIAL:
                ExecuteBreakoutStrategy(regime);
                break;
        }
        return;
    }
    
    // Normal regime trading logic
    Print("Executing NORMAL market strategy");
    
    // Balanced approach: mix of breakout and range trading
    if(DetectAdvancedBreakoutSELL(regime))
    {
        // Execute with moderate risk
        ExecuteBreakoutSell(0.8); // 80% of normal risk
    }
    // Add other signals as needed
}

void ResetRecoveryToDefault()
{
    // ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤ default ‡∏à‡∏≤‡∏Å input
    currentRecoveryMultiplier = localRecoveryMultiplier;
    currentMaxRecovery = localMaxRecovery;
    currentEnableCounterPosition = EnableCounterPosition;
    
    // ‡∏õ‡∏¥‡∏î‡πÇ‡∏´‡∏°‡∏î‡∏û‡∏¥‡πÄ‡∏®‡∏©‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    EnableAggressiveRecovery(false);
    EnableConservativeRecovery(false);
    EnableQuickRecovery(false);
    EnablePassiveRecovery(false);
    EnableOpportunisticRecovery(false);
    
    Print("   üîÑ Recovery settings reset to default");
}
void AdjustStrategyByMomentum(double momentum)
{
    if(momentum > 10) {
        // ‡πÇ‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡∏±‡∏°‡∏ö‡∏ß‡∏Å‡∏ä‡∏±‡∏î ‚Üí ‡πÄ‡∏ô‡πâ‡∏ô‡∏ó‡∏µ‡∏° Buy
        AssignTeamWeights(40, 20, 25, 10, 5);
        Print("   üü¢ Momentum positive - Focusing on BUY teams");
    } else if(momentum < -10) {
        // ‡πÇ‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡∏±‡∏°‡∏•‡∏ö‡∏ä‡∏±‡∏î ‚Üí ‡πÄ‡∏ô‡πâ‡∏ô‡∏ó‡∏µ‡∏° Sell
        AssignTeamWeights(20, 40, 25, 10, 5);
        Print("   üî¥ Momentum negative - Focusing on SELL teams");
    } else {
        // ‡πÇ‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡∏±‡∏°‡∏™‡∏°‡∏î‡∏∏‡∏• ‚Üí ‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡πÄ‡∏ó‡πà‡∏≤‡πÜ ‡∏Å‡∏±‡∏ô
        AssignTeamWeights(30, 25, 20, 15, 10);
        Print("   ‚öñÔ∏è Balanced momentum - Equal team distribution");
    }
}
//---------------- Performance Feedback -----------//
// ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å CalculateTotalProfit() ‡πÅ‡∏•‡∏∞‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
void AdaptiveParameterAdjustment(ENUM_MARKET_REGIME regime = MARKET_REGIME_NORMAL) 
{
    double totalProfit = CalculateTotalProfit();
    double winRate = CalculateWinRate(); // ‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ
    
    // ‡∏õ‡∏£‡∏±‡∏ö‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏ï‡∏≤‡∏° Performance ‡πÅ‡∏•‡∏∞ Market Regime
    switch(regime) 
    {
        case MARKET_REGIME_TRENDING_STRONG:
            // ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏° aggression ‡πÑ‡∏î‡πâ
            if(totalProfit > 0 && winRate > 0.55) 
            {
                Current_Scalp1_Lot_Multiplier = MathMin(Current_Scalp1_Lot_Multiplier * 1.15, 2.5);
                Print("üìà Strong trend - Increasing aggression: ", Current_Scalp1_Lot_Multiplier);
            }
            break;
            
        case MARKET_REGIME_RANGING_VOLATILE:
            // ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô ‡∏•‡∏î aggression
            Current_Scalp1_Lot_Multiplier = MathMax(Current_Scalp1_Lot_Multiplier * 0.7, 0.5);
            Print("‚ö†Ô∏è Volatile market - Reducing aggression: ", Current_Scalp1_Lot_Multiplier);
            break;
            
        case MARKET_REGIME_RANGING_CALM:
            // ‡πÉ‡∏ô sideways ‡πÄ‡∏á‡∏µ‡∏¢‡∏ö ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏õ‡∏Å‡∏ï‡∏¥
            Current_Scalp1_Lot_Multiplier = MathMax(Current_Scalp1_Lot_Multiplier, 0.8);
            Print("üòê Calm market - Normal aggression: ", Current_Scalp1_Lot_Multiplier);
            break;
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            // ‡∏£‡∏∞‡∏ß‡∏±‡∏á‡πÉ‡∏ô breakout ‡∏•‡∏î lot
            Current_Scalp1_Lot_Multiplier = MathMax(Current_Scalp1_Lot_Multiplier * 0.6, 0.4);
            Print("üéØ Breakout potential - Conservative aggression: ", Current_Scalp1_Lot_Multiplier);
            break;
            
        case MARKET_REGIME_TRENDING_WEAK:
            // ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏≠‡πà‡∏≠‡∏ô ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á
            Current_Scalp1_Lot_Multiplier = MathMin(MathMax(Current_Scalp1_Lot_Multiplier, 0.7), 1.3);
            Print("üìä Weak trend - Moderate aggression: ", Current_Scalp1_Lot_Multiplier);
            break;
            
        case MARKET_REGIME_NORMAL:
        default:
            // ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° Performance
            if(winRate < 0.4) 
            {
                // ‡∏•‡∏î Aggression
                Current_Scalp1_Lot_Multiplier = MathMax(Current_Scalp1_Lot_Multiplier * 0.8, 0.3);
                Print("üìâ Reducing aggression due to low win rate: ", winRate);
            }
            
            if(totalProfit > 0 && winRate > 0.6) 
            {
                // ‡πÄ‡∏û‡∏¥‡πà‡∏° Aggression ‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
                Current_Scalp1_Lot_Multiplier = MathMin(Current_Scalp1_Lot_Multiplier * 1.1, 2.0);
                Print("üìà Slightly increasing aggression due to good performance");
            }
            break;
    }
    
    // ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ñ‡πà‡∏≤ min/max
    Current_Scalp1_Lot_Multiplier = MathMax(Current_Scalp1_Lot_Multiplier, 0.1);
    Current_Scalp1_Lot_Multiplier = MathMin(Current_Scalp1_Lot_Multiplier, 3.0);
}

// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Win Rate ‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏°‡∏µ
double CalculateWinRate() {
    int totalTrades = 0;
    int winningTrades = 0;
    
    for(int i = PositionsTotal()-1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket)) {
            double profit = PositionGetDouble(POSITION_PROFIT);
            if(profit != 0) { // ‡πÑ‡∏°‡πà‡∏ô‡∏±‡∏ö‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà
                totalTrades++;
                if(profit > 0) winningTrades++;
            }
        }
    }
    
    return (totalTrades > 0) ? (double)winningTrades / totalTrades : 0.5;
}
//+------------------------------------------------------------------+
//| Check Margin - Fixed implementation                            |
//+------------------------------------------------------------------+
bool CheckMargin(double lot, string symbol = NULL)
{
   string sym = (symbol == NULL) ? _Symbol : symbol;
   double freeMargin = AccountInfoDouble(ACCOUNT_MARGIN_FREE);
   if(freeMargin <= 0) return false;
   
   double marginRequired = 0;
   if(!OrderCalcMargin(ORDER_TYPE_BUY, sym, lot, SymbolInfoDouble(sym, SYMBOL_ASK), marginRequired))
   {
      double contractSize = SymbolInfoDouble(sym, SYMBOL_TRADE_CONTRACT_SIZE);
      double leverage = (double)AccountInfoInteger(ACCOUNT_LEVERAGE);
      marginRequired = (lot * contractSize) / leverage;
   }
   
   return (marginRequired < freeMargin * 0.8);
}


//+------------------------------------------------------------------+
//| Count Positions By Type - Fixed implementation                 |
//+------------------------------------------------------------------+
int CountPositionsByType(ENUM_POSITION_TYPE type)
{
   int count = 0;
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         if(PositionGetInteger(POSITION_TYPE) == type)
            count++;
      }
   }
   return count;
}

double CalculateSellPositionsProfit()
{
    double profit = 0;
    for(int i = 0; i < PositionsTotal(); i++) {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket) && PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL) {
            profit += PositionGetDouble(POSITION_PROFIT);
        }
    }
    return profit;
}
//+------------------------------------------------------------------+
//| Get Optimal Signal For Help                                     |
//+------------------------------------------------------------------+
ENUM_SIGNAL_STRENGTH GetOptimalSignalForHelp(ENUM_POSITION_TYPE mainType, string symbol)
{
   if(mainType == POSITION_TYPE_BUY)
      return GetScalp3SellSignalStrength();
   else
      return GetScalp3BuySignalStrength();
}

//+------------------------------------------------------------------+
//| Open Ultimate Recovery                                          |
//+------------------------------------------------------------------+
void OpenUltimateRecovery(double aggression)
{
   if(!IsRecoveryAllowed()) 
   {
      DebugPrint(2, "Ultimate Recovery not allowed");
      return;
   }
   
   if(recoveryLayerCount >= localMaxSteps) 
   {
      Print("?? Maximum ultimate recovery steps reached: " + IntegerToString(recoveryLayerCount));
      return;
   }
   
   double totalLoss = CalculateTotalPortfolioLoss();
   double dynamicTrigger = RecoveryTrigger / (aggression * 0.8);
   
   if(totalLoss > -dynamicTrigger) 
   {
      DebugPrint(3, "Loss not sufficient for ultimate recovery: $" + DoubleToString(totalLoss, 2));
      return;
   }
   
   double recoveryLot = CalculateDynamicRecoveryLot(recoveryLayerCount + 1) * aggression;
   recoveryLot = MathMin(recoveryLot, MaxRecoveryLot);
   recoveryLot = MathMax(recoveryLot, RecoveryStartLot);
   
   if(!CheckMargin(recoveryLot)) 
   {
      Print("? Margin insufficient for ultimate recovery: " + DoubleToString(recoveryLot, 2));
      return;
   }
   
   ENUM_POSITION_TYPE mainType = GetMainPositionType();
   if(mainType == (ENUM_POSITION_TYPE)WRONG_VALUE_CONST)
   {
      Print("? No main position found for ultimate recovery");
      return;
   }
   
   trade.SetExpertMagicNumber(MAGIC_RECOVERY);
   bool success = false;
   string comment = "Ultimate-Recovery-" + IntegerToString(recoveryLayerCount + 1) + 
                    "-Agg" + DoubleToString(aggression, 1);
   
   if(mainType == POSITION_TYPE_BUY) 
   {
      success = trade.Sell(recoveryLot, _Symbol, 0, 0, 0, comment);
   } 
   else if(mainType == POSITION_TYPE_SELL)
   {
      success = trade.Buy(recoveryLot, _Symbol, 0, 0, 0, comment);
   }
   
   if(success) 
   {
      recoveryLayerCount++;
      lastRecoveryTime = TimeCurrent();
      fightingTradesCount++;
      
      Print("?? ULTIMATE RECOVERY STEP " + IntegerToString(recoveryLayerCount) + 
            " | Aggression: " + DoubleToString(aggression, 1) +
            " | Lot: " + DoubleToString(recoveryLot, 2) +
            " | Equity: $" + DoubleToString(accountInfo.Equity(), 2));
   }
}

//+------------------------------------------------------------------+
//| Execute Emergency Counter Attack                                |
//+------------------------------------------------------------------+
void ExecuteEmergencyCounterAttack()
{
   if(!UltimateFightingMode || currentFightingPhase < 3) 
   {
      DebugPrint(3, "Emergency counter attack not available in current phase");
      return;
   }
   
   double currentEquity = accountInfo.Equity();
   double currentBalance = accountInfo.Balance();
   if(currentBalance <= 0) return;
   
   double drawdownPercent = (currentBalance - currentEquity) / currentBalance * 100.0;
   
   if(drawdownPercent < 40.0) 
   {
      DebugPrint(3, "Drawdown not severe enough for emergency counter: " + DoubleToString(drawdownPercent, 1) + "%");
      return;
   }
   
   // Find worst performing position
   ulong worstTicket = 0;
   double worstProfit = 0;
   ENUM_POSITION_TYPE worstType = (ENUM_POSITION_TYPE)WRONG_VALUE_CONST;
   double worstVolume = 0;
   string worstSymbol = "";
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         long magic = PositionGetInteger(POSITION_MAGIC);
         if(IsHelperPosition(magic)) continue;
         
         double profit = PositionGetDouble(POSITION_PROFIT);
         if(profit < worstProfit)
         {
            worstProfit = profit;
            worstTicket = ticket;
            worstType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            worstVolume = PositionGetDouble(POSITION_VOLUME);
            worstSymbol = PositionGetString(POSITION_SYMBOL);
         }
      }
   }
   
   if(worstTicket == 0) return;
   
   double emergencyLot = worstVolume * 2.5; // Very aggressive
   emergencyLot = MathMin(emergencyLot, MaxLot);
   emergencyLot = MathMax(emergencyLot, BaseLot * 3);
   
   if(!CheckMargin(emergencyLot, worstSymbol))
   {
      Print("? Margin insufficient for emergency counter: " + DoubleToString(emergencyLot, 2));
      return;
   }
   
   trade.SetExpertMagicNumber(MAGIC_COUNTER);
   bool success = false;
   string comment = "Emergency-Counter-" + TicketToStr(worstTicket);
   
   if(worstType == POSITION_TYPE_BUY)
   {
      success = trade.Sell(emergencyLot, worstSymbol, 0, 0, 0, comment);
   }
   else if(worstType == POSITION_TYPE_SELL)
   {
      success = trade.Buy(emergencyLot, worstSymbol, 0, 0, 0, comment);
   }
   
   if(success)
   {
      Print("?? EMERGENCY COUNTER ATTACK! | Main: #" + TicketToStr(worstTicket) +
            " | Loss: $" + DoubleToString(worstProfit, 2) +
            " | Counter Lot: " + DoubleToString(emergencyLot, 2) +
            " | Phase: " + IntegerToString(currentFightingPhase));
   }
}

//+------------------------------------------------------------------+
//| Check Phase Transition                                          |
//+------------------------------------------------------------------+
void CheckPhaseTransition()
{
   if(!UltimateFightingMode) return;
   
   double currentEquity = accountInfo.Equity();
   double currentBalance = accountInfo.Balance();
   if(currentBalance <= 0) return;
   
   double drawdownPercent = (currentBalance - currentEquity) / currentBalance * 100.0;
   int newPhase = currentFightingPhase;
   
   // Check for phase upgrades
   if(drawdownPercent >= Phase5Trigger && currentFightingPhase < 5)
      newPhase = 5;
   else if(drawdownPercent >= Phase4Trigger && currentFightingPhase < 4)
      newPhase = 4;
   else if(drawdownPercent >= Phase3Trigger && currentFightingPhase < 3)
      newPhase = 3;
   else if(drawdownPercent >= Phase2Trigger && currentFightingPhase < 2)
      newPhase = 2;
   else if(drawdownPercent >= Phase1Trigger && currentFightingPhase < 1)
      newPhase = 1;
   
   // Check for phase downgrades (recovery)
   double phaseProgress = (currentEquity - phaseStartEquity) / MathAbs(phaseStartEquity) * 100.0;
   if(phaseProgress >= 20.0 && currentFightingPhase > 0)
   {
      newPhase = MathMax(0, currentFightingPhase - 1);
      Print("?? PHASE DOWNGRADE | Recovery: " + DoubleToString(phaseProgress, 1) + "%");
   }
   
   if(newPhase != currentFightingPhase)
   {
      currentFightingPhase = newPhase;
      phaseStartEquity = currentEquity;
      phaseStartTime = TimeCurrent();
      
      if(currentFightingPhase > 0)
      {
         Print("?? ULTIMATE FIGHTING PHASE " + IntegerToString(currentFightingPhase) + " | " +
               "Drawdown: " + DoubleToString(drawdownPercent, 1) + "% | " +
               "Aggression: " + DoubleToString(GetPhaseAggression(currentFightingPhase), 1));
      }
      else
      {
         Print("?? EXITING ULTIMATE FIGHTING MODE | Full Recovery Achieved!");
         ResetRecoverySystem();
      }
   }
}





//+------------------------------------------------------------------+
//| Monitor Recovery Performance                                    |
//+------------------------------------------------------------------+
void MonitorRecoveryPerformance()
{
   static datetime lastMonitorTime = 0;
   if(TimeCurrent() - lastMonitorTime < 300) return; // Check every 5 minutes
   
   lastMonitorTime = TimeCurrent();
   
   if(recoveryLayerCount == 0) 
   {
      DebugPrint(3, "No active recovery to monitor");
      return;
   }
   
   double currentEquity = accountInfo.Equity();
   double recoveryEffectiveness = 0;
   
   if(recoveryHistory[0].openEquity != 0)
   {
      recoveryEffectiveness = (currentEquity - recoveryHistory[0].openEquity) / MathAbs(recoveryHistory[0].openEquity) * 100.0;
   }
   
   int activeRecoveryPositions = 0;
   double totalRecoveryProfitCurrent = 0;
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         if(PositionGetInteger(POSITION_MAGIC) == MAGIC_RECOVERY)
         {
            activeRecoveryPositions++;
            totalRecoveryProfitCurrent += PositionGetDouble(POSITION_PROFIT);
         }
      }
   }
   
   // Performance assessment
   string performanceStatus = "POOR";
   if(recoveryEffectiveness > 10.0) performanceStatus = "EXCELLENT";
   else if(recoveryEffectiveness > 5.0) performanceStatus = "GOOD";
   else if(recoveryEffectiveness > 0) performanceStatus = "FAIR";
   else if(recoveryEffectiveness > -5.0) performanceStatus = "WEAK";
   
   Print("=== RECOVERY PERFORMANCE MONITOR ===");
   Print("Effectiveness: " + DoubleToString(recoveryEffectiveness, 1) + "% | Status: " + performanceStatus);
   Print("Active Recovery Positions: " + IntegerToString(activeRecoveryPositions));
   Print("Total Recovery Profit: $" + DoubleToString(totalRecoveryProfitCurrent, 2));
   Print("Recovery Steps: " + IntegerToString(recoveryLayerCount));
   Print("Successful Recoveries: " + IntegerToString(successfulRecoveries));
   Print("Failed Recoveries: " + IntegerToString(failedRecoveryCount));
   
   // Auto-adjust based on performance
   if(performanceStatus == "POOR" && recoveryLayerCount >= 2)
   {
      Print("?? PERFORMANCE ALERT: Poor recovery effectiveness - reducing aggression");
      // Could adjust recovery parameters here
   }
   else if(performanceStatus == "EXCELLENT" && recoveryLayerCount >= 1)
   {
      Print("?? PERFORMANCE POSITIVE: Excellent recovery - maintaining strategy");
   }
}


//+------------------------------------------------------------------+
//| Enhanced Recovery Exit                                          |
//+------------------------------------------------------------------+
void EnhancedRecoveryExit()
{
   if(recoveryLayerCount == 0) return;
   
   double currentEquity = accountInfo.Equity();
   double totalPortfolioProfit = CalculateTotalProfit();
   double recoveryPositionsProfit = CalculateRecoveryPositionsProfit();
   
   bool exitRecovery = false;
   string exitReason = "";
   
   // Multiple exit conditions
   if(totalPortfolioProfit >= RecoveryTarget)
   {
      exitRecovery = true;
      exitReason = "Portfolio target achieved";
   }
   else if(recoveryPositionsProfit >= RecoveryTarget * 0.8 && recoveryLayerCount >= 2)
   {
      exitRecovery = true;
      exitReason = "Recovery positions near target";
   }
   else if(currentEquity >= recoveryHistory[0].openEquity + RecoveryTarget * 0.6)
   {
      exitRecovery = true;
      exitReason = "Equity recovery milestone";
   }
   else if(recoveryLayerCount >= 3 && totalPortfolioProfit >= -RecoveryTarget * 0.3)
   {
      exitRecovery = true;
      exitReason = "Significant loss recovery with multiple steps";
   }
   
   // Time-based exit - if recovery is taking too long
   datetime firstRecoveryTime = recoveryHistory[0].openTime;
   double hoursSinceFirstRecovery = (TimeCurrent() - firstRecoveryTime) / 3600.0;
   
   if(hoursSinceFirstRecovery > 24 && recoveryLayerCount >= 2)
   {
      exitRecovery = true;
      exitReason = "Time-based recovery exit (24h+)";
   }
   
   if(exitRecovery)
   {
      Print("?? ENHANCED RECOVERY EXIT | Reason: " + exitReason);
      Print("?? Portfolio Profit: $" + DoubleToString(totalPortfolioProfit, 2));
      Print("?? Recovery Profit: $" + DoubleToString(recoveryPositionsProfit, 2));
      Print("?? Recovery Steps: " + IntegerToString(recoveryLayerCount));
      
      // Close all recovery positions
      int closedRecovery = 0;
      double totalRecoveryCloseProfit = 0;
      
      for(int i = PositionsTotal()-1; i >= 0; i--)
      {
         ulong ticket = PositionGetTicket(i);
         if(PositionSelectByTicket(ticket))
         {
            if(PositionGetInteger(POSITION_MAGIC) == MAGIC_RECOVERY)
            {
               double profit = PositionGetDouble(POSITION_PROFIT);
               if(trade.PositionClose(ticket))
               {
                  closedRecovery++;
                  totalRecoveryCloseProfit += profit;
               }
            }
         }
      }
      
      Print("?? Closed " + IntegerToString(closedRecovery) + " recovery positions");
      Print("?? Total recovery close profit: $" + DoubleToString(totalRecoveryCloseProfit, 2));
      
      // Reset recovery system
      ResetRecoverySystem();
   }
}


ENUM_POSITION_TYPE GetBreakoutDirection()
{
   return (iClose(_Symbol, PERIOD_M15, 0) > iClose(_Symbol, PERIOD_M15, 1)) ? POSITION_TYPE_BUY : POSITION_TYPE_SELL;
}

bool IsBreakoutLikely()
{
   return (CalculateVolatility() > 0.8 && MathAbs(GetNetMomentum()) > 10);
}

void OpenRecoveryPosition(ENUM_POSITION_TYPE type, double multiplier)
{
    double lotSize = CalculateRecoveryLotSize() * multiplier;
    string comment = "Recovery_" + GetRegimeName(DetectMarketRegime());
    
    Print("   üìà Opening Recovery " + EnumToString(type) + 
          " Lot: " + DoubleToString(lotSize, 2) +
          " Multiplier: " + DoubleToString(multiplier, 1));
    
   
}
double CalculateRecoveryLotSize()
{
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì lot size ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö recovery
    double baseLot = 0.01; // ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≤‡∏Å balance
    int recoveryStep = GetCurrentRecoveryStep();
    return baseLot * MathPow(1.8, recoveryStep); // Martingale-like
}

void WaitForBetterConditions()
{
   Print("   ‚è≥ Waiting for better conditions");
}



int GetCurrentRecoveryStep()
{
   return recoveryLayerCount; // ‡∏´‡∏£‡∏∑‡∏≠ logic ‡∏Å‡∏≤‡∏£‡∏ô‡∏±‡∏ö‡∏Ç‡∏±‡πâ‡∏ô recovery
}

//+------------------------------------------------------------------+
//| Check Emergency Hedge                                           |
//+------------------------------------------------------------------+
void CheckEmergencyHedge()
{
   if(!UseEmergencyHedge) return;
   
   double totalLoss = CalculateTotalPortfolioLoss();
   if(totalLoss > -EmergencyHedgeThreshold)
   {
      DebugPrint(3, "Loss not sufficient for emergency hedge: $" + DoubleToString(totalLoss, 2));
      return;
   }
   
   // Check if we already have a hedge position
   bool hasHedge = false;
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         if(PositionGetInteger(POSITION_MAGIC) == MAGIC_HEDGE)
         {
            hasHedge = true;
            break;
         }
      }
   }
   
   if(hasHedge)
   {
      DebugPrint(3, "Emergency hedge already active");
      return;
   }
   
   // Calculate hedge lot size
   double totalVolume = CalculateTotalVolume();
   double hedgeLot = totalVolume * HedgeLotMultiplier;
   hedgeLot = MathMin(hedgeLot, MaxLot);
   hedgeLot = MathMax(hedgeLot, BaseLot * 2);
   
   if(!CheckMargin(hedgeLot))
   {
      Print("? Margin insufficient for emergency hedge: " + DoubleToString(hedgeLot, 2));
      return;
   }
   
   // Determine hedge direction (opposite to net position)
   ENUM_POSITION_TYPE netPositionType = GetMainPositionType();
   if(netPositionType == (ENUM_POSITION_TYPE)WRONG_VALUE_CONST)
   {
      Print("? Cannot determine net position for hedge");
      return;
   }
   
   trade.SetExpertMagicNumber(MAGIC_HEDGE);
   bool success = false;
   string comment = "Emergency-Hedge-Loss" + DoubleToString(totalLoss, 0);
   
   if(netPositionType == POSITION_TYPE_BUY)
   {
      // Net long - hedge with sell
      success = trade.Sell(hedgeLot, _Symbol, 0, 0, 0, comment);
   }
   else
   {
      // Net short - hedge with buy
      success = trade.Buy(hedgeLot, _Symbol, 0, 0, 0, comment);
   }
   
   if(success)
   {
      Print("?? EMERGENCY HEDGE ACTIVATED | Loss: $" + DoubleToString(totalLoss, 2) +
            " | Hedge Lot: " + DoubleToString(hedgeLot, 2) +
            " | Direction: " + (netPositionType == POSITION_TYPE_BUY ? "SELL" : "BUY"));
   }
   
   // Check for hedge profit target
   CheckHedgeProfitTarget();
}
//+------------------------------------------------------------------+
//| Check Hedge Profit Target                                       |
//+------------------------------------------------------------------+
void CheckHedgeProfitTarget()
{
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         if(PositionGetInteger(POSITION_MAGIC) == MAGIC_HEDGE)
         {
            double profit = PositionGetDouble(POSITION_PROFIT);
            if(profit >= HedgeProfitTargetUSD)
            {
               if(trade.PositionClose(ticket))
               {
                  Print("?? HEDGE PROFIT TARGET HIT | Profit: $" + DoubleToString(profit, 2));
               }
            }
         }
      }
   }
}
//-----------------------------------------**--//
// ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ safety system
void PrintRecoverySafetyStatus()
{
    Print("=== RECOVERY SAFETY SYSTEMS ===");
    Print("UseRecoverySafety: " + (UseRecoverySafety ? "ENABLED üü¢" : "DISABLED üî¥"));
    Print("MaxDrawdownPercent: " + DoubleToString(MaxDrawdownPercent, 1) + "%");
    Print("MaxTotalLoss: $" + DoubleToString(MaxTotalLoss, 2));
    Print("MaxConsecutiveLosses: " + IntegerToString(MaxConsecutiveLosses));
    Print("AutoStopRecovery: " + (AutoStopRecovery ? "YES" : "NO"));
    Print("SafetyStopThreshold: $" + DoubleToString(SafetyStopThreshold, 2));
    
    double currentDrawdown = CalculateTrueDrawdownPercent();
    double totalProfit = CalculateTotalProfit();
    double marginLevel = (AccountInfoDouble(ACCOUNT_EQUITY) / AccountInfoDouble(ACCOUNT_MARGIN)) * 100.0;
    
    Print("--- CURRENT STATUS ---");
    Print("Drawdown: " + DoubleToString(currentDrawdown, 1) + "%");
    Print("Total P/L: $" + DoubleToString(totalProfit, 2));
    Print("Margin Level: " + DoubleToString(marginLevel, 1) + "%");
    Print("Active Positions: " + IntegerToString(PositionsTotal()));
    Print("Recovery Stopped: " + (recoveryStopped ? "YES" : "NO"));
    
    if(!UseRecoverySafety)
    {
        Print("üö´ RECOVERY SAFETY: DISABLED");
        Print("üí° No automatic position closure will occur");
        Print("üí° System will only show warnings");
    }
    else
    {
        Print("üõ°Ô∏è RECOVERY SAFETY: ENABLED");
        Print("üí° Will take action if conditions are met");
    }
}
// ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö UseRecoverySafety
void ExecuteMarginProtectionOnly()
{
    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£
    if(!UseRecoverySafety) 
    {
        Print("‚ö†Ô∏è MARGIN PROTECTION: UseRecoverySafety = FALSE - No action taken");
        return;
    }
    
    Print("üõ°Ô∏è MARGIN PROTECTION: Managing positions carefully");
    
    int closedCount = 0;
    
    // ‚úÖ ‡∏õ‡∏¥‡∏î‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡πÑ‡∏£‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
    for(int i = PositionsTotal()-1; i >= 0 && closedCount < 2; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            double profit = PositionGetDouble(POSITION_PROFIT);
            double volume = PositionGetDouble(POSITION_VOLUME);
            
            if(profit > 2.0 && volume <= BaseLot * 2)
            {
                if(trade.PositionClose(ticket))
                {
                    closedCount++;
                    Print("? Margin Protection: Closed #" + TicketToStr(ticket) + 
                          " | Profit: $" + DoubleToString(profit, 2));
                }
            }
        }
    }
    
    if(closedCount > 0)
    {
        double newMarginLevel = (AccountInfoDouble(ACCOUNT_EQUITY) / AccountInfoDouble(ACCOUNT_MARGIN)) * 100.0;
        Print("‚úÖ MARGIN PROTECTION: Closed " + IntegerToString(closedCount) + 
              " positions | New Level: " + DoubleToString(newMarginLevel, 1) + "%");
    }
}
//+------------------------------------------------------------------+
//| Run Safety Check                                                |
//+------------------------------------------------------------------+
void RunSafetyCheck()
{
    // ‚úÖ ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ Safety Systems Manager
    ManageSafetySystems();
    
    // ‚úÖ ‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Margin Protection (‡πÅ‡∏¢‡∏Å‡∏™‡πà‡∏ß‡∏ô)
    double marginLevel = (AccountInfoDouble(ACCOUNT_EQUITY) / AccountInfoDouble(ACCOUNT_MARGIN)) * 100.0;
    
    if(marginLevel < 100.0 && UseRecoverySafety) 
    {
        Print("?? MARGIN PROTECTION: Margin level " + DoubleToString(marginLevel, 1) + "%");
        ExecuteMarginProtectionOnly();
    }
}

//+------------------------------------------------------------------+
//| Close Small Profitable Positions                               |
//+------------------------------------------------------------------+
void CloseSmallProfitablePositions()
{
   int closed = 0;
   
   for(int i = PositionsTotal()-1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         double profit = PositionGetDouble(POSITION_PROFIT);
         double volume = PositionGetDouble(POSITION_VOLUME);
         
         // Close small profitable positions to free margin
         if(profit > 1.0 && volume <= BaseLot * 2)
         {
            if(trade.PositionClose(ticket))
            {
               closed++;
               Print("? Closed small profitable: #" + TicketToStr(ticket) + " | Profit: $" + DoubleToString(profit, 2));
               
               if(closed >= 2) break; // Close max 2 positions at once
            }
         }
      }
   }
   
   if(closed > 0)
   {
      Print("?? Freed margin by closing " + IntegerToString(closed) + " small positions");
   }
}
//+------------------------------------------------------------------+
//| Emergency Margin Protection                                    |
//+------------------------------------------------------------------+
void EmergencyMarginProtection()
{
   Print("?? EMERGENCY MARGIN PROTECTION ACTIVATED!");
   
   // Close positions starting with smallest profit/largest loss
   int closed = 0;
   double totalClosed = 0;
   
   // First try to close some losing positions
   for(int i = PositionsTotal()-1; i >= 0 && closed < 3; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         double profit = PositionGetDouble(POSITION_PROFIT);
         if(profit < -10.0) // Close positions with significant loss
         {
            if(trade.PositionClose(ticket))
            {
               closed++;
               totalClosed += profit;
               Print("? Emergency close loss: #" + TicketToStr(ticket) + " | Loss: $" + DoubleToString(profit, 2));
            }
         }
      }
   }
   
   // If still needed, close some small positions regardless of P/L
   if(closed < 2)
   {
      for(int i = PositionsTotal()-1; i >= 0 && closed < 3; i--)
      {
         ulong ticket = PositionGetTicket(i);
         if(PositionSelectByTicket(ticket))
         {
            double volume = PositionGetDouble(POSITION_VOLUME);
            if(volume <= BaseLot * 2) // Small positions
            {
               double profit = PositionGetDouble(POSITION_PROFIT);
               if(trade.PositionClose(ticket))
               {
                  closed++;
                  totalClosed += profit;
                  Print("? Emergency close small: #" + TicketToStr(ticket) + " | P/L: $" + DoubleToString(profit, 2));
               }
            }
         }
      }
   }
   
   if(closed > 0)
   {
      Print("?? EMERGENCY MARGIN ACTION: Closed " + IntegerToString(closed) + 
            " positions | Net P/L: $" + DoubleToString(totalClosed, 2));
   }
}
//+------------------------------------------------------------------+

bool CloseHedgedPair(ulong ticket1, ulong ticket2, double profit)
{
    bool closed1 = trade.PositionClose(ticket1);
    bool closed2 = trade.PositionClose(ticket2);
    
    if(closed1 && closed2)
    {
        Print("üéØ HEDGED PAIR CLOSED | " + 
              "T1: #" + TicketToStr(ticket1) + 
              " | T2: #" + TicketToStr(ticket2) + 
              " | Profit: $" + DoubleToString(profit, 2));
        
        // Mark set as completed
        int setIndex = FindSetByMainTicket(ticket1);
        if(setIndex != -1)
        {
            recoverySets[setIndex].isCompleted = true;
            Print("üî∞ SET #" + IntegerToString(recoverySets[setIndex].setNumber) + 
                  " COMPLETED | Hedged pair closed");
        }
        
        return true;
    }
    else
    {
        Print("‚ùå FAILED to close hedged pair: " +
              "T1: " + (closed1 ? "OK" : "FAIL") + 
              " | T2: " + (closed2 ? "OK" : "FAIL"));
        return false;
    }
}
// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏Å‡πà‡∏≠‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô CloseHedgedPair
void MarkSetAsCompleted(int setIndex, string reason)
{
    if(setIndex < 0 || setIndex >= totalRecoverySets) return;
    
    recoverySets[setIndex].isCompleted = true;
    
    Print("üî∞ SET #" + IntegerToString(recoverySets[setIndex].setNumber) + 
          " COMPLETED | Reason: " + reason +
          " | Main: #" + TicketToStr(recoverySets[setIndex].mainTicket) +
          " | Final Profit: $" + DoubleToString(recoverySets[setIndex].totalProfit, 2));
}

void MarkSetAsCompletedByMainTicket(ulong mainTicket, string reason)
{
    int setIndex = FindSetByMainTicket(mainTicket);
    if(setIndex != -1)
    {
        MarkSetAsCompleted(setIndex, reason);
    }
}




void ExecuteSmartHedgeClosing()
{
    // ‡∏õ‡∏¥‡∏î‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏Ç‡∏±‡∏î‡πÅ‡∏¢‡πâ‡∏á‡∏Å‡∏±‡∏ô‡πÅ‡∏ö‡∏ö selective
    double totalClosedProfit = 0;
    int pairsClosed = 0;
    
    for(int i = PositionsTotal()-1; i >= 0; i--)
    {
        ulong ticket1 = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket1)) continue;
        
        ENUM_POSITION_TYPE type1 = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        string symbol1 = PositionGetString(POSITION_SYMBOL);
        
        // ‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°
        for(int j = PositionsTotal()-1; j >= 0; j--)
        {
            if(i == j) continue;
            
            ulong ticket2 = PositionGetTicket(j);
            if(!PositionSelectByTicket(ticket2)) continue;
            
            ENUM_POSITION_TYPE type2 = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            string symbol2 = PositionGetString(POSITION_SYMBOL);
            
            // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏Å‡∏∏‡∏•‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡πÅ‡∏•‡∏∞‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°
            if(symbol1 == symbol2 && type1 != type2)
            {
                double profit1 = PositionGetDouble(POSITION_PROFIT);
                double profit2 = PositionGetDouble(POSITION_PROFIT);
                double totalProfit = profit1 + profit2;
                
                // ‡∏õ‡∏¥‡∏î‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡πÑ‡∏£‡∏£‡∏ß‡∏° ‡∏´‡∏£‡∏∑‡∏≠ ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏ô‡πâ‡∏≠‡∏¢‡∏°‡∏≤‡∏Å
                if(totalProfit >= 1.0 || (totalProfit >= -2.0 && MathAbs(profit1 - profit2) < 5.0))
                {
                    if(trade.PositionClose(ticket1) && trade.PositionClose(ticket2))
                    {
                        totalClosedProfit += totalProfit;
                        pairsClosed++;
                        Print("üéØ SMART HEDGE CLOSED | Profit: $" + DoubleToString(totalProfit, 2));
                        break;
                    }
                }
            }
        }
    }
    
    if(pairsClosed > 0)
    {
        Print("üéØ HEDGE SUMMARY | Pairs: " + IntegerToString(pairsClosed) + 
              " | Total Profit: $" + DoubleToString(totalClosedProfit, 2));
    }
}

// +------------------------------------------------------------------+
//| Calculate Break-Even Price                                       |
//+------------------------------------------------------------------+
double CalculateBreakEvenPrice(ulong buyTicket, ulong sellTicket)
{
    if(!PositionSelectByTicket(buyTicket) || !PositionSelectByTicket(sellTicket)) return 0;
    
    ENUM_POSITION_TYPE buyType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
    ENUM_POSITION_TYPE sellType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏±‡∏ô‡∏à‡∏£‡∏¥‡∏á‡πÜ
    if(buyType == sellType) return 0;
    
    double buyVolume = PositionGetDouble(POSITION_VOLUME);
    double sellVolume = PositionGetDouble(POSITION_VOLUME);
    double buyOpen = PositionGetDouble(POSITION_PRICE_OPEN);
    double sellOpen = PositionGetDouble(POSITION_PRICE_OPEN);
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ñ‡∏∏‡∏°‡∏ó‡∏∏‡∏ô (Weighted Average)
    double totalVolume = buyVolume + sellVolume;
    double breakEven = ((buyVolume * buyOpen) + (sellVolume * sellOpen)) / totalVolume;
    
    return NormalizeDouble(breakEven, (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS));
}
// +------------------------------------------------------------------+
//| Create or Update Breakeven Line                                 |
//+------------------------------------------------------------------+
void UpdateBreakevenLine()
{
    double newBreakevenPrice = CalculateGlobalBreakevenPrice();
    
    // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ç‡∏±‡∏î‡πÅ‡∏¢‡πâ‡∏á‡∏Å‡∏±‡∏ô ‚Üí ‡∏•‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏≠‡∏≠‡∏Å
    if(newBreakevenPrice == 0)
    {
        DeleteBreakevenLine();
        currentBreakevenPrice = 0;
        return;
    }
    
    // ‡∏ñ‡πâ‡∏≤‡∏£‡∏≤‡∏Ñ‡∏≤‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô ‚Üí ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡πÄ‡∏™‡πâ‡∏ô
    if(newBreakevenPrice != currentBreakevenPrice || !breakevenLineCreated)
    {
        DeleteBreakevenLine();
        CreateBreakevenLine(newBreakevenPrice);
        currentBreakevenPrice = newBreakevenPrice;
        breakevenLineCreated = true;
    }
}

// +------------------------------------------------------------------+
//| Calculate Global Breakeven Price                                |
//+------------------------------------------------------------------+
double CalculateGlobalBreakevenPrice()
{
    int totalBuyLots = 0, totalSellLots = 0;
    double totalBuyCost = 0, totalSellCost = 0;
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string symbol = PositionGetString(POSITION_SYMBOL);
        if(symbol != _Symbol) continue; // ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
        
        ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        double volume = PositionGetDouble(POSITION_VOLUME);
        double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        
        if(type == POSITION_TYPE_BUY)
        {
            totalBuyLots += (int)(volume / 0.01); // ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô lot
            totalBuyCost += volume * openPrice;
        }
        else if(type == POSITION_TYPE_SELL)
        {
            totalSellLots += (int)(volume / 0.01); // ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô lot
            totalSellCost += volume * openPrice;
        }
    }
    
    // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ç‡∏±‡∏î‡πÅ‡∏¢‡πâ‡∏á‡∏Å‡∏±‡∏ô
    if(totalBuyLots == 0 || totalSellLots == 0) return 0;
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ñ‡∏∏‡∏°‡∏ó‡∏∏‡∏ô
    double totalLots = totalBuyLots + totalSellLots;
    double breakevenPrice = (totalBuyCost + totalSellCost) / (totalBuyLots * 0.01 + totalSellLots * 0.01);
    
    Print("üí∞ BREAKEVEN CALC | Buy: " + IntegerToString(totalBuyLots) + 
          " lots | Sell: " + IntegerToString(totalSellLots) + 
          " lots | BE Price: " + DoubleToString(breakevenPrice, _Digits));
    
    return NormalizeDouble(breakevenPrice, _Digits);
}

// +------------------------------------------------------------------+
//| Create Breakeven Line                                           |
//+------------------------------------------------------------------+
void CreateBreakevenLine(double price)
{
    ObjectCreate(0, beLineName, OBJ_HLINE, 0, 0, price);
    ObjectSetInteger(0, beLineName, OBJPROP_COLOR, clrLime); // ‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß
    ObjectSetInteger(0, beLineName, OBJPROP_STYLE, STYLE_SOLID);
    ObjectSetInteger(0, beLineName, OBJPROP_WIDTH, 2);
    ObjectSetInteger(0, beLineName, OBJPROP_BACK, true);
    ObjectSetString(0, beLineName, OBJPROP_TEXT, "Breakeven");
    
    Print("üìä BREAKEVEN LINE CREATED | Price: " + DoubleToString(price, _Digits));
}

// +------------------------------------------------------------------+
//| Delete Breakeven Line                                           |
//+------------------------------------------------------------------+
void DeleteBreakevenLine()
{
    if(ObjectFind(0, beLineName) >= 0)
    {
        ObjectDelete(0, beLineName);
        breakevenLineCreated = false;
    }
}

// +------------------------------------------------------------------+
//| Show Breakeven Info On Chart                                    |
//+------------------------------------------------------------------+
void ShowBreakevenInfo()
{
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double distance = 0;
    
    if(currentBreakevenPrice > 0)
    {
        distance = (currentPrice - currentBreakevenPrice) / GetPipSize(_Symbol);
    }
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á/‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó text object
    string infoName = "BE_Info";
    string infoText = "Breakeven: " + (currentBreakevenPrice > 0 ? DoubleToString(currentBreakevenPrice, _Digits) : "N/A");
    
    if(currentBreakevenPrice > 0)
    {
        infoText += " | Distance: " + DoubleToString(distance, 1) + " pips";
        infoText += " | " + (distance > 0 ? "ABOVE" : "BELOW");
    }
    
    if(ObjectFind(0, infoName) < 0)
    {
        ObjectCreate(0, infoName, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, infoName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
        ObjectSetInteger(0, infoName, OBJPROP_XDISTANCE, 10);
        ObjectSetInteger(0, infoName, OBJPROP_YDISTANCE, 60);
        ObjectSetInteger(0, infoName, OBJPROP_BACK, false);
    }
    
    ObjectSetString(0, infoName, OBJPROP_TEXT, infoText);
    ObjectSetInteger(0, infoName, OBJPROP_COLOR, currentBreakevenPrice > 0 ? clrLime : clrGray);
    ObjectSetInteger(0, infoName, OBJPROP_FONTSIZE, 10);
}
void CheckStuckHedges()
{
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        long magic = PositionGetInteger(POSITION_MAGIC);
        if(magic != MAGIC_HEDGE) continue;
        
        double profit = PositionGetDouble(POSITION_PROFIT);
        datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
        double hoursOpen = (TimeCurrent() - openTime) / 3600.0;
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ "‡∏Ñ‡πâ‡∏≤‡∏á" ‡πÅ‡∏•‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç
        bool isStuck = (hoursOpen > 1.0) && (MathAbs(profit) > 10.0);
        
        if(isStuck)
        {
            Print("‚ö†Ô∏è ANALYZING STUCK HEDGE | #" + TicketToStr(ticket) + 
                  " | P/L: $" + DoubleToString(profit, 2) + 
                  " | Hours: " + DoubleToString(hoursOpen, 1));
            
            // ‚úÖ ‡πÑ‡∏°‡πà‡∏õ‡∏¥‡∏î! ‡πÅ‡∏ï‡πà‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏•‡∏∞‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç
            AnalyzeAndFixStuckHedge(ticket);
        }
    }
}

// +------------------------------------------------------------------+
//| Try Close Stuck Hedge                                           |
//+------------------------------------------------------------------+
void TryCloseStuckHedge(ulong hedgeTicket, double profit, double hoursOpen)
{
    //string symbol = PositionGetString(POSITION_SYMBOL);
    
    
    
    
}
// +------------------------------------------------------------------+
//| Manual Hedge Management (‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏à‡∏≤‡∏Å OnChartEvent)                 |
//+------------------------------------------------------------------+
void ManageHedgesManually()
{
    Print("=== MANUAL HEDGE MANAGEMENT ===");
    
    int totalHedges = 0;
    double totalProfit = 0;
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        long magic = PositionGetInteger(POSITION_MAGIC);
        if(magic != MAGIC_HEDGE) continue;
        
        totalHedges++;
        double profit = PositionGetDouble(POSITION_PROFIT);
        totalProfit += profit;
        
        string symbol = PositionGetString(POSITION_SYMBOL);
        double volume = PositionGetDouble(POSITION_VOLUME);
        datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
        
        Print("Hedge #" + IntegerToString(totalHedges) + 
              " | Ticket: #" + TicketToStr(ticket) +
              " | " + symbol + 
              " | Lot: " + DoubleToString(volume, 2) +
              " | P/L: $" + DoubleToString(profit, 2) +
              " | Open: " + TimeToString(openTime));
    }
    
    if(totalHedges == 0)
    {
        Print("No active hedge positions found.");
    }
    else
    {
        Print("Total Hedges: " + IntegerToString(totalHedges) + 
              " | Combined P/L: $" + DoubleToString(totalProfit, 2));
        
        // ‡∏ñ‡∏≤‡∏°‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏õ‡∏¥‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÑ‡∏´‡∏°
        if(MessageBox("Found " + IntegerToString(totalHedges) + " hedge positions.\n" +
                     "Total P/L: $" + DoubleToString(totalProfit, 2) + "\n" +
                     "Close all hedge positions?", "Hedge Management", MB_YESNO) == IDYES)
        {
            CloseAllHedges();
        }
    }
}
// +------------------------------------------------------------------+
//| Close All Hedges                                                |
//+------------------------------------------------------------------+
void CloseAllHedges()
{
    int closedCount = 0;
    double totalProfit = 0;
    
    for(int i = PositionsTotal()-1; i >= 0; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        long magic = PositionGetInteger(POSITION_MAGIC);
        if(magic != MAGIC_HEDGE) continue;
        
        double profit = PositionGetDouble(POSITION_PROFIT);
        
        if(trade.PositionClose(ticket))
        {
            closedCount++;
            totalProfit += profit;
            Print("‚úÖ HEDGE CLOSED | #" + TicketToStr(ticket) + 
                  " | P/L: $" + DoubleToString(profit, 2));
        }
    }
    
    Print("üéØ HEDGE CLOSE SUMMARY | Closed: " + IntegerToString(closedCount) + 
          " | Total P/L: $" + DoubleToString(totalProfit, 2));
}
// +------------------------------------------------------------------+
//| Chart Event (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö manual control)                            |
//+------------------------------------------------------------------+
void OnChartEvent(const int id, const long &lparam, const double &dparam, const string &sparam)
{
    if(id == CHARTEVENT_KEYDOWN)
    {
        // ‡∏Å‡∏î 'H' ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ hedge manual
        if(lparam == 'H')
        {
            ManageHedgesManually();
        }
       
        
    }
}
// +------------------------------------------------------------------+
//| Analyze Stuck Hedge Situation                                   |
//+------------------------------------------------------------------+
void AnalyzeAndFixStuckHedge(ulong hedgeTicket)
{
    if(!PositionSelectByTicket(hedgeTicket)) return;
    
    string symbol = PositionGetString(POSITION_SYMBOL);
    ENUM_POSITION_TYPE hedgeType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
    double hedgeVolume = PositionGetDouble(POSITION_VOLUME);
    double hedgeProfit = PositionGetDouble(POSITION_PROFIT);
    double hedgeOpenPrice = PositionGetDouble(POSITION_PRICE_OPEN);
    
    Print("üîç ANALYZING STUCK HEDGE | #" + TicketToStr(hedgeTicket) + 
          " | " + (hedgeType == POSITION_TYPE_BUY ? "BUY" : "SELL") +
          " | Lot: " + DoubleToString(hedgeVolume, 2) + 
          " | P/L: $" + DoubleToString(hedgeProfit, 2));
    
    // ‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏´‡∏•‡∏±‡∏Å‡∏ó‡∏µ‡πà hedge ‡∏ô‡∏µ‡πâ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ä‡πà‡∏ß‡∏¢‡∏≠‡∏¢‡∏π‡πà
    ulong mainTicket = FindMainTicketForHedge(hedgeTicket);
    
    if(mainTicket > 0 && PositionSelectByTicket(mainTicket))
    {
        // ‚úÖ ‡∏Å‡∏£‡∏ì‡∏µ‡∏°‡∏µ Main Ticket ‚Üí ‡πÉ‡∏ä‡πâ‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÅ‡∏ö‡∏ö‡∏°‡∏µ‡∏Ñ‡∏π‡πà
        FixHedgeWithRecovery(hedgeTicket, mainTicket, hedgeType, hedgeVolume, hedgeProfit);
    }
    else
    {
        // ‚úÖ ‡∏Å‡∏£‡∏ì‡∏µ‡πÑ‡∏°‡πà‡∏°‡∏µ Main Ticket ‚Üí ‡πÉ‡∏ä‡πâ‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÅ‡∏ö‡∏ö standalone
        FixStandaloneHedge(hedgeTicket, hedgeType, hedgeVolume, hedgeProfit);
    }
}
// +------------------------------------------------------------------+
//| Fix Standalone Hedge (‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏´‡∏≤ Main Ticket ‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠)               |
//+------------------------------------------------------------------+
void FixStandaloneHedge(ulong hedgeTicket, ENUM_POSITION_TYPE hedgeType, 
                       double hedgeVolume, double hedgeProfit)
{
    if(!PositionSelectByTicket(hedgeTicket)) return;
    
    string symbol = PositionGetString(POSITION_SYMBOL);
    
    Print("üîß FIXING STANDALONE HEDGE | #" + TicketToStr(hedgeTicket) + 
          " | " + (hedgeType == POSITION_TYPE_BUY ? "BUY" : "SELL") +
          " | Lot: " + DoubleToString(hedgeVolume, 2) + 
          " | P/L: $" + DoubleToString(hedgeProfit, 2));
    
    // ‚úÖ ‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç Hedge ‡πÅ‡∏ö‡∏ö standalone
    
    if(hedgeProfit <= -20.0) 
    {
        // ‡∏Å‡∏£‡∏ì‡∏µ 1: Hedge ‡∏ï‡∏¥‡∏î‡∏•‡∏ö‡∏´‡∏ô‡∏±‡∏Å ‚Üí ‡πÄ‡∏õ‡∏¥‡∏î‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠
        OpenHelpForStandaloneHedge(hedgeTicket, hedgeType, hedgeVolume, symbol, hedgeProfit);
    }
    else if(hedgeProfit >= 15.0) 
    {
        // ‡∏Å‡∏£‡∏ì‡∏µ 2: Hedge ‡∏Å‡∏≥‡πÑ‡∏£‡∏°‡∏≤‡∏Å ‚Üí ‡∏õ‡∏¥‡∏î‡∏ö‡∏≤‡∏á‡∏™‡πà‡∏ß‡∏ô lock profit
        ClosePartialPosition(hedgeTicket, hedgeVolume * 0.4, "Standalone hedge profit take");
    }
    else 
    {
        // ‡∏Å‡∏£‡∏ì‡∏µ 3: Hedge ‡∏Ñ‡πâ‡∏≤‡∏á‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏´‡∏ô‡∏±‡∏Å ‚Üí ‡πÄ‡∏õ‡∏¥‡∏î‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ä‡πà‡∏ß‡∏¢‡πÅ‡∏ö‡∏ö conservative
        OpenConservativeHelp(hedgeTicket, hedgeType, hedgeVolume, symbol, hedgeProfit);
    }
}

// +------------------------------------------------------------------+
//| Open Help For Standalone Hedge                                   |
//+------------------------------------------------------------------+
void OpenHelpForStandaloneHedge(ulong hedgeTicket, ENUM_POSITION_TYPE hedgeType,
                               double hedgeVolume, string symbol, double hedgeProfit)
{
    double helpVolume = hedgeVolume * 0.6; // 60% ‡∏Ç‡∏≠‡∏á volume ‡πÄ‡∏î‡∏¥‡∏°
    helpVolume = MathMax(helpVolume, BaseLot);
    helpVolume = MathMin(helpVolume, MaxLot);
    helpVolume = NormalizeDouble(helpVolume, 2);
    
    if(!CheckMargin(helpVolume, symbol))
    {
        Print("‚ùå Margin insufficient for standalone hedge help");
        return;
    }
    
    trade.SetExpertMagicNumber(MAGIC_HEDGE);
    bool success = false;
    
    // ‡πÄ‡∏õ‡∏¥‡∏î‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ä‡πà‡∏ß‡∏¢‡πÉ‡∏ô‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô (‡πÄ‡∏™‡∏£‡∏¥‡∏°‡∏Å‡∏≥‡∏•‡∏±‡∏á)
    if(hedgeType == POSITION_TYPE_BUY)
    {
        success = trade.Buy(helpVolume, symbol, 0, 0, 0, 
                          "Standalone-Help-BUY-" + TicketToStr(hedgeTicket));
    }
    else
    {
        success = trade.Sell(helpVolume, symbol, 0, 0, 0, 
                           "Standalone-Help-SELL-" + TicketToStr(hedgeTicket));
    }
    
    if(success)
    {
        Print("üÜò STANDALONE HEDGE HELP | For: #" + TicketToStr(hedgeTicket) + 
              " | " + (hedgeType == POSITION_TYPE_BUY ? "BUY" : "SELL") +
              " | Help Lot: " + DoubleToString(helpVolume, 2) +
              " | Reason: Losing $" + DoubleToString(hedgeProfit, 2));
    }
}

// +------------------------------------------------------------------+
//| Open Conservative Help                                           |
//+------------------------------------------------------------------+
void OpenConservativeHelp(ulong hedgeTicket, ENUM_POSITION_TYPE hedgeType,
                         double hedgeVolume, string symbol, double hedgeProfit)
{
    double helpVolume = BaseLot; // ‡πÉ‡∏ä‡πâ lot ‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏•‡πá‡∏Å
    helpVolume = NormalizeDouble(helpVolume, 2);
    
    if(!CheckMargin(helpVolume, symbol))
    {
        Print("‚ùå Margin insufficient for conservative help");
        return;
    }
    
    trade.SetExpertMagicNumber(MAGIC_HEDGE);
    bool success = false;
    
    // ‡πÄ‡∏õ‡∏¥‡∏î‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á balance
    if(hedgeType == POSITION_TYPE_BUY)
    {
        success = trade.Sell(helpVolume, symbol, 0, 0, 0, 
                           "Cons-Help-Balance-" + TicketToStr(hedgeTicket));
    }
    else
    {
        success = trade.Buy(helpVolume, symbol, 0, 0, 0, 
                          "Cons-Help-Balance-" + TicketToStr(hedgeTicket));
    }
    
    if(success)
    {
        Print("üéØ CONSERVATIVE HEDGE BALANCE | For: #" + TicketToStr(hedgeTicket) + 
              " | Opposite " + (hedgeType == POSITION_TYPE_BUY ? "SELL" : "BUY") +
              " | Lot: " + DoubleToString(helpVolume, 2) +
              " | Reason: Balance standalone position");
    }
}
// +------------------------------------------------------------------+
//| Fix Hedge With Additional Recovery                              |
//+------------------------------------------------------------------+
void FixHedgeWithRecovery(ulong hedgeTicket, ulong mainTicket, ENUM_POSITION_TYPE hedgeType, 
                         double hedgeVolume, double hedgeProfit)
{
    if(!PositionSelectByTicket(mainTicket)) return;
    
    ENUM_POSITION_TYPE mainType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
    double mainVolume = PositionGetDouble(POSITION_VOLUME);
    double mainProfit = PositionGetDouble(POSITION_PROFIT);
    string symbol = PositionGetString(POSITION_SYMBOL);
    
    double totalPairProfit = mainProfit + hedgeProfit;
    
    Print("üí∞ HEDGE PAIR ANALYSIS | Main: #" + TicketToStr(mainTicket) + 
          " | Hedge: #" + TicketToStr(hedgeTicket) +
          " | Main P/L: $" + DoubleToString(mainProfit, 2) +
          " | Hedge P/L: $" + DoubleToString(hedgeProfit, 2) +
          " | Total: $" + DoubleToString(totalPairProfit, 2));
    
    // ‚úÖ ‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÄ‡∏õ‡∏¥‡∏î recovery ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
    if(totalPairProfit <= -15.0) // ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏£‡∏ß‡∏°‡∏°‡∏≤‡∏Å
    {
        OpenHedgeRecovery(hedgeTicket, mainTicket, symbol, mainType, mainVolume, hedgeVolume);
    }
    else if(MathAbs(hedgeProfit) > 25.0) // Hedge ‡∏ï‡∏¥‡∏î‡∏•‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡∏Å‡∏≥‡πÑ‡∏£‡∏°‡∏≤‡∏Å
    {
        BalanceHedgePosition(hedgeTicket, mainTicket, symbol, hedgeType, hedgeVolume, hedgeProfit);
    }
}
// +------------------------------------------------------------------+
//| Open Additional Recovery for Hedged Pair                        |
//+------------------------------------------------------------------+
void OpenHedgeRecovery(ulong hedgeTicket, ulong mainTicket, string symbol, 
                      ENUM_POSITION_TYPE mainType, double mainVolume, double hedgeVolume)
{
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì volume ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
    double totalVolume = mainVolume + hedgeVolume;
    double recoveryVolume = totalVolume * 0.3; // 30% ‡∏Ç‡∏≠‡∏á volume ‡∏£‡∏ß‡∏°
    recoveryVolume = MathMax(recoveryVolume, BaseLot);
    recoveryVolume = MathMin(recoveryVolume, MaxLot);
    recoveryVolume = NormalizeDouble(recoveryVolume, 2);
    
    if(!CheckMargin(recoveryVolume, symbol))
    {
        Print("‚ùå Insufficient margin for hedge recovery: " + DoubleToString(recoveryVolume, 2));
        return;
    }
    
    trade.SetExpertMagicNumber(MAGIC_HEDGE);
    bool success = false;
    
    // ‡πÄ‡∏õ‡∏¥‡∏î‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏±‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏´‡∏•‡∏±‡∏Å (‡∏ä‡πà‡∏ß‡∏¢ hedge)
    if(mainType == POSITION_TYPE_BUY)
    {
        // ‡∏´‡∏•‡∏±‡∏Å‡πÄ‡∏õ‡πá‡∏ô BUY, Hedge ‡πÄ‡∏õ‡πá‡∏ô SELL ‚Üí ‡πÄ‡∏õ‡∏¥‡∏î SELL ‡πÄ‡∏û‡∏¥‡πà‡∏°
        success = trade.Sell(recoveryVolume, symbol, 0, 0, 0, 
                           "Hedge-Recov-Main" + TicketToStr(mainTicket));
    }
    else
    {
        // ‡∏´‡∏•‡∏±‡∏Å‡πÄ‡∏õ‡πá‡∏ô SELL, Hedge ‡πÄ‡∏õ‡πá‡∏ô BUY ‚Üí ‡πÄ‡∏õ‡∏¥‡∏î BUY ‡πÄ‡∏û‡∏¥‡πà‡∏°  
        success = trade.Buy(recoveryVolume, symbol, 0, 0, 0,
                          "Hedge-Recov-Main" + TicketToStr(mainTicket));
    }
    
    if(success)
    {
        ulong recoveryTicket = trade.ResultOrder();
        Print("üéØ HEDGE RECOVERY OPENED | Main: #" + TicketToStr(mainTicket) + 
              " | Hedge: #" + TicketToStr(hedgeTicket) +
              " | Recovery: #" + TicketToStr(recoveryTicket) +
              " | Lot: " + DoubleToString(recoveryVolume, 2) +
              " | Strategy: Reinforce hedge position");
    }
}
// +------------------------------------------------------------------+
//| Balance Hedge Position                                          |
//+------------------------------------------------------------------+
void BalanceHedgePosition(ulong hedgeTicket, ulong mainTicket, string symbol,
                         ENUM_POSITION_TYPE hedgeType, double hedgeVolume, double hedgeProfit)
{
    if(hedgeProfit <= -20.0) // Hedge ‡∏ï‡∏¥‡∏î‡∏•‡∏ö‡∏´‡∏ô‡∏±‡∏Å
    {
        // ‚úÖ ‡πÄ‡∏õ‡∏¥‡∏î‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ä‡πà‡∏ß‡∏¢ Hedge
        double helpVolume = hedgeVolume * 0.5;
        helpVolume = MathMax(helpVolume, BaseLot);
        helpVolume = NormalizeDouble(helpVolume, 2);
        
        trade.SetExpertMagicNumber(MAGIC_HEDGE);
        bool success = false;
        
        if(hedgeType == POSITION_TYPE_BUY)
        {
            // Hedge BUY ‡∏ï‡∏¥‡∏î‡∏•‡∏ö ‚Üí ‡πÄ‡∏õ‡∏¥‡∏î BUY ‡∏ä‡πà‡∏ß‡∏¢
            success = trade.Buy(helpVolume, symbol, 0, 0, 0,
                              "Hedge-Help-" + TicketToStr(hedgeTicket));
        }
        else
        {
            // Hedge SELL ‡∏ï‡∏¥‡∏î‡∏•‡∏ö ‚Üí ‡πÄ‡∏õ‡∏¥‡∏î SELL ‡∏ä‡πà‡∏ß‡∏¢  
            success = trade.Sell(helpVolume, symbol, 0, 0, 0,
                               "Hedge-Help-" + TicketToStr(hedgeTicket));
        }
        
        if(success)
        {
            Print("üîÑ HEDGE HELP OPENED | For: #" + TicketToStr(hedgeTicket) + 
                  " | Lot: " + DoubleToString(helpVolume, 2) +
                  " | Reason: Hedge losing $" + DoubleToString(hedgeProfit, 2));
        }
    }
    else if(hedgeProfit >= 25.0) // Hedge ‡∏Å‡∏≥‡πÑ‡∏£‡∏°‡∏≤‡∏Å
    {
        // ‚úÖ ‡∏õ‡∏¥‡∏î‡∏ö‡∏≤‡∏á‡∏™‡πà‡∏ß‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠ lock profit
        double closeVolume = hedgeVolume * 0.3; // ‡∏õ‡∏¥‡∏î 30%
        ClosePartialPosition(hedgeTicket, closeVolume, "Hedge partial profit");
    }
}
// +------------------------------------------------------------------+
//| Close Partial Position                                          |
//+------------------------------------------------------------------+
bool ClosePartialPosition(ulong ticket, double closeVolume, string reason)
{
    if(!PositionSelectByTicket(ticket)) return false;
    
    double currentVolume = PositionGetDouble(POSITION_VOLUME);
    if(closeVolume >= currentVolume) return false; // ‡πÑ‡∏°‡πà‡∏õ‡∏¥‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    
    string symbol = PositionGetString(POSITION_SYMBOL);
    ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
    
    // ‡∏õ‡∏¥‡∏î‡∏ö‡∏≤‡∏á‡∏™‡πà‡∏ß‡∏ô‡πÇ‡∏î‡∏¢‡πÄ‡∏õ‡∏¥‡∏î‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°
    trade.SetExpertMagicNumber(MAGIC_HEDGE);
    bool success = false;
    
    if(type == POSITION_TYPE_BUY)
    {
        success = trade.Sell(closeVolume, symbol, 0, 0, 0, "Partial-Close-" + reason);
    }
    else
    {
        success = trade.Buy(closeVolume, symbol, 0, 0, 0, "Partial-Close-" + reason);
    }
    
    if(success)
    {
        Print("üìâ PARTIAL CLOSE | #" + TicketToStr(ticket) + 
              " | Volume: " + DoubleToString(closeVolume, 2) + 
              " | Reason: " + reason);
    }
    
    return success;
}
// +------------------------------------------------------------------+
//| Find Main Ticket for Hedge                                      |
//+------------------------------------------------------------------+
ulong FindMainTicketForHedge(ulong hedgeTicket)
{
    if(!PositionSelectByTicket(hedgeTicket)) return 0;
    
    string hedgeSymbol = PositionGetString(POSITION_SYMBOL);
    ENUM_POSITION_TYPE hedgeType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
    
    // ‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏´‡∏•‡∏±‡∏Å‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏±‡∏ö hedge
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        long magic = PositionGetInteger(POSITION_MAGIC);
        string symbol = PositionGetString(POSITION_SYMBOL);
        ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        
        // ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏´‡∏•‡∏±‡∏Å + ‡∏™‡∏Å‡∏∏‡∏•‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô + ‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏±‡∏ö hedge
        if(magic != MAGIC_HEDGE && symbol == hedgeSymbol && type != hedgeType)
        {
            return ticket;
        }
    }
    
    return 0;
}
// +------------------------------------------------------------------+
//| Orphan Universal - ‡∏ú‡∏π‡πâ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏á‡∏≤‡∏ô                                  |
//+------------------------------------------------------------------+
void ManageOrphanUniversal()
{
    if(!EnableUniversalOrphan) return;
    
    // 1. ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ job ‡∏ß‡πà‡∏≤‡∏á‡πÑ‡∏´‡∏° (‡∏ï‡∏≤‡∏° MaxOrphansPerCycle)
    if(totalActiveJobs >= MaxOrphansPerCycle) 
    {
        DebugPrint(2, "Orphan Universal: Maximum active jobs reached (" + IntegerToString(MaxOrphansPerCycle) + ")");
        return;
    }
    
    // 2. ‡∏´‡∏≤ Orphan Main Ticket ‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ job
    ulong newOrphanMain = FindNewOrphanMainTicket();
    if(newOrphanMain == 0) 
    {
        DebugPrint(3, "Orphan Universal: No new orphan main tickets found");
        return;
    }
    
    // 3. ‡∏™‡∏£‡πâ‡∏≤‡∏á job ‡πÉ‡∏´‡∏°‡πà
    if(CreateOrphanJob(newOrphanMain))
    {
        Print("üè≠ ORPHAN UNIVERSAL: New Job Created | Job ID: " + IntegerToString(nextJobId-1) + 
              " | Main: #" + TicketToStr(newOrphanMain) +
              " | Active Jobs: " + IntegerToString(totalActiveJobs) + "/" + IntegerToString(MaxOrphansPerCycle));
    }
}
// +------------------------------------------------------------------+
//| Find New Orphan Main Ticket                                      |
//+------------------------------------------------------------------+
ulong FindNewOrphanMainTicket()
{
    // 1. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≤‡∏Å Recovery Sets ‡∏ó‡∏µ‡πà Main ‡∏´‡∏≤‡∏¢
    for(int i = 0; i < totalRecoverySets; i++)
    {
        if(recoverySets[i].isCompleted) continue;
        
        if(!PositionSelectByTicket(recoverySets[i].mainTicket))
        {
            // ‡∏û‡∏ö Main ‡∏ó‡∏µ‡πà‡∏´‡∏≤‡∏¢ ‚Üí ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ job ‡∏ô‡∏µ‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
            if(!HasActiveJobForMain(recoverySets[i].mainTicket))
            {
                return recoverySets[i].mainTicket;
            }
        }
    }
    
    // 2. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≤‡∏Å‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡πÄ‡∏õ‡πá‡∏ô Orphan
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        long magic = PositionGetInteger(POSITION_MAGIC);
        string comment = PositionGetString(POSITION_COMMENT);
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô recovery position ‡∏ó‡∏µ‡πà main ‡∏´‡∏≤‡∏¢
        if((magic == MAGIC_RECOVERY || magic == MAGIC_INDIVIDUAL) && 
           StringFind(comment, "Recovery-") != -1)
        {
            ulong mainTicket = ExtractMainTicketFromComment(comment);
            if(mainTicket > 0 && !PositionSelectByTicket(mainTicket) && !HasActiveJobForMain(mainTicket))
            {
                return mainTicket;
            }
        }
    }
    
    return 0;
}
// +------------------------------------------------------------------+
//| Create Orphan Job                                                |
//+------------------------------------------------------------------+
bool CreateOrphanJob(ulong mainTicket)
{
    if(totalActiveJobs >= 10) 
    {
        Print("‚ùå ORPHAN UNIVERSAL: Maximum jobs capacity reached (10)");
        return false;
    }
    
    OrphanJob newJob;
    newJob.jobId = nextJobId;
    newJob.mainTicket = mainTicket;
    newJob.orphanCount = 0;
    newJob.targetProfit = OrphanCloseProfit;
    newJob.createdTime = TimeCurrent();
    newJob.isCompleted = false;
    newJob.originalStrategy = "Recovery-Set";
    
    // ‡∏´‡∏≤ Orphan tickets ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö main ‡∏ô‡∏µ‡πâ
    FindOrphanTicketsForMain(mainTicket, newJob);
    
    activeOrphanJobs[totalActiveJobs] = newJob;
    totalActiveJobs++;
    nextJobId++;
    
    Print("‚úÖ ORPHAN JOB CREATED | Job ID: " + IntegerToString(newJob.jobId) + 
          " | Main: #" + TicketToStr(mainTicket) +
          " | Orphans Found: " + IntegerToString(newJob.orphanCount) +
          " | Target Profit: $" + DoubleToString(newJob.targetProfit, 2) +
          " | Active Jobs: " + IntegerToString(totalActiveJobs) + "/" + IntegerToString(MaxOrphansPerCycle));
    
    return true;
}
// +------------------------------------------------------------------+
//| Check if Main has Active Job                                     |
//+------------------------------------------------------------------+
bool HasActiveJobForMain(ulong mainTicket)
{
    for(int i = 0; i < totalActiveJobs; i++)
    {
        if(!activeOrphanJobs[i].isCompleted && activeOrphanJobs[i].mainTicket == mainTicket)
            return true;
    }
    return false;
}
// +------------------------------------------------------------------+
//| Orphan Worker - ‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ job                               |
//+------------------------------------------------------------------+
void ManageOrphanWorkers()
{
    if(totalActiveJobs == 0) return;
    
    int completedJobs = 0;
    
    for(int i = 0; i < totalActiveJobs; i++)
    {
        if(activeOrphanJobs[i].isCompleted) continue;
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ job ‡∏ô‡∏µ‡πâ‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
        if(CheckOrphanJobCompletion(i))
        {
            // Job ‡πÄ‡∏™‡∏£‡πá‡∏à ‚Üí ‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡∏∞‡∏•‡∏ö
            CompleteOrphanJob(i);
            completedJobs++;
        }
        else
        {
            // ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏™‡∏£‡πá‡∏à ‚Üí ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ orphan tickets
            ManageOrphanTicketsInJob(i);
        }
    }
    
    // ‡∏•‡∏ö job ‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å array
    if(completedJobs > 0)
    {
        CompactOrphanJobsArray();
        Print("üßπ ORPHAN WORKER: Completed " + IntegerToString(completedJobs) + " jobs | Remaining: " + IntegerToString(totalActiveJobs));
        
        // ‡πÅ‡∏à‡πâ‡∏á Universal ‡πÉ‡∏´‡πâ‡∏´‡∏≤‡∏á‡∏≤‡∏ô‡πÉ‡∏´‡∏°‡πà
        if(totalActiveJobs < MaxOrphansPerCycle)
        {
            ManageOrphanUniversal();
        }
    }
}

// +------------------------------------------------------------------+
//| Check Orphan Job Completion                                      |
//+------------------------------------------------------------------+
bool CheckOrphanJobCompletion(int jobIndex)
{
    double totalProfit = 0;
    int activeOrphans = 0;
    
    for(int i = 0; i < activeOrphanJobs[jobIndex].orphanCount; i++)
    {
        ulong ticket = activeOrphanJobs[jobIndex].orphanTickets[i];
        if(PositionSelectByTicket(ticket))
        {
            activeOrphans++;
            totalProfit += PositionGetDouble(POSITION_PROFIT);
        }
    }
    
    // ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç job ‡πÄ‡∏™‡∏£‡πá‡∏à: ‡∏ñ‡∏∂‡∏á TP ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ orphan ‡πÄ‡∏´‡∏•‡∏∑‡∏≠
    bool profitTargetReached = (totalProfit >= activeOrphanJobs[jobIndex].targetProfit);
    bool noActiveOrphans = (activeOrphans == 0);
    
    if(profitTargetReached || noActiveOrphans)
    {
        Print("üéØ ORPHAN JOB READY FOR COMPLETION | Job ID: " + IntegerToString(activeOrphanJobs[jobIndex].jobId) + 
              " | Profit: $" + DoubleToString(totalProfit, 2) + 
              " | Target: $" + DoubleToString(activeOrphanJobs[jobIndex].targetProfit, 2) +
              " | Active Orphans: " + IntegerToString(activeOrphans));
        return true;
    }
    
    return false;
}

// +------------------------------------------------------------------+
//| Complete Orphan Job                                              |
//+------------------------------------------------------------------+
void CompleteOrphanJob(int jobIndex)
{
    // ‡∏õ‡∏¥‡∏î orphan tickets ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô job ‡∏ô‡∏µ‡πâ
    int closedCount = 0;
    double totalProfit = 0;
    
    for(int i = 0; i < activeOrphanJobs[jobIndex].orphanCount; i++)
    {
        ulong ticket = activeOrphanJobs[jobIndex].orphanTickets[i];
        if(PositionSelectByTicket(ticket))
        {
            double profit = PositionGetDouble(POSITION_PROFIT);
            if(trade.PositionClose(ticket))
            {
                closedCount++;
                totalProfit += profit;
            }
        }
    }
    
    // Mark job as completed
    activeOrphanJobs[jobIndex].isCompleted = true;
    
    Print("‚úÖ ORPHAN JOB COMPLETED | Job ID: " + IntegerToString(activeOrphanJobs[jobIndex].jobId) + 
          " | Main: #" + TicketToStr(activeOrphanJobs[jobIndex].mainTicket) +
          " | Orphans Closed: " + IntegerToString(closedCount) +
          " | Total Profit: $" + DoubleToString(totalProfit, 2) +
          " | Duration: " + IntegerToString((int)(TimeCurrent() - activeOrphanJobs[jobIndex].createdTime)/60) + " minutes");
}

// +------------------------------------------------------------------+
//| Manage Orphan Tickets In Job (‡πÅ‡∏ö‡∏ö‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà)              |
//+------------------------------------------------------------------+
void ManageOrphanTicketsInJob(int jobIndex)
{
    // ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ orphan tickets ‡πÉ‡∏ô job (‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡∏´‡∏≤‡∏Å‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô)
    for(int i = 0; i < activeOrphanJobs[jobIndex].orphanCount; i++)
    {
        ulong ticket = activeOrphanJobs[jobIndex].orphanTickets[i];
        if(PositionSelectByTicket(ticket))
        {
            double profit = PositionGetDouble(POSITION_PROFIT);
            
            // ‡∏´‡∏≤‡∏Å orphan ‡∏ï‡∏¥‡∏î‡∏•‡∏ö‡∏°‡∏≤‡∏Å ‚Üí ‡∏û‡∏¥‡∏à‡∏≤‡∏£‡∏ì‡∏≤‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠
            if(profit <= -localOrphanTrigger)
            {
                int helpCount = CountHelpForOrphan(ticket);
                if(helpCount < 3) // ‡∏à‡∏≥‡∏Å‡∏±‡∏î help ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 3 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á
                {
                    OpenOrphanHelpWithinJob(ticket, jobIndex);
                }
                else
                {
                    DebugPrint(2, "Orphan #" + TicketToStr(ticket) + ": Max help attempts reached (" + IntegerToString(helpCount) + ")");
                }
            }
        }
    }
}
// +------------------------------------------------------------------+
//| Count Help For Orphan (‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠ Orphan)      |
//+------------------------------------------------------------------+
int CountHelpForOrphan(ulong orphanTicket)
{
    int count = 0;
    string orphanTicketStr = TicketToStr(orphanTicket);
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            string comment = PositionGetString(POSITION_COMMENT);
            // ‡∏ô‡∏±‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏ó‡∏µ‡πà‡∏°‡∏µ ticket ‡∏ô‡∏µ‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô comment
            if(StringFind(comment, orphanTicketStr) != -1 && 
               StringFind(comment, "OrphanJob-Help") != -1)
            {
                count++;
            }
        }
    }
    return count;
}

// +------------------------------------------------------------------+
//| Open Orphan Help Within Job                                      |
//+------------------------------------------------------------------+
void OpenOrphanHelpWithinJob(ulong orphanTicket, int jobIndex)
{
    if(!PositionSelectByTicket(orphanTicket)) return;
    
    ENUM_POSITION_TYPE orphanType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
    string symbol = PositionGetString(POSITION_SYMBOL);
    
    // ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô help ‡∏†‡∏≤‡∏¢‡πÉ‡∏ô job ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
    int helpCountInJob = CountHelpInJob(jobIndex);
    if(helpCountInJob >= 3) // ‡∏à‡∏≥‡∏Å‡∏±‡∏î help 3 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ï‡πà‡∏≠ job
    {
        DebugPrint(2, "Orphan Job " + IntegerToString(activeOrphanJobs[jobIndex].jobId) + ": Max help attempts reached");
        return;
    }
    
    // ‚úÖ ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà
    double helpLot = CalculateSafeOrphanLot(orphanTicket, helpCountInJob);
    
    if(!CheckMargin(helpLot, symbol)) 
    {
        Print("‚ùå Insufficient margin for orphan help: " + DoubleToString(helpLot, 2));
        return;
    }
    
    trade.SetExpertMagicNumber(MAGIC_ORPHAN);
    bool success = false;
    string comment = "OrphanJob-Help-" + IntegerToString(activeOrphanJobs[jobIndex].jobId) + "-" + IntegerToString(helpCountInJob + 1);
    
    if(orphanType == POSITION_TYPE_BUY)
    {
        success = trade.Sell(helpLot, symbol, 0, 0, 0, comment);
    }
    else
    {
        success = trade.Buy(helpLot, symbol, 0, 0, 0, comment);
    }
    
    if(success)
    {
        Print("üÜò ORPHAN JOB HELP | Job ID: " + IntegerToString(activeOrphanJobs[jobIndex].jobId) + 
              " | Orphan: #" + TicketToStr(orphanTicket) +
              " | Help Lot: " + DoubleToString(helpLot, 2) +
              " | Help #" + IntegerToString(helpCountInJob + 1));
    }
    else
    {
        Print("‚ùå Failed to open orphan help: " + trade.ResultRetcodeDescription());
    }
}
// +------------------------------------------------------------------+
//| Find Orphan Tickets For Main                                     |
//+------------------------------------------------------------------+
void FindOrphanTicketsForMain(ulong mainTicket, OrphanJob &job)
{
    job.orphanCount = 0;
    
    // ‡∏´‡∏≤‡∏à‡∏≤‡∏Å Recovery Sets
    int setIndex = FindSetByMainTicket(mainTicket);
    if(setIndex != -1)
    {
        for(int i = 0; i < recoverySets[setIndex].subCount; i++)
        {
            if(job.orphanCount < 20) // ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô
            {
                job.orphanTickets[job.orphanCount] = recoverySets[setIndex].subTickets[i];
                job.orphanCount++;
            }
        }
    }
    
    // ‡∏´‡∏≤‡∏à‡∏≤‡∏Å positions ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    for(int i = 0; i < PositionsTotal(); i++)
    {
        if(job.orphanCount >= 20) break;
        
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        long magic = PositionGetInteger(POSITION_MAGIC);
        string comment = PositionGetString(POSITION_COMMENT);
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô orphan ‡∏Ç‡∏≠‡∏á main ‡∏ô‡∏µ‡πâ
        if((magic == MAGIC_RECOVERY || magic == MAGIC_INDIVIDUAL || magic == MAGIC_ORPHAN) &&
           StringFind(comment, TicketToStr(mainTicket)) != -1)
        {
            job.orphanTickets[job.orphanCount] = ticket;
            job.orphanCount++;
        }
    }
}

// +------------------------------------------------------------------+
//| Compact Orphan Jobs Array                                        |
//+------------------------------------------------------------------+
void CompactOrphanJobsArray()
{
    int newIndex = 0;
    for(int i = 0; i < totalActiveJobs; i++)
    {
        if(!activeOrphanJobs[i].isCompleted)
        {
            if(i != newIndex)
                activeOrphanJobs[newIndex] = activeOrphanJobs[i];
            newIndex++;
        }
    }
    totalActiveJobs = newIndex;
}

// +------------------------------------------------------------------+
//| Count Help In Job                                                |
//+------------------------------------------------------------------+
int CountHelpInJob(int jobIndex)
{
    int count = 0;
    for(int i = 0; i < activeOrphanJobs[jobIndex].orphanCount; i++)
    {
        ulong ticket = activeOrphanJobs[jobIndex].orphanTickets[i];
        if(PositionSelectByTicket(ticket))
        {
            string comment = PositionGetString(POSITION_COMMENT);
            if(StringFind(comment, "OrphanJob-Help") != -1)
                count++;
        }
    }
    return count;
}

// +------------------------------------------------------------------+
//| Print Orphan Jobs Status                                         |
//+------------------------------------------------------------------+
void PrintOrphanJobsStatus()
{
    if(totalActiveJobs == 0) 
    {
        Print("=== NO ACTIVE ORPHAN JOBS ===");
        return;
    }
    
    Print("=== ORPHAN JOBS STATUS ===");
    Print("Active Jobs: " + IntegerToString(totalActiveJobs) + "/" + IntegerToString(MaxOrphansPerCycle));
    
    for(int i = 0; i < totalActiveJobs; i++)
    {
        if(!activeOrphanJobs[i].isCompleted)
        {
            double totalProfit = 0;
            int activeCount = 0;
            
            for(int j = 0; j < activeOrphanJobs[i].orphanCount; j++)
            {
                if(PositionSelectByTicket(activeOrphanJobs[i].orphanTickets[j]))
                {
                    activeCount++;
                    totalProfit += PositionGetDouble(POSITION_PROFIT);
                }
            }
            
            Print("Job #" + IntegerToString(activeOrphanJobs[i].jobId) + 
                  " | Main: #" + TicketToStr(activeOrphanJobs[i].mainTicket) +
                  " | Orphans: " + IntegerToString(activeCount) + "/" + IntegerToString(activeOrphanJobs[i].orphanCount) +
                  " | Profit: $" + DoubleToString(totalProfit, 2) + 
                  " | Target: $" + DoubleToString(activeOrphanJobs[i].targetProfit, 2) +
                  " | Age: " + IntegerToString((int)(TimeCurrent() - activeOrphanJobs[i].createdTime)/60) + "m");
        }
    }
    Print("=== END ORPHAN JOBS STATUS ===");
}
//+------------------------------------------------------------------+
//| Clean Up Closed Universal Orphans                               |
//+------------------------------------------------------------------+
void CleanUpClosedUniversalOrphans()
{
    int newIndex = 0;
    for(int i = 0; i < totalUniversalOrphans; i++)
    {
        if(PositionSelectByTicket(universalOrphans[i].ticket))
        {
            if(i != newIndex)
            {
                universalOrphans[newIndex] = universalOrphans[i];
                lastOrphanHelpTime[newIndex] = lastOrphanHelpTime[i];
                orphanStopped[newIndex] = orphanStopped[i];
            }
            newIndex++;
        }
    }
    totalUniversalOrphans = newIndex;
}

//+------------------------------------------------------------------+
//| Sort Orphans By Priority                                        |
//+------------------------------------------------------------------+
void SortOrphansByPriority()
{
    for(int i = 0; i < totalUniversalOrphans - 1; i++)
    {
        for(int j = i + 1; j < totalUniversalOrphans; j++)
        {
            double scoreI = CalculateOrphanPriorityScore(i);
            double scoreJ = CalculateOrphanPriorityScore(j);
            
            if(scoreJ > scoreI)
            {
                // Swap orphans
                UniversalOrphan tempOrphan = universalOrphans[i];
                universalOrphans[i] = universalOrphans[j];
                universalOrphans[j] = tempOrphan;
                
                // Swap help times
                datetime tempTime = lastOrphanHelpTime[i];
                lastOrphanHelpTime[i] = lastOrphanHelpTime[j];
                lastOrphanHelpTime[j] = tempTime;
                
                // Swap stopped flags
                bool tempStopped = orphanStopped[i];
                orphanStopped[i] = orphanStopped[j];
                orphanStopped[j] = tempStopped;
            }
        }
    }
}


//+------------------------------------------------------------------+
//| Scan For Orphans                                                |
//+------------------------------------------------------------------+
void ScanForOrphans()
{
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            long magic = PositionGetInteger(POSITION_MAGIC);
            string comment = PositionGetString(POSITION_COMMENT);
            
            // Check if this is a helper position with missing main
            if(IsHelperPosition(magic) && HasMissingMain(comment))
            {
                RegisterOrphan(ticket, magic, comment);
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Check if position has missing main                             |
//+------------------------------------------------------------------+
bool HasMissingMain(string comment)
{
    ulong mainTicket = ExtractMainTicketFromComment(comment);
    if(mainTicket > 0 && !PositionSelectByTicket(mainTicket))
    {
        return true;
    }
    return false;
}

//+------------------------------------------------------------------+
//| Register Orphan                                                 |
//+------------------------------------------------------------------+
void RegisterOrphan(ulong ticket, long magic, string comment)
{
    // Check if already registered
    for(int i = 0; i < totalUniversalOrphans; i++)
    {
        if(universalOrphans[i].ticket == ticket)
            return;
    }
    
    if(totalUniversalOrphans >= 100) return;
    
    if(PositionSelectByTicket(ticket))
    {
        universalOrphans[totalUniversalOrphans].ticket = ticket;
        universalOrphans[totalUniversalOrphans].symbol = PositionGetString(POSITION_SYMBOL);
        universalOrphans[totalUniversalOrphans].type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        universalOrphans[totalUniversalOrphans].volume = PositionGetDouble(POSITION_VOLUME);
        universalOrphans[totalUniversalOrphans].openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        universalOrphans[totalUniversalOrphans].openTime = (datetime)PositionGetInteger(POSITION_TIME);
        universalOrphans[totalUniversalOrphans].recoveryCount = 0;
        universalOrphans[totalUniversalOrphans].totalProfit = PositionGetDouble(POSITION_PROFIT);
        universalOrphans[totalUniversalOrphans].originalStrategy = GetMagicStrategyName(magic);
        universalOrphans[totalUniversalOrphans].originalMagic = magic;
        
        lastOrphanHelpTime[totalUniversalOrphans] = 0;
        orphanStopped[totalUniversalOrphans] = false;
        
        totalUniversalOrphans++;
        
        Print("üÜò ORPHAN REGISTERED: #" + TicketToStr(ticket) + 
              " | Strategy: " + GetMagicStrategyName(magic) +
              " | Loss: $" + DoubleToString(universalOrphans[totalUniversalOrphans-1].totalProfit, 2));
    }
}

//+------------------------------------------------------------------+
//| Process Orphan Jobs                                             |
//+------------------------------------------------------------------+
void ProcessOrphanJobs()
{
    if(totalUniversalOrphans == 0) return;
    
    // Process one orphan per cycle to avoid over-trading
    for(int i = 0; i < totalUniversalOrphans; i++)
    {
        if(!orphanStopped[i] && PositionSelectByTicket(universalOrphans[i].ticket))
        {
            double currentProfit = PositionGetDouble(POSITION_PROFIT);
            universalOrphans[i].totalProfit = currentProfit;
            
            if(currentProfit <= -localOrphanTrigger && 
               universalOrphans[i].recoveryCount < localMaxOrphanSteps &&
               TimeCurrent() - lastOrphanHelpTime[i] >= 180)
            {
                if(HelpSingleOrphanStrict(i))
                {
                    break; // Process one orphan per cycle
                }
            }
        }
    }
}

string GetMagicName(long magic)
{
    if(magic == MAGIC_TREND_SCALP) return "TREND_SCALP";
    else if(magic == MAGIC_SCALP1) return "SCALP1";
    else if(magic == MAGIC_SCALP1_HF) return "SCALP1_HF";
    else if(magic == MAGIC_SCALP2) return "SCALP2";
    else if(magic == MAGIC_SCALP3) return "SCALP3";
    else if(magic == MAGIC_RECOVERY) return "RECOVERY";
    else if(magic == MAGIC_INDIVIDUAL) return "INDIVIDUAL";
    else if(magic == MAGIC_ORPHAN) return "ORPHAN";
    else if(magic == MAGIC_HEDGE) return "HEDGE";
    else if(magic == MAGIC_AI_NEWS) return "AI_NEWS";
    else if(magic == MAGIC_AI_TREND) return "AI_TREND";
    else if(magic == MAGIC_BREAKOUT) return "BREAKOUT";
    else if(magic == MAGIC_COUNTER) return "COUNTER";
    else if(magic == MAGIC_MAIN) return "MAIN";
    else return "UNKNOWN (" + IntegerToString((int)magic) + ")";
}

//+------------------------------------------------------------------+
//| Check And Close Hedged Pairs                                    |
//+------------------------------------------------------------------+
void CheckAndCloseHedgedPairs()
{
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket1 = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket1))
        {
            string symbol1 = PositionGetString(POSITION_SYMBOL);
            ENUM_POSITION_TYPE type1 = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            long magic1 = PositionGetInteger(POSITION_MAGIC);
            double profit1 = PositionGetDouble(POSITION_PROFIT);
            
            for(int j = i + 1; j < PositionsTotal(); j++)
            {
                ulong ticket2 = PositionGetTicket(j);
                if(PositionSelectByTicket(ticket2))
                {
                    string symbol2 = PositionGetString(POSITION_SYMBOL);
                    ENUM_POSITION_TYPE type2 = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
                    long magic2 = PositionGetInteger(POSITION_MAGIC);
                    double profit2 = PositionGetDouble(POSITION_PROFIT);
                    
                    if(symbol1 == symbol2 && type1 != type2)
                    {
                        double totalProfit = profit1 + profit2;
                        
                        // ‚úÖ ‡∏´‡∏≤ Target Profit ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏ô‡∏µ‡πâ
                        double correctTargetProfit = GetCorrectTargetProfit(magic1, magic2);
                        string strategyPair = GetMagicName(magic1) + " + " + GetMagicName(magic2);
                        
                        if(totalProfit >= correctTargetProfit) 
                        {
                            if(trade.PositionClose(ticket1) && trade.PositionClose(ticket2))
                            {
                                Print("üéØ HEDGE PAIR CLOSED | " +
                                      "Strategies: " + strategyPair + " | " +
                                      "Profit: $" + DoubleToString(totalProfit, 2) + " | " +
                                      "Target: $" + DoubleToString(correctTargetProfit, 2));
                                
                                Print("üéØ HEDGE TARGET REACHED | " + strategyPair + " | Profit: $" + DoubleToString(totalProfit, 2));
                               
                            }
                        }
                        else if(totalProfit > 0)
                        {
                            // Debug: ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡πà‡∏≤‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏Ñ‡∏π‡πà‡∏ô‡∏µ‡πâ
                            Print("üìä Monitoring: " + strategyPair + 
                                  " | Current: $" + DoubleToString(totalProfit, 2) + 
                                  " | Target: $" + DoubleToString(correctTargetProfit, 2));
                        }
                    }
                }
            }
        }
    }
}

// ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏≤ Target Profit ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå
double GetCorrectTargetProfit(long magic1, long magic2)
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡πÑ‡∏´‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏•‡∏±‡∏Å
    if(magic1 == MAGIC_SCALP1 || magic2 == MAGIC_SCALP1 || 
       magic1 == MAGIC_SCALP1_HF || magic2 == MAGIC_SCALP1_HF)
        return 15.0; // Default ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Scalp1
    
    else if(magic1 == MAGIC_SCALP2 || magic2 == MAGIC_SCALP2)
        return 10.0; // Default ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Scalp2
    
    else if(magic1 == MAGIC_SCALP3 || magic2 == MAGIC_SCALP3)
        return 20.0; // Default ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Scalp3
    
    else if(magic1 == MAGIC_TREND_SCALP || magic2 == MAGIC_TREND_SCALP)
        return 25.0; // Default ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Trend Scalp
    
    else if(magic1 == MAGIC_AI_NEWS || magic2 == MAGIC_AI_NEWS ||
            magic1 == MAGIC_AI_TREND || magic2 == MAGIC_AI_TREND)
        return 30.0; // Default ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö AI Strategies
    
    else if(magic1 == MAGIC_BREAKOUT || magic2 == MAGIC_BREAKOUT)
        return 15.0; // Default ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Breakout
    
    else
        return 5.0; // default ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏≠‡∏∑‡πà‡∏ô‡πÜ
}



//+------------------------------------------------------------------+
//| Prioritize And Execute Help                                     |
//+------------------------------------------------------------------+
void PrioritizeAndExecuteHelp()
{
    // Implementation for prioritizing which positions to help first
    // Based on loss amount, time open, and recovery count
    ulong mostNeedyTicket = 0;
    double highestPriority = 0;
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            long magic = PositionGetInteger(POSITION_MAGIC);
            if(IsHelperPosition(magic)) continue;
            
            double profit = PositionGetDouble(POSITION_PROFIT);
            double volume = PositionGetDouble(POSITION_VOLUME);
            datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
            
            if(profit < 0)
            {
                double priority = MathAbs(profit) * 10 + volume * 5 + (TimeCurrent() - openTime) / 3600.0;
                
                if(priority > highestPriority)
                {
                    highestPriority = priority;
                    mostNeedyTicket = ticket;
                }
            }
        }
    }
    
    if(mostNeedyTicket != 0)
    {
        Print("üéØ PRIORITY HELP: Ticket #" + TicketToStr(mostNeedyTicket) + " | Score: " + DoubleToString(highestPriority, 1));
        // Could trigger individual recovery or other help mechanisms here
    }
}
/*
//+------------------------------------------------------------------+
//| Execute Smart Batch Closing                                     |
//+------------------------------------------------------------------+
void ExecuteSmartBatchClosing()
{
    // Close multiple positions when overall portfolio reaches target
    double totalProfit = CalculateTotalProfit();
    
    if(totalProfit >= SmartCloseProfitTarget)
    {
        Print("üéâ BATCH CLOSING: Total profit target reached: $" + DoubleToString(totalProfit, 2));
        CloseAllPositions("ExecuteSmartBatchClosing", "SmartCloseProfitTarget");
    }
}
*/
//+------------------------------------------------------------------+
//| IsMarketGoodForTrading - ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°             |
//+------------------------------------------------------------------+
bool IsMarketGoodForTrading(string symbol)
{
    string sym = symbol;
    StringToUpper(sym);
    
    // 1. ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Volatility ‡∏î‡πâ‡∏ß‡∏¢ ATR
    double atr = CalculateATR(14, 0, symbol);
    double currentPrice = SymbolInfoDouble(symbol, SYMBOL_BID);
    double atrPercent = (atr / currentPrice) * 100;
    
    DebugPrint(3, "Market Check - " + symbol + " | ATR: " + DoubleToString(atrPercent, 3) + "%");
    
    if(atrPercent < 0.03) // ATR ‡∏ï‡πà‡∏≥‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ (‡∏ï‡∏•‡∏≤‡∏î‡πÄ‡∏á‡∏µ‡∏¢‡∏ö)
    {
        DebugPrint(2, "‚ùå Market too quiet - ATR: " + DoubleToString(atrPercent, 3) + "%");
        return false;
    }
    
    if(atrPercent > 0.5) // ATR ‡∏™‡∏π‡∏á‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ (‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô)
    {
        DebugPrint(2, "‚ùå Market too volatile - ATR: " + DoubleToString(atrPercent, 3) + "%");
        return false;
    }
    
    // 2. ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Session Time
    MqlDateTime timeStruct;
    TimeToStruct(TimeCurrent(), timeStruct);
    int hour = timeStruct.hour;
    int dayOfWeek = timeStruct.day_of_week; // 1=Sunday, 7=Saturday
    
    // ‡πÑ‡∏°‡πà‡πÄ‡∏ó‡∏£‡∏î‡∏ß‡∏±‡∏ô‡πÄ‡∏™‡∏≤‡∏£‡πå-‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå
    if(dayOfWeek == 6 || dayOfWeek == 7) // Saturday or Sunday
    {
        DebugPrint(2, "‚ùå Weekend - no trading");
        return false;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå
    if(StringFind(sym, "XAU") != -1) // Gold
    {
        // Gold - ‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏ó‡∏£‡∏î‡∏ó‡∏µ‡πà‡∏î‡∏µ 08:00-22:00 (Session London/NY)
        if(hour < 8 || hour >= 22)
        {
            DebugPrint(2, "‚ùå Gold: Outside trading hours (" + IntegerToString(hour) + ":00)");
            return false;
        }
    }
    else if(StringFind(sym, "USD") != -1 || 
            StringFind(sym, "EUR") != -1 ||
            StringFind(sym, "GBP") != -1 ||
            StringFind(sym, "JPY") != -1) // Forex
    {
        // Forex - ‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏ó‡∏£‡∏î‡∏ó‡∏µ‡πà‡∏î‡∏µ 02:00-20:00 (Session Overlap)
        if(hour < 2 || hour >= 20)
        {
            DebugPrint(2, "‚ùå Forex: Outside trading hours (" + IntegerToString(hour) + ":00)");
            return false;
        }
    }
    else // ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏≠‡∏∑‡πà‡∏ô‡πÜ
    {
        // ‡πÄ‡∏ó‡∏£‡∏î‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ß‡∏±‡∏ô‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå-‡∏®‡∏∏‡∏Å‡∏£‡πå 08:00-18:00
        if(hour < 8 || hour >= 18)
        {
            DebugPrint(2, "‚ùå Other: Outside trading hours (" + IntegerToString(hour) + ":00)");
            return false;
        }
    }
    
    // 3. ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Spread
    double spread = SymbolInfoInteger(symbol, SYMBOL_SPREAD) * _Point;
    double spreadPips = spread / GetPipSize(symbol);
    
    if(spreadPips > 3.0)
    {
        DebugPrint(2, "‚ùå Spread too high: " + DoubleToString(spreadPips, 1) + " pips");
        return false;
    }
    
    DebugPrint(2, "‚úÖ Market conditions good for " + symbol);
    return true;
}
//+------------------------------------------------------------------+
//| GetTradingSession - ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Session ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô                   |
//+------------------------------------------------------------------+
string GetTradingSession()
{
    MqlDateTime timeStruct;
    TimeToStruct(TimeCurrent(), timeStruct);
    int hour = timeStruct.hour;
    
    if(hour >= 0 && hour < 5) return "ASIA";
    else if(hour >= 5 && hour < 13) return "LONDON";
    else if(hour >= 13 && hour < 17) return "LONDON_NY_OVERLAP";
    else if(hour >= 17 && hour < 21) return "NY";
    else return "EVENING";
}

//+------------------------------------------------------------------+
//| IsSessionGoodForTrading - ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Session ‡∏ô‡∏µ‡πâ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ó‡∏£‡∏î |
//+------------------------------------------------------------------+
bool IsSessionGoodForTrading(string symbol)
{
    string session = GetTradingSession();
    string sym = symbol;
    StringToUpper(sym);
    
    if(StringFind(sym, "XAU") != -1) // Gold
    {
        // Gold ‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á London ‡πÅ‡∏•‡∏∞ NY Overlap
        return (session == "LONDON" || session == "LONDON_NY_OVERLAP" || session == "NY");
    }
    else // Forex
    {
        // Forex ‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á Session Overlap
        return (session == "LONDON_NY_OVERLAP");
    }
}

//------------------------------------------------------------//

//+------------------------------------------------------------------+
//| Initialize Collaborative System                                 |
//+------------------------------------------------------------------+
void InitializeCollaborativeSystem()
{
    if(!EnableCooperativeSystem) return;
    
    strategies[0].name = "Scalp1";
    strategies[0].targetProfit = GlobalTargetProfit * StrategyWeight_Scalp1;
    strategies[0].isActive = Scalp1Enabled;
    
    strategies[1].name = "Scalp2"; 
    strategies[1].targetProfit = GlobalTargetProfit * StrategyWeight_Scalp2;
    strategies[1].isActive = Scalp2Enabled;
    
    strategies[2].name = "Scalp3";
    strategies[2].targetProfit = GlobalTargetProfit * StrategyWeight_Scalp3;
    strategies[2].isActive = Scalp3_Enabled;
    
    strategies[3].name = "Trend";
    strategies[3].targetProfit = GlobalTargetProfit * StrategyWeight_Trend;
    strategies[3].isActive = SimpleTrendScalpEnabled;
    
    strategies[4].name = "Breakout";
    strategies[4].targetProfit = GlobalTargetProfit * StrategyWeight_Breakout;
    strategies[4].isActive = BreakoutStrategy;
    
    collaborativeTarget = GlobalTargetProfit;
    cooperativeSystemInitialized = true;
    
    Print("=== ü§ù COOPERATIVE SYSTEM INITIALIZED ===");
    for(int i = 0; i < 5; i++) {
        Print("   " + strategies[i].name + " Target: $" + DoubleToString(strategies[i].targetProfit, 2) + 
              " | Active: " + (strategies[i].isActive ? "YES" : "NO"));
    }
    Print("   Total Target: $" + DoubleToString(collaborativeTarget, 2));
}

//+------------------------------------------------------------------+
//| Update Strategy Contributions                                   |
//+------------------------------------------------------------------+
void UpdateStrategyContributions()
{
    if(!cooperativeSystemInitialized) return;
    
    totalCollaborativeProfit = 0;
    
    // Reset all strategies
    for(int i = 0; i < 5; i++) {
        strategies[i].currentProfit = 0;
        strategies[i].positions = 0;
        strategies[i].contribution = 0;
        strategies[i].progress = 0;
    }
    
    // Calculate current profits per strategy
    for(int i = 0; i < PositionsTotal(); i++) {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket)) {
            long magic = PositionGetInteger(POSITION_MAGIC);
            double profit = PositionGetDouble(POSITION_PROFIT);
            
            int strategyIndex = GetStrategyIndexByMagic(magic);
            if(strategyIndex != -1) {
                strategies[strategyIndex].currentProfit += profit;
                strategies[strategyIndex].positions++;
                totalCollaborativeProfit += profit;
            }
        }
    }
    
    // üî• ‡πÄ‡∏û‡∏¥‡πà‡∏°: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ Recovery
    CheckRecoveryCoordination();
    
    // Calculate progress and contributions
    for(int i = 0; i < 5; i++) {
        if(strategies[i].targetProfit > 0) {
            strategies[i].progress = (strategies[i].currentProfit / strategies[i].targetProfit) * 100;
        }
        if(totalCollaborativeProfit != 0) {
            strategies[i].contribution = (strategies[i].currentProfit / totalCollaborativeProfit) * 100;
        }
    }
}
// üìç ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà
void BroadcastRecoveryMode(bool isRecoveryActive) {
   if(isRecoveryActive) {
      Print("üÜò BROADCAST: Entering Recovery Mode - All strategies cooperate!");
      BroadcastToAllSystems("RECOVERY_MODE_ACTIVATED");
      
      // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ Recovery ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡πà‡∏≤‡∏á‡πÜ
      recoveryModeActive = true;
      SystemMode = MODE_RECOVERY;
      
   } else {
      Print("‚úÖ BROADCAST: Exiting Recovery Mode - Returning to normal!");
      BroadcastToAllSystems("RECOVERY_MODE_ENDED");
      
      // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏Å‡∏ï‡∏¥‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡πà‡∏≤‡∏á‡πÜ
      recoveryModeActive = false;
      SystemMode = MODE_NORMAL;
   }
}
//+------------------------------------------------------------------+
//| Check Recovery Coordination                                     |
//+------------------------------------------------------------------+
void CheckRecoveryCoordination()
{
    // üî• ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤ Input ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì %
    if(TotalPortfolioProfit <= -Recovery_StartLevel) { 
        if(!recoveryModeActive) {
            recoveryStartTime = TimeCurrent();
            BroadcastRecoveryMode(true);
            Print("üÜò COOPERATIVE ACTIVATED at: " + DoubleToString(TotalPortfolioProfit, 2));
        }
    }
    
    // üî• ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤ Input ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏´‡∏¢‡∏∏‡∏î Recovery
    if(recoveryModeActive && TotalPortfolioProfit >= -Recovery_StopLevel) {
        BroadcastRecoveryMode(false);
        Print("‚úÖ COOPERATIVE STOPPED at: " + DoubleToString(TotalPortfolioProfit, 2));
    }
}

// üìç ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà
int FindBestPerformingStrategy()
{
    int bestIndex = -1;
    double bestProgress = -1000000;
    
    for(int i = 0; i < 5; i++) {
        if(strategies[i].isActive && strategies[i].progress > bestProgress) {
            bestProgress = strategies[i].progress;
            bestIndex = i;
        }
    }
    
    return bestIndex;
}

// üìç ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà
void SupportRecoveryOperation(int supporterIndex, int leaderIndex)
{
    // ‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô‡∏•‡∏î‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡∏ô‡∏≥ Recovery ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏î‡∏µ‡∏Ç‡∏∂‡πâ‡∏ô
    Print("   ü§ù " + strategies[supporterIndex].name + " supporting " + strategies[leaderIndex].name);
    
    // ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏° logic ‡∏Å‡∏≤‡∏£‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà
    // ‡πÄ‡∏ä‡πà‡∏ô ‡∏•‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡∏•‡∏≠‡∏ï, ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î, ‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ö‡∏≤‡∏á‡∏™‡πà‡∏ß‡∏ô
}

// üìç ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà
void AdjustStrategyWeightsForRecovery()
{
    // ‡πÉ‡∏ô‡πÇ‡∏´‡∏°‡∏î Recovery ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏ú‡∏•‡∏á‡∏≤‡∏ô‡∏î‡∏µ
    int bestPerformer = FindBestPerformingStrategy();
    
    if(bestPerformer != -1) {
        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡πÉ‡∏´‡πâ‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß
        double tempWeight = StrategyWeight_Scalp1;
        
        // ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏õ‡∏£‡∏±‡∏ö‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡∏ï‡∏≤‡∏°‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÑ‡∏î‡πâ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà
        Print("üìä Temporary weight adjustment for recovery mode");
    }
}
//+------------------------------------------------------------------+
//| Execute Cooperative Recovery Actions                           |
//+------------------------------------------------------------------+
void ExecuteCooperativeRecoveryActions()
{
    // üî• ‡∏´‡∏≤‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏ú‡∏•‡∏á‡∏≤‡∏ô‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏°‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ú‡∏π‡πâ‡∏ô‡∏≥ Recovery
    int bestPerformer = FindBestPerformingStrategy();
    
    if(bestPerformer != -1) {
        Print("üèÜ RECOVERY LEADER: " + strategies[bestPerformer].name + 
              " leading recovery operations");
        
        // ‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏ä‡πà‡∏ß‡∏¢‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô
        for(int i = 0; i < 5; i++) {
            if(i != bestPerformer && strategies[i].isActive) {
                SupportRecoveryOperation(i, bestPerformer);
            }
        }
    }
    
    // üî• ‡∏õ‡∏£‡∏±‡∏ö‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß‡πÉ‡∏ô‡πÇ‡∏´‡∏°‡∏î Recovery
    AdjustStrategyWeightsForRecovery();
}
//+------------------------------------------------------------------+
//| Get Strategy Index by Magic Number                              |
//+------------------------------------------------------------------+
int GetStrategyIndexByMagic(long magic)
{
    // ‡πÉ‡∏ä‡πâ if-else chain ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏õ‡∏±‡∏ç‡∏´‡∏≤ type conversion
    if(magic == (long)MAGIC_SCALP1) return 0;
    if(magic == (long)MAGIC_SCALP2) return 1;
    if(magic == (long)MAGIC_SCALP3) return 2;
    if(magic == (long)MAGIC_TREND_SCALP) return 3;
    if(magic == (long)MAGIC_BREAKOUT) return 4;
    
    return -1; // ‡πÑ‡∏°‡πà‡∏û‡∏ö strategy
}
//+------------------------------------------------------------------+
//| Manage Cooperative Strategies                                   |
//+------------------------------------------------------------------+
void ManageCooperativeStrategies(ENUM_MARKET_REGIME regime = MARKET_REGIME_NORMAL) 
{
    if(!EnableCooperativeSystem || !cooperativeSystemInitialized) return;
    
    UpdateStrategyContributions();
    
    double progress = (totalCollaborativeProfit / collaborativeTarget) * 100;
    
    // Display real-time status
    Print("=== ü§ù COOPERATIVE PROGRESS: " + DoubleToString(progress, 1) + "% ===");
    Print("Market Regime: " + EnumToString(regime));
    Print("Total: $" + DoubleToString(totalCollaborativeProfit, 2) + " / $" + DoubleToString(collaborativeTarget, 2));
    
    for(int i = 0; i < 5; i++) 
    {
        if(strategies[i].isActive) 
        {
            string status = (strategies[i].progress >= 80) ? "üéØ NEAR TARGET" : "üìä WORKING";
            if(strategies[i].progress >= 100) status = "‚úÖ TARGET ACHIEVED";
            
            Print("   " + strategies[i].name + ": $" + DoubleToString(strategies[i].currentProfit, 2) + 
                  " / $" + DoubleToString(strategies[i].targetProfit, 2) + 
                  " (" + DoubleToString(strategies[i].progress, 1) + "%) " + status);
        }
    }
    
    // ‡∏õ‡∏£‡∏±‡∏ö cooperative target ‡∏ï‡∏≤‡∏° market regime
    AdjustCooperativeTarget(regime);
    
    // Check for global target achievement
    if(totalCollaborativeProfit >= collaborativeTarget) 
    {
        ExecuteGlobalTakeProfit();
    }
    
    // ‡∏õ‡∏£‡∏±‡∏ö‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå cooperative ‡∏ï‡∏≤‡∏° market regime
    AdjustCooperativeStrategiesByRegime(regime);
}
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
void AdjustCooperativeTarget(ENUM_MARKET_REGIME regime)
{
    switch(regime)
    {
        case MARKET_REGIME_TRENDING_STRONG:
            // ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á ‡∏≠‡∏≤‡∏à‡πÄ‡∏û‡∏¥‡πà‡∏° target
            collaborativeTarget = MathMax(collaborativeTarget, BaseCollaborativeTarget * 1.2);
            break;
            
        case MARKET_REGIME_RANGING_VOLATILE:
            // ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô ‡∏•‡∏î target
            collaborativeTarget = MathMax(collaborativeTarget * 0.8, BaseCollaborativeTarget * 0.5);
            break;
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            // ‡πÉ‡∏ô breakout ‡πÉ‡∏ä‡πâ target ‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô
            collaborativeTarget = BaseCollaborativeTarget;
            break;
    }
}
void AdjustCooperativeStrategiesByRegime(ENUM_MARKET_REGIME regime)
{
    for(int i = 0; i < 5; i++) 
    {
        if(strategies[i].isActive) 
        {
            switch(regime)
            {
                case MARKET_REGIME_TRENDING_STRONG:
                    // ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô trend strategies
                    if(strategies[i].name == "TrendStrategy") 
                    {
                        strategies[i].isActive = true;
                        strategies[i].targetProfit = BaseCollaborativeTarget * 1.5;
                    }
                    break;
                    
                case MARKET_REGIME_RANGING_CALM:
                    // ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô range strategies
                    if(strategies[i].name == "RangeStrategy") 
                    {
                        strategies[i].isActive = true;
                        strategies[i].targetProfit = BaseCollaborativeTarget * 0.8;
                    }
                    break;
                    
                case MARKET_REGIME_RANGING_VOLATILE:
                    // ‡∏õ‡∏¥‡∏î‡∏ö‡∏≤‡∏á strategies ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
                    if(strategies[i].name == "TrendStrategy" || strategies[i].name == "BreakoutStrategy") 
                    {
                        strategies[i].isActive = false;
                    }
                    break;
            }
        }
    }
}

//--------------TEAM--------------------------//
void SetupMissionTeam() {
    // üéØ TRADING TEAMS (5 ‡∏ó‡∏µ‡∏°)
    strategyMissionTeam[0] = "QUICK_STRIKE_TEAM";     // Scalp1 - ‡∏ó‡∏µ‡∏°‡∏à‡∏π‡πà‡πÇ‡∏à‡∏°‡πÄ‡∏£‡πá‡∏ß
    strategyMissionTeam[1] = "INCOME_SUPPORT_TEAM";   // Scalp2 - ‡∏ó‡∏µ‡∏°‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô‡∏£‡∏≤‡∏¢‡πÑ‡∏î‡πâ  
    strategyMissionTeam[2] = "SPECIAL_OPS_TEAM";      // Scalp3 - ‡∏ó‡∏µ‡∏°‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏û‡∏¥‡πÄ‡∏®‡∏©
    strategyMissionTeam[3] = "TREND_CONTROL_TEAM";    // Trend - ‡∏ó‡∏µ‡∏°‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå
    strategyMissionTeam[4] = "BREAKOUT_SQUAD_TEAM";   // Breakout - ‡∏ó‡∏µ‡∏°‡∏à‡∏±‡∏ö‡∏à‡∏∏‡∏î‡πÅ‡∏ï‡∏Å‡∏´‡∏±‡∏Å
    
    // üõ°Ô∏è RECOVERY TEAMS (6 ‡∏ó‡∏µ‡∏°)
    strategyMissionTeam[5] = "INDIVIDUAL_RECOVERY_TEAM";    // Individual Recovery
    strategyMissionTeam[6] = "STEPUP_RECOVERY_TEAM";        // Step-Up Recovery
    strategyMissionTeam[7] = "COUNTER_ATTACK_TEAM";         // Counter Position
    strategyMissionTeam[8] = "HEDGE_DEFENSE_TEAM";          // Emergency Hedge
    strategyMissionTeam[9] = "ORPHAN_RESCUE_TEAM";          // Orphan Management
    strategyMissionTeam[10] = "ULTIMATE_FIGHTING_TEAM";     // Ultimate Fighting
    
    // ‚úÖ ‡∏ó‡∏∏‡∏Å‡∏ó‡∏µ‡∏°‡πÉ‡∏ä‡πâ‡∏•‡∏≠‡∏ï‡∏õ‡∏Å‡∏ï‡∏¥ 100%
    Mission.lotSize = 1.0; // 100%
    
    Print("‚úÖ MISSION TEAMS SETUP: 5 Trading + 6 Recovery Teams Ready!");
}
// ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà: ‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏∑‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡∏°
void UpdateTeamProgress() {
    double totalMissionProgress = 0;
    int activeTeams = 0;
    int totalTeams = 11; // 5 Trading + 6 Recovery
    
    // üîÑ ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó progress ‡∏ó‡∏±‡πâ‡∏á 11 ‡∏ó‡∏µ‡∏°
    for(int i = 0; i < totalTeams; i++) {
        double teamProgress = CalculateTeamProgress(strategyMissionTeam[i]);
        strategyMissionProgress[i] = teamProgress;
        totalMissionProgress += teamProgress;
        
        // ‡∏ô‡∏±‡∏ö‡∏ó‡∏µ‡∏°‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏î‡∏µ
        if(teamProgress > 0) activeTeams++;
        
        // ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ó‡∏µ‡∏°‡πÉ‡∏Å‡∏•‡πâ‡∏ö‡∏£‡∏£‡∏•‡∏∏‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢
        if(teamProgress >= 80) {
            Print("üéØ " + strategyMissionTeam[i] + " nearing target: " + 
                  DoubleToString(teamProgress, 1) + "%");
        }
    }
    
    // üèÜ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏†‡∏≤‡∏£‡∏Å‡∏¥‡∏à‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
    double averageProgress = totalMissionProgress / totalTeams;
    if(averageProgress >= 70 && activeTeams >= 6) { // 70% ‡πÇ‡∏î‡∏¢‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢ ‡πÅ‡∏•‡∏∞ 6 ‡∏ó‡∏µ‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
        Mission.missionCompleted = true;
        Mission.totalProgress = averageProgress;
        Mission.activeTeamsCount = activeTeams;
        
        Print("üéâ MISSION ACCOMPLISHED! " + 
              DoubleToString(averageProgress, 1) + "% Average | " + 
              IntegerToString(activeTeams) + "/" + IntegerToString(totalTeams) + " Teams Active");
              
        // üéØ ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ó‡∏∏‡∏Å‡∏£‡∏∞‡∏ö‡∏ö
        BroadcastToAllSystems("MISSION_COMPLETED");
    }
}
// ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà: ‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏î‡∏ä‡∏ö‡∏≠‡∏£‡πå‡∏î‡∏ó‡∏µ‡∏°
void DisplayTeamDashboard() {
    string teamDashboard = "=== ü§ù FULL TEAM COOPERATION DASHBOARD ===\n";
    double totalProgress = 0;
    int totalTeams = 11;
    
    // TRADING TEAMS
    teamDashboard += "--- TRADING TEAMS ---\n";
    for(int i = 0; i < 5; i++) {
        string statusIcon = (strategyMissionProgress[i] > 0) ? "‚úÖ" : "‚è∏Ô∏è";
        teamDashboard += StringFormat("%s %-20s: %5.1f%%\n", 
                          statusIcon, 
                          strategyMissionTeam[i], 
                          strategyMissionProgress[i]);
        totalProgress += strategyMissionProgress[i];
    }
    
    // RECOVERY TEAMS  
    teamDashboard += "--- RECOVERY TEAMS ---\n";
    for(int i = 5; i < totalTeams; i++) {
        string statusIcon = (IsRecoveryTeamActive(i)) ? "üõ°Ô∏è" : "üí§";
        teamDashboard += StringFormat("%s %-20s: %5.1f%%\n", 
                          statusIcon, 
                          strategyMissionTeam[i], 
                          strategyMissionProgress[i]);
        totalProgress += strategyMissionProgress[i];
    }
    
    teamDashboard += "----------------------------------------\n";
    teamDashboard += StringFormat("üéØ TOTAL MISSION PROGRESS: %.1f%%\n", totalProgress / totalTeams);
    teamDashboard += StringFormat("üìä ACTIVE TEAMS: %d/%d\n", CountActiveTeams(), totalTeams);
    teamDashboard += StringFormat("üí∞ DAILY TARGET: $%.2f\n", CalculateDailyMissionTarget());
    
    Comment(teamDashboard);
}

bool IsRecoveryTeamActive(int teamIndex) {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Recovery Team ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà‡πÑ‡∏´‡∏°
    switch(teamIndex) {
        case 5: return EnableIndividualRecovery;  // INDIVIDUAL_RECOVERY_TEAM
        case 6: return StepUpRecoveryEnabled;      // STEPUP_RECOVERY_TEAM
        case 7: return EnableCounterPosition;      // COUNTER_ATTACK_TEAM
        case 8: return UseEmergencyHedge;          // HEDGE_DEFENSE_TEAM
        case 9: return EnableUniversalOrphan;      // ORPHAN_RESCUE_TEAM
        case 10: return UltimateFightingMode;      // ULTIMATE_FIGHTING_TEAM
        default: return false;
    }
}
// ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠
double CalculateTeamProgress(string teamName) {
    // TRADING TEAMS (‡πÉ‡∏ä‡πâ profit-based progress)
    if(teamName == "QUICK_STRIKE_TEAM" || teamName == "INCOME_SUPPORT_TEAM" || 
       teamName == "SPECIAL_OPS_TEAM" || teamName == "TREND_CONTROL_TEAM" || 
       teamName == "BREAKOUT_SQUAD_TEAM") {
        
        int strategyIndex = GetStrategyIndexByTeam(teamName);
        if(strategyIndex == -1) return 0;
        
        double currentProfit = strategies[strategyIndex].currentProfit;
        double targetProfit = strategies[strategyIndex].targetProfit;
        
        if(targetProfit <= 0) return 0;
        
        double progress = (currentProfit / targetProfit) * 100.0;
        return MathMin(progress, 100.0);
    }
    
    // RECOVERY TEAMS (‡πÉ‡∏ä‡πâ activity-based progress)
    else {
        return CalculateRecoveryTeamProgress(teamName);
    }
}
double CalculateRecoveryTeamProgress(string teamName) {
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏∑‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏Ç‡∏≠‡∏á Recovery Teams ‡πÅ‡∏ö‡∏ö‡∏á‡πà‡∏≤‡∏¢
    if(teamName == "INDIVIDUAL_RECOVERY_TEAM") {
        return EnableIndividualRecovery ? 60.0 : 0.0;
    }
    else if(teamName == "STEPUP_RECOVERY_TEAM") {
        return StepUpRecoveryEnabled ? 50.0 : 0.0;
    }
    else if(teamName == "COUNTER_ATTACK_TEAM") {
        return EnableCounterPosition ? 40.0 : 0.0;
    }
    else if(teamName == "HEDGE_DEFENSE_TEAM") {
        return UseEmergencyHedge ? 30.0 : 0.0;
    }
    else if(teamName == "ORPHAN_RESCUE_TEAM") {
        return EnableUniversalOrphan ? 70.0 : 0.0;
    }
    else if(teamName == "ULTIMATE_FIGHTING_TEAM") {
        return UltimateFightingMode ? 90.0 : 0.0;
    }
    
    return 0.0;
}
//--Recovery Teams-//
bool IsIndividualRecoveryActive() {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Individual Recovery ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô (‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ò‡∏µ‡∏á‡πà‡∏≤‡∏¢‡πÜ)
    return EnableIndividualRecovery; // ‡πÅ‡∏Ñ‡πà‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Å‡πá‡∏ô‡∏±‡∏ö‡∏ß‡πà‡∏≤‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
}

bool IsStepUpRecoveryActive() {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Step-Up Recovery ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
    return StepUpRecoveryEnabled;
}

bool IsCounterPositionActive() {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Counter Position ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô  
    return EnableCounterPosition;
}

bool IsHedgeActive() {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Hedge ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
    return UseEmergencyHedge;
}

bool IsOrphanManagementActive() {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Orphan Management ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
    return EnableUniversalOrphan;
}

bool IsUltimateFightingActive() {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Ultimate Fighting ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
    return UltimateFightingMode;
}
//---//
int GetStrategyIndexByTeam(string teamName) {
    for(int i = 0; i < 5; i++) {
        if(strategies[i].missionTeam == teamName) {
            return i;
        }
    }
    return -1;
}

int CountActiveTeams() {
    int count = 0;
    for(int i = 0; i < 5; i++) {
        if(strategies[i].missionProgress > 0) {
            count++;
        }
    }
    return count;
}

string GetTeamTask(string teamName) {
    // TRADING TEAMS
    if(teamName == "QUICK_STRIKE_TEAM") return "Fast scalp entries in ranging markets";
    if(teamName == "INCOME_SUPPORT_TEAM") return "Consistent profit generation";
    if(teamName == "SPECIAL_OPS_TEAM") return "Handle special market conditions";
    if(teamName == "TREND_CONTROL_TEAM") return "Capture and ride strong trends";
    if(teamName == "BREAKOUT_SQUAD_TEAM") return "Exploit breakout opportunities";
    
    // RECOVERY TEAMS
    if(teamName == "INDIVIDUAL_RECOVERY_TEAM") return "Fix individual losing positions";
    if(teamName == "STEPUP_RECOVERY_TEAM") return "Gradual portfolio recovery";
    if(teamName == "COUNTER_ATTACK_TEAM") return "Counter-trend position management";
    if(teamName == "HEDGE_DEFENSE_TEAM") return "Emergency hedging protection";
    if(teamName == "ORPHAN_RESCUE_TEAM") return "Orphan position management";
    if(teamName == "ULTIMATE_FIGHTING_TEAM") return "Final stage recovery operations";
    
    return "General trading operations";
}

double CalculateDailyMissionTarget() {
    // ‡πÉ‡∏ä‡πâ existing collaborative target
    if(collaborativeTarget > 0) {
        return collaborativeTarget;
    }
    
    // Fallback calculation
    return GlobalTargetProfit;
}
// ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î (‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏°)

bool IsMarketRanging() {
    // ‡πÉ‡∏ä‡πâ iATR ‡πÅ‡∏ö‡∏ö MQL5 ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
    double atrArray[];
    ArraySetAsSeries(atrArray, true);
    
    int atrHandle = iATR(_Symbol, PERIOD_H1, 14);
    if(atrHandle == INVALID_HANDLE) return false;
    
    if(CopyBuffer(atrHandle, 0, 0, 1, atrArray) < 1) {
        IndicatorRelease(atrHandle);
        return false;
    }
    
    double atr = atrArray[0];
    IndicatorRelease(atrHandle);
    
    double atrPercent = (atr / SymbolInfoDouble(_Symbol, SYMBOL_BID)) * 100;
    return (atrPercent < 0.08);
}

bool IsMarketTrending() {
    // ‡πÉ‡∏ä‡πâ ADX ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏£‡∏á‡∏Ç‡∏≠‡∏á‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå
    double adxArray[];
    ArraySetAsSeries(adxArray, true);
    
    int adxHandle = iADX(_Symbol, PERIOD_H1, 14);
    if(adxHandle == INVALID_HANDLE) return false;
    
    if(CopyBuffer(adxHandle, 0, 0, 1, adxArray) < 1) {
        IndicatorRelease(adxHandle);
        return false;
    }
    
    double adx = adxArray[0];
    IndicatorRelease(adxHandle);
    
    return (adx > 25.0); // ADX > 25 = ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á
}

bool IsMarketBreakingOut() {
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_M15, 0, 3, rates) != 3) return false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Breakout ‡πÅ‡∏ö‡∏ö‡∏á‡πà‡∏≤‡∏¢
    bool bullishBreakout = (rates[2].high < rates[1].high && 
                           rates[1].high < rates[0].high && 
                           rates[0].close > rates[1].high);
    
    bool bearishBreakout = (rates[2].low > rates[1].low && 
                           rates[1].low > rates[0].low && 
                           rates[0].close < rates[1].low);
    
    return (bullishBreakout || bearishBreakout);
}

//--
//+------------------------------------------------------------------+
//| Get Detailed Market Status                                     |
//+------------------------------------------------------------------+
string GetDetailedMarketStatus()
{
    string status = "";
    
    // 1. üìä ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡∏ï‡∏•‡∏≤‡∏î
    double currentBid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double currentAsk = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    double spread = (currentAsk - currentBid) / GetPipSize(_Symbol);
    long spreadPoints = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD);
    
    status += "=== üìä MARKET STATUS REPORT ===\n";
    status += StringFormat("Symbol: %s | Bid: %.5f | Ask: %.5f\n", _Symbol, currentBid, currentAsk);
    status += StringFormat("Spread: %.1f pips (%d points)\n", spread, spreadPoints);
    
    // 2. üìà Volatility Analysis
    double atr1H = GetATRValue(_Symbol, PERIOD_H1, 14);
    double atr15M = GetATRValue(_Symbol, PERIOD_M15, 14);
    double atrPercent1H = (atr1H / currentBid) * 100;
    double atrPercent15M = (atr15M / currentBid) * 100;
    
    status += StringFormat("Volatility - ATR(H1): %.5f (%.3f%%) | ATR(M15): %.5f (%.3f%%)\n", 
                          atr1H, atrPercent1H, atr15M, atrPercent15M);
    
    // 3. üéØ Market Regime Detection
    ENUM_MARKET_REGIME regime = DetectMarketRegime();
    string regimeName = GetRegimeName(regime);
    int regimeScore = CalculateRegimeConfidence(regime);
    
    status += StringFormat("Market Regime: %s (Confidence: %d/100)\n", regimeName, regimeScore);
    
    // 4. üìâ Trend Analysis (Multiple Timeframes)
    string trendStatus = GetMultiTimeframeTrendStatus();
    status += trendStatus;
    
    // 5. üìä Support & Resistance Levels
    string srStatus = GetSupportResistanceStatus();
    status += srStatus;
    
    // 6. üîÑ Volume & Momentum
    string volumeStatus = GetVolumeMomentumStatus();
    status += volumeStatus;
    
    // 7. ‚ö†Ô∏è Risk Assessment
    string riskStatus = GetMarketRiskStatus();
    status += riskStatus;
    
    // 8. üïí Session & Timing
    string sessionStatus = GetTradingSessionStatus();
    status += sessionStatus;
    
    // 9. üéØ Trading Recommendations
    string recommendations = GetTradingRecommendations(regime);
    status += recommendations;
    
    status += "=== END MARKET REPORT ===\n";
    
    return status;
}

//+------------------------------------------------------------------+
//| Get Multi Timeframe Trend Status                               |
//+------------------------------------------------------------------+
string GetMultiTimeframeTrendStatus()
{
    string status = "--- üìà TREND ANALYSIS ---\n";
    
    ENUM_TIMEFRAMES timeframes[5] = {PERIOD_M5, PERIOD_M15, PERIOD_H1, PERIOD_H4, PERIOD_D1};
    string tfNames[5] = {"M5", "M15", "H1", "H4", "D1"};
    
    int bullishCount = 0;
    int bearishCount = 0;
    int neutralCount = 0;
    
    for(int i = 0; i < 5; i++) {
        ENUM_TREND_DIRECTION trend = AnalyzeTrendOnTimeframe(timeframes[i]);
        string trendIcon = "‚û°Ô∏è"; // Neutral
        
        switch(trend) {
            case TREND_UP: 
                trendIcon = "üü¢"; 
                bullishCount++;
                break;
            case TREND_DOWN: 
                trendIcon = "üî¥"; 
                bearishCount++;
                break;
            default: 
                trendIcon = "‚ö™"; 
                neutralCount++;
                break;
        }
        
        status += StringFormat("%s %s: %s | ", trendIcon, tfNames[i], GetTrendDirectionName(trend));
        
        // Add strength indicator
        double strength = CalculateTrendStrengthOnTimeframe(timeframes[i]);
        if(strength > 0.7) status += "üí™";
        else if(strength > 0.4) status += "üëç";
        else status += "üëé";
        
        status += "\n";
    }
    
    // Overall trend consensus
    string overallTrend = "NEUTRAL";
    if(bullishCount >= 3) overallTrend = "BULLISH";
    else if(bearishCount >= 3) overallTrend = "BEARISH";
    
    status += StringFormat("OVERALL TREND: %s (Bull:%d/Bear:%d/Neutral:%d)\n", 
                          overallTrend, bullishCount, bearishCount, neutralCount);
    
    return status;
}

//+------------------------------------------------------------------+
//| Get Support & Resistance Status                                |
//+------------------------------------------------------------------+
string GetSupportResistanceStatus()
{
    string status = "--- üìä SUPPORT & RESISTANCE ---\n";
    
    MqlRates rates[];
    int barsToCheck = 50;
    
    if(CopyRates(_Symbol, PERIOD_H1, 0, barsToCheck, rates) < barsToCheck) {
        status += "Unable to analyze S/R levels\n";
        return status;
    }
    
    // Find key levels
    double keySupport = FindKeySupportLevel(rates, barsToCheck);
    double keyResistance = FindKeyResistanceLevel(rates, barsToCheck);
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    if(keySupport > 0) {
        double distanceToSupport = (currentPrice - keySupport) / GetPipSize(_Symbol);
        status += StringFormat("Key Support: %.5f (%.1f pips below)\n", keySupport, distanceToSupport);
    } else {
        status += "Key Support: Not found\n";
    }
    
    if(keyResistance > 0) {
        double distanceToResistance = (keyResistance - currentPrice) / GetPipSize(_Symbol);
        status += StringFormat("Key Resistance: %.5f (%.1f pips above)\n", keyResistance, distanceToResistance);
    } else {
        status += "Key Resistance: Not found\n";
    }
    
    // Range analysis
    double rangeHigh = rates[0].high;
    double rangeLow = rates[0].low;
    for(int i = 1; i < barsToCheck; i++) {
        if(rates[i].high > rangeHigh) rangeHigh = rates[i].high;
        if(rates[i].low < rangeLow) rangeLow = rates[i].low;
    }
    
    double rangeHeight = (rangeHigh - rangeLow) / GetPipSize(_Symbol);
    double positionInRange = ((currentPrice - rangeLow) / (rangeHigh - rangeLow)) * 100;
    
    status += StringFormat("Range: %.1f pips | Position: %.1f%% (%s)\n", 
                          rangeHeight, positionInRange, 
                          positionInRange > 70 ? "Near Resistance" : 
                          positionInRange < 30 ? "Near Support" : "Mid-Range");
    
    return status;
}

//+------------------------------------------------------------------+
//| Get Volume & Momentum Status                                   |
//+------------------------------------------------------------------+
//+------------------------------------------------------------------+
//| Get Volume & Momentum Status (Fixed Version)                   |
//+------------------------------------------------------------------+
string GetVolumeMomentumStatus()
{
    string status = "--- üîÑ VOLUME & MOMENTUM ---\n";
    
    // Volume analysis
    long currentVolume = iVolume(_Symbol, PERIOD_H1, 0);
    long prevVolume = iVolume(_Symbol, PERIOD_H1, 1);
    long avgVolume = 0;
    
    for(int i = 1; i <= 5; i++) {
        avgVolume += iVolume(_Symbol, PERIOD_H1, i);
    }
    avgVolume /= 5;
    
    double volumeRatio = (double)currentVolume / avgVolume;
    string volumeStatus = volumeRatio > 1.5 ? "üìà HIGH" : volumeRatio > 0.8 ? "üìä NORMAL" : "üìâ LOW";
    
    status += StringFormat("Volume: %s (%.1fx average)\n", volumeStatus, volumeRatio);
    
    // Momentum indicators - FIXED VERSION
    double rsi = iRSI(_Symbol, PERIOD_H1, 14, PRICE_CLOSE, 0);
    string rsiStatusText; // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô string
    
    if(rsi > 70) 
        rsiStatusText = "OVERBOUGHT";
    else if(rsi < 30) 
        rsiStatusText = "OVERSOLD";
    else 
        rsiStatusText = "NEUTRAL";
    
    // ADX for trend strength
    double adx = GetADXValue(_Symbol, PERIOD_H1, 14);
    string adxStatus = adx > 25 ? "STRONG TREND" : adx > 20 ? "MODERATE TREND" : "WEAK/NO TREND";
    
    status += StringFormat("RSI(14): %.1f (%s) | ADX: %.1f (%s)\n", rsi, rsiStatusText, adx, adxStatus);
    
    return status;
}

//+------------------------------------------------------------------+
//| Get Market Risk Status                                         |
//+------------------------------------------------------------------+
string GetMarketRiskStatus()
{
    string status = "--- ‚ö†Ô∏è RISK ASSESSMENT ---\n";
    
    double riskScore = 0;
    string riskLevel = "LOW";
    string riskColor = "üü¢";
    
    // 1. Volatility risk
    double atrPercent = (GetATRValue(_Symbol, PERIOD_H1, 14) / SymbolInfoDouble(_Symbol, SYMBOL_BID)) * 100;
    if(atrPercent > 0.3) riskScore += 3;
    else if(atrPercent > 0.15) riskScore += 2;
    else if(atrPercent > 0.08) riskScore += 1;
    
    // 2. Spread risk
    long spreadPoints = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD);
    if(spreadPoints > 30) riskScore += 3;
    else if(spreadPoints > 15) riskScore += 2;
    else if(spreadPoints > 8) riskScore += 1;
    
    // 3. Time risk (trading session)
    MqlDateTime timeNow;
    TimeCurrent(timeNow);
    int hour = timeNow.hour;
    if(hour >= 22 || hour < 2) riskScore += 2; // Low liquidity hours
    
    // 4. News/Event risk (simplified - could integrate with economic calendar)
    if(IsHighImpactTime()) riskScore += 2;
    
    // Determine overall risk level
    if(riskScore >= 6) {
        riskLevel = "HIGH";
        riskColor = "üî¥";
    } else if(riskScore >= 3) {
        riskLevel = "MEDIUM";
        riskColor = "üü°";
    } else {
        riskLevel = "LOW";
        riskColor = "üü¢";
    }
    
    status += StringFormat("Risk Level: %s %s (Score: %d/8)\n", riskColor, riskLevel, riskScore);
    status += StringFormat("Factors - Volatility: %.3f%% | Spread: %d pts\n", atrPercent, spreadPoints);
    
    if(riskScore >= 6) {
        status += "‚ö†Ô∏è RECOMMENDATION: Reduce position sizes, avoid trading\n";
    } else if(riskScore >= 3) {
        status += "‚ö†Ô∏è RECOMMENDATION: Trade with caution, use smaller lots\n";
    } else {
        status += "‚úÖ RECOMMENDATION: Normal trading conditions\n";
    }
    
    return status;
}

//+------------------------------------------------------------------+
//| Get Trading Session Status                                     |
//+------------------------------------------------------------------+
string GetTradingSessionStatus()
{
    string status = "--- üïí TRADING SESSION ---\n";
    
    string session = GetTradingSession();
    MqlDateTime timeNow;
    TimeCurrent(timeNow);
    
    status += StringFormat("Current Session: %s\n", session);
    status += StringFormat("Local Time: %s\n", TimeToString(TimeCurrent(), TIME_MINUTES));
    
    // Session-specific advice
    if(session == "ASIA") {
        status += "üí° Focus: JPY pairs, Gold, Conservative trading\n";
    } else if(session == "LONDON") {
        status += "üí° Focus: EUR, GBP pairs, High volatility expected\n";
    } else if(session == "LONDON_NY_OVERLAP") {
        status += "üí° Focus: All major pairs, Highest volatility\n";
    } else if(session == "NY") {
        status += "üí° Focus: USD pairs, Good momentum opportunities\n";
    } else {
        status += "üí° Focus: Light trading, Wait for next session\n";
    }
    
    return status;
}

//+------------------------------------------------------------------+
//| Get Trading Recommendations                                    |
//+------------------------------------------------------------------+
string GetTradingRecommendations(ENUM_MARKET_REGIME regime)
{
    string status = "--- üéØ TRADING RECOMMENDATIONS ---\n";
    
    switch(regime) {
        case MARKET_REGIME_TRENDING_STRONG:
            status += "‚úÖ STRONG TREND DETECTED\n";
            status += "‚Ä¢ Use Trend-following strategies\n";
            status += "‚Ä¢ Trade in direction of trend\n";
            status += "‚Ä¢ Consider larger position sizes\n";
            status += "‚Ä¢ Look for pullback entries\n";
            break;
            
        case MARKET_REGIME_TRENDING_WEAK:
            status += "‚úÖ WEAK TREND DETECTED\n";
            status += "‚Ä¢ Use conservative trend strategies\n";
            status += "‚Ä¢ Smaller position sizes\n";
            status += "‚Ä¢ Wait for clear entry signals\n";
            status += "‚Ä¢ Consider range strategies as well\n";
            break;
            
        case MARKET_REGIME_RANGING_VOLATILE:
            status += "‚úÖ VOLATILE RANGE DETECTED\n";
            status += "‚Ä¢ Use Scalping strategies\n";
            status += "‚Ä¢ Trade range boundaries\n";
            status += "‚Ä¢ Quick entries and exits\n";
            status += "‚Ä¢ Tight stop losses\n";
            break;
            
        case MARKET_REGIME_RANGING_CALM:
            status += "‚úÖ CALM RANGE DETECTED\n";
            status += "‚Ä¢ Reduced trading activity\n";
            status += "‚Ä¢ Wait for breakout signals\n";
            status += "‚Ä¢ Smaller position sizes\n";
            status += "‚Ä¢ Focus on high-probability setups\n";
            break;
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            status += "‚úÖ BREAKOUT POTENTIAL DETECTED\n";
            status += "‚Ä¢ Prepare for breakout trades\n";
            status += "‚Ä¢ Monitor key support/resistance\n";
            status += "‚Ä¢ Have entry orders ready\n";
            status += "‚Ä¢ Wait for confirmation\n";
            break;
            
        default: // MARKET_REGIME_NORMAL
            status += "üìä NORMAL MARKET CONDITIONS\n";
            status += "‚Ä¢ Use balanced strategies\n";
            status += "‚Ä¢ Monitor trend development\n";
            status += "‚Ä¢ Be ready for regime changes\n";
            status += "‚Ä¢ Use standard position sizing\n";
            break;
    }
    
    // Add specific strategy recommendations
    string bestStrategies = GetRecommendedStrategies(regime);
    status += "Recommended Strategies: " + bestStrategies + "\n";
    
    return status;
}
string GetRecommendedStrategies(ENUM_MARKET_REGIME regime)
{
    switch(regime) {
        case MARKET_REGIME_TRENDING_STRONG:
            return "TrendScalp, Breakout";
        case MARKET_REGIME_TRENDING_WEAK:
            return "TrendScalp (conservative), Scalp1";
        case MARKET_REGIME_RANGING_VOLATILE:
            return "Scalp1, Scalp2, CounterPosition";
        case MARKET_REGIME_RANGING_CALM:
            return "Scalp1 (reduced), Breakout (prepare)";
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            return "Breakout, TrendScalp (prepare)";
        case MARKET_REGIME_NORMAL:
            return "All strategies (balanced)";
        default:
            return "Conservative approaches";
    }
}
void PrintTradingRecommendations()
{
    ENUM_MARKET_REGIME currentRegime = DetectMarketRegime();
    string recommendations = GetTradingRecommendations(currentRegime);
    
    Print(recommendations);
    
    // ‡∏´‡∏£‡∏∑‡∏≠‡πÅ‡∏™‡∏î‡∏á‡πÉ‡∏ô Comment ‡∏ö‡∏ô chart
    Comment(recommendations);
}
//+------------------------------------------------------------------+
//| Helper Functions                                               |
//+------------------------------------------------------------------+

double CalculateTrendStrengthOnTimeframe(ENUM_TIMEFRAMES tf)
{
    double ema9 = iMA(_Symbol, tf, 9, 0, MODE_EMA, PRICE_CLOSE);
    double ema21 = iMA(_Symbol, tf, 21, 0, MODE_EMA, PRICE_CLOSE);
    double ema50 = iMA(_Symbol, tf, 50, 0, MODE_EMA, PRICE_CLOSE);
    
    // Calculate alignment score
    double alignmentScore = 0;
    if(ema9 > ema21 && ema21 > ema50) alignmentScore = 1.0; // Perfect bullish
    else if(ema9 < ema21 && ema21 < ema50) alignmentScore = 1.0; // Perfect bearish
    else if((ema9 > ema21 && ema21 > ema50) || (ema9 < ema21 && ema21 < ema50)) alignmentScore = 0.5; // Partial alignment
    
    // Calculate slope strength
    double ema9Prev = iMA(_Symbol, tf, 9, 1, MODE_EMA, PRICE_CLOSE);
    double slope = MathAbs(ema9 - ema9Prev) / SymbolInfoDouble(_Symbol, SYMBOL_POINT);
    
    double slopeStrength = MathMin(slope / 10.0, 1.0); // Normalize
    
    return (alignmentScore * 0.7 + slopeStrength * 0.3);
}

double FindKeySupportLevel(MqlRates &rates[], int count)
{
    // Simple support level detection
    double lowest = rates[0].low;
    int touchCount = 0;
    
    for(int i = 1; i < count; i++) {
        if(rates[i].low < lowest) {
            lowest = rates[i].low;
            touchCount = 1;
        } else if(MathAbs(rates[i].low - lowest) < (lowest * 0.0005)) {
            touchCount++;
        }
    }
    
    return (touchCount >= 2) ? lowest : 0;
}

double FindKeyResistanceLevel(MqlRates &rates[], int count)
{
    // Simple resistance level detection
    double highest = rates[0].high;
    int touchCount = 0;
    
    for(int i = 1; i < count; i++) {
        if(rates[i].high > highest) {
            highest = rates[i].high;
            touchCount = 1;
        } else if(MathAbs(rates[i].high - highest) < (highest * 0.0005)) {
            touchCount++;
        }
    }
    
    return (touchCount >= 2) ? highest : 0;
}

double GetADXValue(string symbol, ENUM_TIMEFRAMES timeframe, int period, int shift = 0)
{
    double adxArray[];
    ArraySetAsSeries(adxArray, true);
    
    int handle = iADX(symbol, timeframe, period);
    if(handle == INVALID_HANDLE) {
        Print("Error: Cannot create ADX indicator handle");
        return 0;
    }
    
    int copied = CopyBuffer(handle, 0, shift, 1, adxArray); // Main ADX line
    IndicatorRelease(handle);
    
    if(copied <= 0) {
        Print("Error: Cannot copy ADX buffer");
        return 0;
    }
    
    return adxArray[0];
}
//+------------------------------------------------------------------+
//| Get RSI Value (Safe Implementation)                            |
//+------------------------------------------------------------------+
double GetRSISimple(int period = 14, int shift = 0, ENUM_TIMEFRAMES tf = PERIOD_H1)
{
    return GetRSIValue(_Symbol, tf, period, PRICE_CLOSE, shift);
}

double GetRSIValue(string symbol, ENUM_TIMEFRAMES timeframe, int period, int applied_price, int shift = 0)
{
    double rsiArray[];
    ArraySetAsSeries(rsiArray, true);
    
    int handle = iRSI(symbol, timeframe, period, applied_price);
    if(handle == INVALID_HANDLE) {
        Print("Error: Cannot create RSI indicator handle");
        return 50; // Return neutral value on error
    }
    
    int copied = CopyBuffer(handle, 0, shift, 1, rsiArray);
    IndicatorRelease(handle);
    
    if(copied <= 0) {
        Print("Error: Cannot copy RSI buffer");
        return 50;
    }
    
    return rsiArray[0];
}
bool CheckRSICondition()
{
    // ‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡∏á‡πà‡∏≤‡∏¢
    double rsi = GetRSISimple(14, 0, PERIOD_H1);
    
    if(rsi > 70) 
    {
        Print("Overbought condition");
        return false;
    }
    
    if(rsi < 30)
    {
        Print("Oversold condition");
        return false;
    }
    
    return true;
}

bool IsHighImpactTime()
{
    // Simplified high impact time detection
    // In real implementation, integrate with economic calendar
    MqlDateTime timeNow;
    TimeCurrent(timeNow);
    
    // Example: Assume high impact at certain hours (8 AM, 2 PM UTC)
    int hour = timeNow.hour;
    return (hour == 8 || hour == 14 || hour == 20);
}



int CalculateRegimeConfidence(ENUM_MARKET_REGIME regime)
{
    // Calculate confidence score based on multiple indicators
    int confidence = 50; // Base confidence
    
    // Add confidence based on indicator alignment
    double trendStrengthH1 = CalculateTrendStrengthOnTimeframe(PERIOD_H1);
    double trendStrengthH4 = CalculateTrendStrengthOnTimeframe(PERIOD_H4);
    
    if(MathAbs(trendStrengthH1 - trendStrengthH4) < 0.3) confidence += 20;
    
    // Add confidence based on volume
    long currentVolume = iVolume(_Symbol, PERIOD_H1, 0);
    long avgVolume = (iVolume(_Symbol, PERIOD_H1, 1) + iVolume(_Symbol, PERIOD_H1, 2)) / 2;
    if(currentVolume > avgVolume * 1.2) confidence += 15;
    
    return MathMin(confidence, 100);
}
bool HasMultipleBreakoutConfirmations(bool isBuy)
{
    int confirmations = 0;
    
    // 1. Price above/below key level
    if(isBuy)
    {
        if(SymbolInfoDouble(_Symbol, SYMBOL_BID) > GetResistanceLevel()) confirmations++;
    }
    else
    {
        if(SymbolInfoDouble(_Symbol, SYMBOL_BID) < GetSupportLevel()) confirmations++;
    }
    
    // 2. Volume confirmation
    if(HasBreakoutVolumeConfirmation(isBuy)) confirmations++;
    
    // 3. Candle pattern confirmation
    if(isBuy && HasBullishBreakoutCandle()) confirmations++;
    if(!isBuy && HasBearishBreakoutCandle()) confirmations++;
    
    // 4. Indicator confirmation (RSI) - ‡πÉ‡∏ä‡πâ GetRSIValue ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì
    double rsi = GetRSIValue(_Symbol, PERIOD_H1, 14, PRICE_CLOSE, 0);
    if(isBuy && rsi < 70) confirmations++;      // ‡πÑ‡∏°‡πà overbought ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö buy
    if(!isBuy && rsi > 30) confirmations++;     // ‡πÑ‡∏°‡πà oversold ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö sell
    
    // 5. Trend confirmation (optional)
    if(IsBreakoutWithTrend(isBuy)) confirmations++;
    
    if(EnableDebugMode) 
    {
        Print("Breakout confirmations for ", isBuy ? "BUY" : "SELL", ": ", confirmations, "/5");
    }
    
    // ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 3 confirmations
    return (confirmations >= 3);
}

bool IsBreakoutWithTrend(bool isBuy)
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ breakout ‡πÑ‡∏õ‡πÉ‡∏ô‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö trend ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    //double ema9 = GetEMAValue(9, 0, PERIOD_H1);
    //double ema21 = GetEMAValue(21, 0, PERIOD_H1);
    
     double ema9 = GetEMAValue(Symbol(), PERIOD_H1, 9, 0);
    double ema21 = GetEMAValue(Symbol(), PERIOD_H1, 21, 0);
    
    if(isBuy)
    {
        // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö buy breakout ‡∏Ñ‡∏ß‡∏£‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô uptrend
        return (ema9 > ema21);
    }
    else
    {
        // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö sell breakout ‡∏Ñ‡∏ß‡∏£‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô downtrend
        return (ema9 < ema21);
    }
}
//-GetDetailedMarketStatus()-

void ExecuteTeamByMarketCondition()
{
   // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î‡∏à‡∏£‡∏¥‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à
   CheckMarketConditionsRealTime();
   
   // ‚úÖ ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏•‡∏≤‡∏î‡∏à‡∏£‡∏¥‡∏á‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡πÅ‡∏Ñ‡πà‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
   string marketStatus = GetDetailedMarketStatus();
   Print("üìä MARKET STATUS: " + marketStatus);
   
   // ‚úÖ ‡∏ï‡∏≤‡∏°‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î‡∏à‡∏£‡∏¥‡∏á + ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ã‡πâ‡∏≥‡∏Å‡πà‡∏≠‡∏ô‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£
   if(IsMarketRanging() && ConfirmMarketCondition("RANGING", 3)) {
      Print("üìä MARKET CONFIRMED RANGING - Scalp Teams Lead");
      if(ShouldTradeInThisRegime("RANGING")) {
         ExecuteTradingTeamsInRange();
      }
   }
   else if(IsMarketTrending() && ConfirmMarketCondition("TRENDING", 3)) {
      Print("üìà MARKET CONFIRMED TRENDING - Trend Teams Lead");
      if(ShouldTradeInThisRegime("TRENDING")) {
         ExecuteTradingTeamsInTrend();
      }
   }
   else if(IsMarketBreakingOut() && ConfirmMarketCondition("BREAKOUT", 2)) {
      Print("üöÄ MARKET CONFIRMED BREAKOUT - Breakout Teams Lead");
      if(ShouldTradeInThisRegime("BREAKOUT")) {
         ExecuteTradingTeamsInBreakout();
      }
   }
   else {
      Print("üîÑ MARKET UNCLEAR - Conservative Approach");
      ExecuteConservativeTradingApproach();
   }
}
bool ShouldTradeInThisRegime(string regime)
{
   // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏ó‡∏£‡∏î
   double riskPressure = CalculateRiskPressure();
   int totalPositions = PositionsTotal();
   
   if(riskPressure > 0.8) {
      Print("‚ö†Ô∏è Risk pressure too high for " + regime + " trading");
      return false;
   }
   
   if(totalPositions >= MaxTotalPositions * 0.8) {
      Print("‚ö†Ô∏è Position limit nearly reached for " + regime + " trading");
      return false;
   }
   
   if(!IsMarketGoodForTrading(_Symbol)) {
      Print("‚ö†Ô∏è Market conditions not suitable for " + regime + " trading");
      return false;
   }
   
   return true;
}
// üìç ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î (‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô false signal)
bool ConfirmMarketCondition(string condition, int confirmationCount)
{
   int confirmations = 0;
   for(int i = 0; i < confirmationCount; i++) {
      if(condition == "RANGING" && IsMarketRanging()) confirmations++;
      else if(condition == "TRENDING" && IsMarketTrending()) confirmations++;
      else if(condition == "BREAKOUT" && IsMarketBreakingOut()) confirmations++;
      
      if(i < confirmationCount - 1) Sleep(1000); // ‡∏£‡∏≠ 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
   }
   
   return (confirmations >= confirmationCount);
}

//---Conservative Trading
void ExecuteConservativeTradingApproach()
{
   Print("üéØ CONSERVATIVE MODE: Waiting for clear signals");
   
   // ‚úÖ ‡πÄ‡∏ó‡∏£‡∏î‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
   bool hasClearSignal = HasClearTradingSignal();
   double marketScore = GetMarketScore();
   
   if(hasClearSignal && marketScore > 70) {
      Print("‚úÖ Clear signal detected - proceeding with caution");
      Print("   Market Score: " + DoubleToString(marketScore, 1) + "/100");
      
      // ‡πÉ‡∏ä‡πâ‡∏•‡∏≠‡∏ï‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏•‡πá‡∏Å
      double conservativeLot = CalculateSafeScalpLot() * 0.5;
      conservativeLot = MathMax(conservativeLot, BaseLot); // ‡∏≠‡∏¢‡πà‡∏≤‡πÉ‡∏´‡πâ‡πÄ‡∏•‡πá‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
      
      Print("   Conservative Lot Size: " + DoubleToString(conservativeLot, 2));
      
      // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡πÅ‡∏ö‡∏ö‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á
      if(Scalp1Enabled && HasClearScalpSignal()) {
         Print("   Executing Scalp1 with conservative lot");
         ExecuteScalp1WithCustomLot(conservativeLot);
      }
      else if(SimpleTrendScalpEnabled && HasClearTrendSignal()) {
         Print("   Executing Trend Scalp with conservative lot");
         ExecuteSimpleTrendScalpWithCustomLot(conservativeLot);
      }
      else if(BreakoutStrategy && HasClearBreakoutSignal()) {
         Print("   Executing Breakout with conservative lot");
         ExecuteAdvancedBreakoutWithCustomLot(conservativeLot);
      }
   } else {
      if(!hasClearSignal) {
         Print("‚è∏Ô∏è No clear signals detected");
      } else {
         Print("‚è∏Ô∏è Market score too low: " + DoubleToString(marketScore, 1) + "/100");
      }
      Print("   Waiting for better trading conditions...");
   }
}



//--Conservative Trading
//----------Support/Resistance:----------------//

bool HasClearSupportResistance() {
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_H1, 0, 50, rates) < 50) return false;
    
    // ‡∏´‡∏≤‡πÅ‡∏ô‡∏ß‡∏£‡∏±‡∏ö-‡πÅ‡∏ô‡∏ß‡∏ï‡πâ‡∏≤‡∏ô‡∏à‡∏≤‡∏Å High/Low ‡∏ó‡∏µ‡πà‡πÄ‡∏î‡πà‡∏ô‡∏ä‡∏±‡∏î
    int supportLevels = CountSupportLevels(rates, 50);
    int resistanceLevels = CountResistanceLevels(rates, 50);
    
    return (supportLevels >= 2 && resistanceLevels >= 2); // ‡∏°‡∏µ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 2 ‡πÅ‡∏ô‡∏ß‡∏£‡∏±‡∏ö‡πÅ‡∏•‡∏∞‡πÅ‡∏ô‡∏ß‡∏ï‡πâ‡∏≤‡∏ô
}

int CountSupportLevels(MqlRates &rates[], int count) {
    int supportCount = 0;
    
    // ‡∏´‡∏≤ Low ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏£‡∏±‡πâ‡∏á (Support)
    for(int i = 2; i < count - 2; i++) {
        if(IsSupportLevel(rates, i, count)) {
            supportCount++;
        }
    }
    
    return supportCount;
}

int CountResistanceLevels(MqlRates &rates[], int count) {
    int resistanceCount = 0;
    
    // ‡∏´‡∏≤ High ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏£‡∏±‡πâ‡∏á (Resistance)
    for(int i = 2; i < count - 2; i++) {
        if(IsResistanceLevel(rates, i, count)) {
            resistanceCount++;
        }
    }
    
    return resistanceCount;
}

bool IsSupportLevel(MqlRates &rates[], int index, int totalBars) {
    double currentLow = rates[index].low;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏ô‡∏µ‡πâ‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    int touchCount = 0;
    double tolerance = currentLow * 0.0005; // 0.05% tolerance
    
    for(int i = 0; i < totalBars; i++) {
        if(MathAbs(rates[i].low - currentLow) <= tolerance) {
            touchCount++;
        }
        
        // ‡∏ñ‡πâ‡∏≤‡∏£‡∏≤‡∏Ñ‡∏≤‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏ô‡∏µ‡πâ‡∏°‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‚Üí ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà Support
        if(rates[i].low < currentLow - tolerance * 3) {
            return false;
        }
    }
    
    return (touchCount >= 3); // ‡∏ñ‡∏π‡∏Å‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 3 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á
}

bool IsResistanceLevel(MqlRates &rates[], int index, int totalBars) {
    double currentHigh = rates[index].high;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏ô‡∏µ‡πâ‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    int touchCount = 0;
    double tolerance = currentHigh * 0.0005; // 0.05% tolerance
    
    for(int i = 0; i < totalBars; i++) {
        if(MathAbs(rates[i].high - currentHigh) <= tolerance) {
            touchCount++;
        }
        
        // ‡∏ñ‡πâ‡∏≤‡∏£‡∏≤‡∏Ñ‡∏≤‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏ô‡∏µ‡πâ‡∏°‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‚Üí ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà Resistance
        if(rates[i].high > currentHigh + tolerance * 3) {
            return false;
        }
    }
    
    return (touchCount >= 3); // ‡∏ñ‡∏π‡∏Å‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 3 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á
}
bool IsRangeContraction() {
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_H1, 0, 20, rates) < 20) return false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏´‡∏î‡∏ï‡∏±‡∏ß‡∏Ç‡∏≠‡∏á Range
    double recentRange = rates[0].high - rates[0].low;
    double previousRange = 0;
    
    for(int i = 1; i < 10; i++) {
        previousRange += (rates[i].high - rates[i].low);
    }
    previousRange /= 9.0;
    
    return (recentRange < previousRange * 0.7); // Range ‡∏´‡∏î‡∏ï‡∏±‡∏ß‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 30%
}

bool IsRangeExpansion() {
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_H1, 0, 20, rates) < 20) return false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏Ç‡∏¢‡∏≤‡∏¢‡∏ï‡∏±‡∏ß‡∏Ç‡∏≠‡∏á Range
    double recentRange = rates[0].high - rates[0].low;
    double previousRange = 0;
    
    for(int i = 1; i < 10; i++) {
        previousRange += (rates[i].high - rates[i].low);
    }
    previousRange /= 9.0;
    
    return (recentRange > previousRange * 1.3); // Range ‡∏Ç‡∏¢‡∏≤‡∏¢‡∏ï‡∏±‡∏ß‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 30%
}

bool IsRangeAboutToBreak() {
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_H1, 0, 30, rates) < 30) return false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏£‡∏≤‡∏Ñ‡∏≤‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà‡∏Ç‡∏≠‡∏ö Range ‡πÅ‡∏•‡∏∞‡∏°‡∏µ Volume ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô
    double highest = rates[0].high;
    double lowest = rates[0].low;
    for(int i = 1; i < 30; i++) {
        if(rates[i].high > highest) highest = rates[i].high;
        if(rates[i].low < lowest) lowest = rates[i].low;
    }
    
    double current = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double rangeHeight = highest - lowest;
    
    bool nearBoundary = (MathAbs(current - highest) < rangeHeight * 0.1) || 
                       (MathAbs(current - lowest) < rangeHeight * 0.1);
    
    double currentVolume = GetVolume(_Symbol, PERIOD_H1, 0);
    double avgVolume = 0;
    for(int i = 1; i < 5; i++) {
        avgVolume += GetVolume(_Symbol, PERIOD_H1, i);
    }
    avgVolume /= 4.0;
    
    bool volumeSpike = (currentVolume > avgVolume * 1.5);
    
    return (nearBoundary && volumeSpike);
}

bool HasBreakoutPotential() {
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_H1, 0, 10, rates) < 10) return false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Range ‡πÅ‡∏Ñ‡∏ö‡∏•‡∏á (Coiling) ‚Üí ‡∏°‡∏µ‡πÇ‡∏≠‡∏Å‡∏≤‡∏™ Breakout ‡∏™‡∏π‡∏á
    double recentRanges[5];
    for(int i = 0; i < 5; i++) {
        recentRanges[i] = rates[i].high - rates[i].low;
    }
    
    // ‡πÄ‡∏£‡∏µ‡∏¢‡∏á Range ‡∏à‡∏≤‡∏Å‡πÄ‡∏Å‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÑ‡∏õ‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
    bool isCoiling = true;
    for(int i = 1; i < 5; i++) {
        if(recentRanges[i] > recentRanges[i-1] * 1.1) {
            isCoiling = false;
            break;
        }
    }
    
    return isCoiling;
}
//---//
void ExecuteTradingTeamsInRange() {
    // üìä ‡∏ï‡∏•‡∏≤‡∏î‡πÑ‡∏ã‡∏î‡πå‡πÄ‡∏ß‡∏¢‡πå ‚Üí ‡∏ó‡∏µ‡∏° Scalp ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏µ‡πà
    Print("üìä MARKET RANGING - Scalp Teams Taking Lead");
    
    // üéØ QUICK_STRIKE_TEAM (Scalp1) - ‡∏à‡∏π‡πà‡πÇ‡∏à‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡πÑ‡∏ã‡∏î‡πå‡πÄ‡∏ß‡∏¢‡πå
    if(Scalp1Enabled && ShouldOpenPosition("Scalp1")) {
        if(IsLowVolatility() && IsInRangeZone()) {
            ExecuteScalp1();  // ‚úÖ ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏µ‡πà
            Print("‚ö° QUICK_STRIKE: Scalp1 executed in ranging market");
        }
    }
    
    // üéØ INCOME_SUPPORT_TEAM (Scalp2) - ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡πÑ‡∏î‡πâ‡∏™‡∏°‡πà‡∏≥‡πÄ‡∏™‡∏°‡∏≠
    if(Scalp2Enabled && ShouldOpenPosition("Scalp2")) {
        if(IsStableRange() && HasClearSupportResistance()) {
            ExecuteScalp2();  // ‚úÖ ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏µ‡πà
            Print("üí∞ INCOME_SUPPORT: Scalp2 adding consistent income");
        }
    }
    
    // üéØ SPECIAL_OPS_TEAM (Scalp3) - ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏™‡∏ñ‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏û‡∏¥‡πÄ‡∏®‡∏©
    if(Scalp3_Enabled && ShouldOpenPosition("Scalp3")) {
        if(IsRangeContraction() || IsRangeExpansion()) {
            ExecuteScalp3Integrated();  // ‚úÖ ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏µ‡πà
            Print("üéØ SPECIAL_OPS: Scalp3 handling special range conditions");
        }
    }
    
    // üéØ TREND_CONTROL_TEAM (Trend) - ‡∏£‡∏≠‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏ä‡∏±‡∏î
    if(SimpleTrendScalpEnabled && ShouldOpenPosition("Trend")) {
        if(IsRangeAboutToBreak() && HasTrendSignal()) {
            ExecuteSimpleTrendScalp();  // ‚úÖ ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏ï‡πà‡∏£‡∏≠‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏ä‡∏±‡∏î
            Print("üìà TREND_CONTROL: Trend team waiting for clear trend");
        }
    }
    
    // üéØ BREAKOUT_SQUAD_TEAM (Breakout) - ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏à‡∏±‡∏ö Breakout
    if(BreakoutStrategy && ShouldOpenPosition("Breakout")) {
        if(IsAtRangeBoundary() && HasBreakoutPotential()) {
            // ‚úÖ ‡∏≠‡∏≤‡∏à‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏ö Breakout ‡πÄ‡∏ö‡∏∑‡πâ‡∏≠‡∏á‡∏ï‡πâ‡∏ô
            ExecuteAdvancedBreakout();
            Print("üöÄ BREAKOUT_SQUAD: Monitoring range boundaries for breakout");
        }
    }
}

void ExecuteTradingTeamsInTrend() {
    // üìà ‡∏ï‡∏•‡∏≤‡∏î‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå ‚Üí ‡∏ó‡∏µ‡∏° Trend ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏µ‡πà
    Print("üìà MARKET TRENDING - Trend Teams Taking Lead");
    
    // üéØ TREND_CONTROL_TEAM (Trend) - ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏´‡∏•‡∏±‡∏Å
    if(SimpleTrendScalpEnabled && ShouldOpenPosition("Trend")) {
        ExecuteSimpleTrendScalp();  // ‚úÖ ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏µ‡πà
        Print("üìà TREND_CONTROL: Riding the strong trend");
    }
    
    // üéØ BREAKOUT_SQUAD_TEAM (Breakout) - ‡∏à‡∏±‡∏ö Breakout ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå
    if(BreakoutStrategy && ShouldOpenPosition("Breakout")) {
        if(IsTrendContinuationBreakout()) {
            ExecuteAdvancedBreakout();  // ‚úÖ ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏µ‡πà
            Print("üöÄ BREAKOUT_SQUAD: Capturing trend continuation breakouts");
        }
    }
    
    // üéØ QUICK_STRIKE_TEAM (Scalp1) - ‡∏à‡∏±‡∏ö Pullback
    if(Scalp1Enabled && ShouldOpenPosition("Scalp1")) {
        if(IsTrendPullback() && IsShallowRetracement()) {
            ExecuteScalp1();  // ‚úÖ ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô (‡∏à‡∏±‡∏ö Pullback)
            Print("‚ö° QUICK_STRIKE: Scalping trend pullbacks");
        }
    }
    
    // üéØ INCOME_SUPPORT_TEAM (Scalp2) - ‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå
    if(Scalp2Enabled && ShouldOpenPosition("Scalp2")) {
        if(IsTrendConsolidation()) {
            ExecuteScalp2();  // ‚úÖ ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô (‡∏à‡∏±‡∏ö Consolidation)
            Print("üí∞ INCOME_SUPPORT: Trading trend consolidations");
        }
    }
    
    // üéØ SPECIAL_OPS_TEAM (Scalp3) - ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏û‡∏¥‡πÄ‡∏®‡∏©
    if(Scalp3_Enabled && ShouldOpenPosition("Scalp3")) {
        if(IsTrendExhaustion() || IsTrendReversalSignal()) {
            ExecuteScalp3Integrated();  // ‚úÖ ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô (‡∏à‡∏±‡∏ö Reversal)
            Print("üéØ SPECIAL_OPS: Monitoring trend exhaustion signals");
        }
    }
}
//--//

bool HasTrendSignal()
{
    double ema9_buffer[], ema21_buffer[], ema50_buffer[];
    
    ArraySetAsSeries(ema9_buffer, true);
    ArraySetAsSeries(ema21_buffer, true);
    ArraySetAsSeries(ema50_buffer, true);
    
    // ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• EMA
    if(CopyBuffer(ema9_handle, 0, 0, 1, ema9_buffer) <= 0) return false;
    if(CopyBuffer(ema21_handle, 0, 0, 1, ema21_buffer) <= 0) return false;
    if(CopyBuffer(ema50_handle, 0, 0, 1, ema50_buffer) <= 0) return false;
    
    double ema9 = ema9_buffer[0];
    double ema21 = ema21_buffer[0];
    double ema50 = ema50_buffer[0];
    
    // ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏Ç‡∏∂‡πâ‡∏ô: EMA ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏±‡∏ß‡∏Å‡∏±‡∏ô
    bool uptrend = (ema9 > ema21 && ema21 > ema50);
    // ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏•‡∏á: EMA ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏±‡∏ß‡∏Å‡∏±‡∏ô
    bool downtrend = (ema9 < ema21 && ema21 < ema50);
    
    return (uptrend || downtrend);
}

bool IsTrendPullback() {
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_M15, 0, 10, rates) < 10) return false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏Å‡∏ï‡∏±‡∏ß‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå
    double ema21 = iMA(_Symbol, PERIOD_H1, 21, 0, MODE_EMA, PRICE_CLOSE);
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    // ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏Ç‡∏∂‡πâ‡∏ô: ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏û‡∏±‡∏Å‡∏ï‡∏±‡∏ß‡∏•‡∏á‡∏°‡∏≤‡∏´‡∏≤ EMA
    bool pullbackInUptrend = (currentPrice < ema21 && IsUptrend());
    // ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏•‡∏á: ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏û‡∏±‡∏Å‡∏ï‡∏±‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡∏´‡∏≤ EMA  
    bool pullbackInDowntrend = (currentPrice > ema21 && IsDowntrend());
    
    return (pullbackInUptrend || pullbackInDowntrend);
}

bool IsShallowRetracement() {
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_H1, 0, 20, rates) < 20) return false;
    
    // ‡∏´‡∏≤ Swing High ‡πÅ‡∏•‡∏∞ Swing Low ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
    double swingHigh = rates[0].high;
    double swingLow = rates[0].low;
    
    for(int i = 1; i < 20; i++) {
        if(rates[i].high > swingHigh) swingHigh = rates[i].high;
        if(rates[i].low < swingLow) swingLow = rates[i].low;
    }
    
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double totalMove = swingHigh - swingLow;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Retracement ‡πÑ‡∏°‡πà‡∏•‡∏∂‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô 38.2%
    if(IsUptrend()) {
        double retracement = (swingHigh - currentPrice) / totalMove * 100;
        return (retracement < 38.2);
    } else if(IsDowntrend()) {
        double retracement = (currentPrice - swingLow) / totalMove * 100;
        return (retracement < 38.2);
    }
    
    return false;
}

bool IsTrendConsolidation() {
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_M15, 0, 10, rates) < 10) return false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£ Consolidation ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå
    double totalRange = 0;
    for(int i = 0; i < 10; i++) {
        totalRange += (rates[i].high - rates[i].low);
    }
    double avgRange = totalRange / 10.0;
    
    double atr = GetATRValue(_Symbol, PERIOD_M15, 14);
    double rangePercent = (avgRange / rates[0].close) * 100;
    
    // Range ‡πÅ‡∏Ñ‡∏ö + ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå = Consolidation
    return (rangePercent < 0.03 && (IsUptrend() || IsDowntrend()));
}

bool IsTrendExhaustion() {
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_H1, 0, 5, rates) < 5) return false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Divergence ‡∏î‡πâ‡∏ß‡∏¢ RSI
    double rsi = iRSI(_Symbol, PERIOD_H1, 14, PRICE_CLOSE, 0);
    double rsi1 = iRSI(_Symbol, PERIOD_H1, 14, PRICE_CLOSE, 1);
    
    // Bearish Divergence: ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏™‡∏π‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡πÅ‡∏ï‡πà RSI ‡∏ï‡πà‡∏≥‡∏•‡∏á
    bool bearishDivergence = (rates[0].high > rates[1].high && rsi < rsi1);
    // Bullish Divergence: ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ï‡πà‡∏≥‡∏•‡∏á‡πÅ‡∏ï‡πà RSI ‡∏™‡∏π‡∏á‡∏Ç‡∏∂‡πâ‡∏ô
    bool bullishDivergence = (rates[0].low < rates[1].low && rsi > rsi1);
    
    return (bearishDivergence || bullishDivergence);
}

bool IsTrendReversalSignal() {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏à‡∏≤‡∏Å Multiple Timeframes
    bool h4Reversal = CheckReversalOnTimeframe(PERIOD_H4);
    bool h1Reversal = CheckReversalOnTimeframe(PERIOD_H1);
    bool m15Momentum = CheckMomentumReversal(PERIOD_M15);
    
    return (h4Reversal && h1Reversal && m15Momentum);
}

// üîß ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠
bool IsUptrend() {
 
   double emaFastBuffer[], emaSlowBuffer[];
   ArraySetAsSeries(emaFastBuffer, true);
   ArraySetAsSeries(emaSlowBuffer, true);
   
   int emaFastHandle = iMA(_Symbol, _Period, 50, 0, MODE_EMA, PRICE_CLOSE);
   int emaSlowHandle = iMA(_Symbol, _Period, 200, 0, MODE_EMA, PRICE_CLOSE);
   
   CopyBuffer(emaFastHandle, 0, 0, 3, emaFastBuffer);
   CopyBuffer(emaSlowHandle, 0, 0, 3, emaSlowBuffer);
   
   return emaFastBuffer[0] > emaSlowBuffer[0];
}

bool IsDowntrend() {
   double emaFastBuffer[], emaSlowBuffer[];
   ArraySetAsSeries(emaFastBuffer, true);
   ArraySetAsSeries(emaSlowBuffer, true);
   
   int emaFastHandle = iMA(_Symbol, _Period, 50, 0, MODE_EMA, PRICE_CLOSE);
   int emaSlowHandle = iMA(_Symbol, _Period, 200, 0, MODE_EMA, PRICE_CLOSE);
   
   CopyBuffer(emaFastHandle, 0, 0, 3, emaFastBuffer);
   CopyBuffer(emaSlowHandle, 0, 0, 3, emaSlowBuffer);
   
   return emaFastBuffer[0] < emaSlowBuffer[0];
}

bool CheckReversalOnTimeframe(ENUM_TIMEFRAMES tf) {
   
    
    // ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å handle ‡∏ï‡∏≤‡∏° timeframe
    switch(tf) {
        case PERIOD_H1:
            ema9_handle = ema9_handle_h1;
            ema21_handle = ema21_handle_h1;
            break;
        case PERIOD_M15:
            ema9_handle = ema9_handle_m15;
            ema21_handle = ema21_handle_m15;
            break;
        case PERIOD_M5:
            ema9_handle = ema9_handle_m5;
            ema21_handle = ema21_handle_m5;
            break;
        default:
            // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö timeframe ‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏™‡∏£‡πâ‡∏≤‡∏á handle ‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß
            ema9_handle = iMA(_Symbol, tf, 9, 0, MODE_EMA, PRICE_CLOSE);
            ema21_handle = iMA(_Symbol, tf, 21, 0, MODE_EMA, PRICE_CLOSE);
    }
    
    double ema9_buffer[], ema21_buffer[];
    ArraySetAsSeries(ema9_buffer, true);
    ArraySetAsSeries(ema21_buffer, true);
    
    // ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    if(CopyBuffer(ema9_handle, 0, 0, 2, ema9_buffer) <= 1) return false;
    if(CopyBuffer(ema21_handle, 0, 0, 2, ema21_buffer) <= 1) return false;
    
    double ema9 = ema9_buffer[0];
    double ema21 = ema21_buffer[0];
    double ema9_1 = ema9_buffer[1];
    double ema21_1 = ema21_buffer[1];
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏Å‡∏±‡∏ô
    bool bullishCross = (ema9_1 <= ema21_1 && ema9 > ema21);
    bool bearishCross = (ema9_1 >= ema21_1 && ema9 < ema21);
    
    // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô timeframe ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà predefined ‡πÉ‡∏´‡πâ release handles
    if(tf != PERIOD_H1 && tf != PERIOD_M15 && tf != PERIOD_M5) {
        IndicatorRelease(ema9_handle);
        IndicatorRelease(ema21_handle);
    }
    
    return (bullishCross || bearishCross);
}

bool CheckMomentumReversal(ENUM_TIMEFRAMES tf) {
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á handles ‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö timeframe ‡∏ô‡∏µ‡πâ
    int rsi_handle = iRSI(_Symbol, tf, 14, PRICE_CLOSE);
    int stoch_handle = iStochastic(_Symbol, tf, 5, 3, 3, MODE_SMA, STO_LOWHIGH);
    
    double rsi_buffer[], stoch_buffer[];
    ArraySetAsSeries(rsi_buffer, true);
    ArraySetAsSeries(stoch_buffer, true);
    
    // ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    if(CopyBuffer(rsi_handle, 0, 0, 1, rsi_buffer) <= 0) {
        IndicatorRelease(rsi_handle);
        IndicatorRelease(stoch_handle);
        return false;
    }
    if(CopyBuffer(stoch_handle, 0, 0, 1, stoch_buffer) <= 0) {
        IndicatorRelease(rsi_handle);
        IndicatorRelease(stoch_handle);
        return false;
    }
    
    double rsi = rsi_buffer[0];
    double stochastic = stoch_buffer[0];
    
    // Overbought/oversold with momentum shift
    bool bullishReversal = (rsi < 30 && stochastic < 20);
    bool bearishReversal = (rsi > 70 && stochastic > 80);
    
    IndicatorRelease(rsi_handle);
    IndicatorRelease(stoch_handle);
    
    return (bullishReversal || bearishReversal);
}

// üîß ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô GetATRValue (‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ)
double GetATRValue(string symbol, ENUM_TIMEFRAMES tf, int period, int shift = 0)
{
    int handle = iATR(symbol, tf, period);
    if(handle == INVALID_HANDLE) 
    {
        Print("Failed to create ATR handle for ", symbol);
        return 0;
    }
    
    double buffer[1];
    if(CopyBuffer(handle, 0, shift, 1, buffer) <= 0)
    {
        IndicatorRelease(handle);
        return 0;
    }
    
    IndicatorRelease(handle);
    return buffer[0];
}

// ‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡∏á‡πà‡∏≤‡∏¢ (‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏ï‡πâ‡∏ô)
double GetATRValueSimple(int period = 14, int shift = 0)
{
    return GetATRValue(_Symbol, PERIOD_H1, period, shift);
}
//--//
bool IsNewTrendConfirmed() {
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_H1, 0, 5, rates) < 5) return false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Breakout ‡∏ô‡∏≥‡πÑ‡∏õ‡∏™‡∏π‡πà‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÉ‡∏´‡∏°‡πà
    bool bullishConfirm = (rates[0].close > rates[1].close && 
                          rates[1].close > rates[2].close &&
                          rates[0].high > rates[1].high);
    
    bool bearishConfirm = (rates[0].close < rates[1].close && 
                          rates[1].close < rates[2].close &&
                          rates[0].low < rates[1].low);
    
    return (bullishConfirm || bearishConfirm);
}

bool IsBreakoutMomentum() {
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_M5, 0, 3, rates) < 3) return false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÇ‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡∏±‡∏°‡∏´‡∏•‡∏±‡∏á Breakout
    double volume1 = GetVolume(_Symbol, PERIOD_M5, 0);
    double volume2 = GetVolume(_Symbol, PERIOD_M5, 1);
    
    bool strongMomentum = (volume1 > volume2 * 1.3) && // Volume ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô
                         (MathAbs(rates[0].close - rates[1].close) > 
                          MathAbs(rates[1].close - rates[2].close) * 1.5); // Price movement ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô
    
    return strongMomentum;
}

bool IsLowRiskEntry() {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏∏‡∏î‡πÄ‡∏Ç‡πâ‡∏≤‡πÄ‡∏ó‡∏£‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡∏ï‡πà‡∏≥
    double spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) * _Point;
    
    // ‡πÉ‡∏ä‡πâ built-in iATR
    double atrArray[];
    ArraySetAsSeries(atrArray, true);
    int atrHandle = iATR(_Symbol, PERIOD_M15, 14);
    if(atrHandle == INVALID_HANDLE) return false;
    
    if(CopyBuffer(atrHandle, 0, 0, 1, atrArray) < 1) {
        IndicatorRelease(atrHandle);
        return false;
    }
    
    double atr = atrArray[0];
    IndicatorRelease(atrHandle);
    
    return (spread < atr * 0.1); // Spread ‡∏ï‡πà‡∏≥ compared to ATR
}
bool IsBreakoutRetest() {
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_M15, 0, 5, rates) < 5) return false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£ Retest ‡∏´‡∏•‡∏±‡∏á Breakout
    bool resistanceBreakRetest = (rates[4].high < rates[3].high &&  // ‡∏Å‡πà‡∏≠‡∏ô Breakout
                                 rates[3].high < rates[2].high &&  // Breakout
                                 rates[1].low > rates[2].low &&    // Pullback
                                 rates[0].close > rates[1].close); // Confirmation
    
    bool supportBreakRetest = (rates[4].low > rates[3].low &&
                              rates[3].low > rates[2].low &&
                              rates[1].high < rates[2].high &&
                              rates[0].close < rates[1].close);
    
    return (resistanceBreakRetest || supportBreakRetest);
}

bool IsFalseBreakout() {
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_M15, 0, 5, rates) < 5) return false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö False Breakout (Breakout ‡πÅ‡∏•‡πâ‡∏ß‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡πÉ‡∏ô Range)
    bool falseBreakoutUp = (rates[2].close > rates[3].high &&  // Breakout ‡∏Ç‡∏∂‡πâ‡∏ô
                           rates[1].close < rates[3].high &&   // ‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏Ç‡πâ‡∏≤ Range
                           rates[0].close < rates[3].high);
    
    bool falseBreakoutDown = (rates[2].close < rates[3].low &&
                             rates[1].close > rates[3].low &&
                             rates[0].close > rates[3].low);
    
    return (falseBreakoutUp || falseBreakoutDown);
}

bool IsBreakoutFailure() {
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_H1, 0, 4, rates) < 4) return false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Breakout ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß (‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÇ‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡∏±‡∏°‡∏ï‡∏≤‡∏°)
    bool failureUp = (rates[3].close > rates[2].high &&  // Breakout
                     rates[2].close < rates[3].close &&  // ‡πÑ‡∏°‡πà‡∏°‡∏µ follow-through
                     rates[1].close < rates[2].close &&
                     rates[0].close < rates[1].close);
    
    bool failureDown = (rates[3].close < rates[2].low &&
                       rates[2].close > rates[3].close &&
                       rates[1].close > rates[2].close &&
                       rates[0].close > rates[1].close);
    
    return (failureUp || failureDown);
}

bool IsTrendContinuationBreakout() {
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_H1, 0, 10, rates) < 10) return false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Breakout ‡∏ó‡∏µ‡πà‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏Å‡∏±‡∏ö‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÄ‡∏î‡∏¥‡∏°
    int uptrendCount = 0, downtrendCount = 0;
    for(int i = 1; i < 8; i++) {
        if(rates[i].close > rates[i-1].close) uptrendCount++;
        else if(rates[i].close < rates[i-1].close) downtrendCount++;
    }
    
    bool continuationUp = (uptrendCount >= 5 && rates[0].close > rates[1].high);
    bool continuationDown = (downtrendCount >= 5 && rates[0].close < rates[1].low);
    
    return (continuationUp || continuationDown);
}
// üîß ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Breakout Signal
bool IsCleanBreakoutSignal() {
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_H1, 0, 3, rates) < 3) return false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô Breakout ‡∏ó‡∏µ‡πà clean
    double volume0 = GetVolume(_Symbol, PERIOD_H1, 0);
    double volume1 = GetVolume(_Symbol, PERIOD_H1, 1);
    
    bool cleanBreakoutUp = (rates[0].close > rates[1].high && 
                           rates[0].close > rates[2].high &&
                           volume0 > volume1 * 1.2);
    
    bool cleanBreakoutDown = (rates[0].close < rates[1].low && 
                             rates[0].close < rates[2].low &&
                             volume0 > volume1 * 1.2);
    
    return (cleanBreakoutUp || cleanBreakoutDown);
}

double GetVolume(string symbol, ENUM_TIMEFRAMES timeframe, int shift) {
    return (double)iVolume(symbol, timeframe, shift);
}

//--//
void ExecuteTradingTeamsInBreakout() {
    // üöÄ ‡∏ï‡∏•‡∏≤‡∏î‡πÄ‡∏ö‡∏£‡∏Å‡πÄ‡∏≠‡πâ‡∏≤‡∏ó‡πå ‚Üí ‡∏ó‡∏µ‡∏° Breakout ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏µ‡πà
    Print("üöÄ MARKET BREAKOUT - Breakout Teams Taking Lead");
    
    // üéØ BREAKOUT_SQUAD_TEAM (Breakout) - ‡∏à‡∏±‡∏ö Breakout ‡∏´‡∏•‡∏±‡∏Å
    if(BreakoutStrategy && ShouldOpenPosition("Breakout")) {
        if(IsCleanBreakoutSignal()) {
            ExecuteAdvancedBreakout();  // ‚úÖ ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏µ‡πà
            Print("üöÄ BREAKOUT_SQUAD: Executing breakout strategy");
        }
    }
    
    // üéØ TREND_CONTROL_TEAM (Trend) - ‡∏ï‡∏≤‡∏°‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÉ‡∏´‡∏°‡πà
    if(SimpleTrendScalpEnabled && ShouldOpenPosition("Trend")) {
        if(IsNewTrendConfirmed()) {
            ExecuteSimpleTrendScalp();  // ‚úÖ ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏µ‡πà
            Print("üìà TREND_CONTROL: Following new trend after breakout");
        }
    }
    
    // üéØ QUICK_STRIKE_TEAM (Scalp1) - ‡∏à‡∏±‡∏ö‡πÇ‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡∏±‡∏°‡∏´‡∏•‡∏±‡∏á Breakout
    if(Scalp1Enabled && ShouldOpenPosition("Scalp1")) {
        if(IsBreakoutMomentum() && IsLowRiskEntry()) {
            ExecuteScalp1();  // ‚úÖ ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô (‡∏à‡∏±‡∏ö‡πÇ‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡∏±‡∏°)
            Print("‚ö° QUICK_STRIKE: Scalping breakout momentum");
        }
    }
    
    // üéØ INCOME_SUPPORT_TEAM (Scalp2) - ‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô‡∏´‡∏•‡∏±‡∏á Breakout
    if(Scalp2Enabled && ShouldOpenPosition("Scalp2")) {
        if(IsBreakoutRetest()) {
            ExecuteScalp2();  // ‚úÖ ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô (‡∏à‡∏±‡∏ö Retest)
            Print("üí∞ INCOME_SUPPORT: Trading breakout retests");
        }
    }
    
    // üéØ SPECIAL_OPS_TEAM (Scalp3) - ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ False Breakout
    if(Scalp3_Enabled && ShouldOpenPosition("Scalp3")) {
        if(IsFalseBreakout() || IsBreakoutFailure()) {
            ExecuteScalp3Integrated();  // ‚úÖ ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô (‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ False Breakout)
            Print("üéØ SPECIAL_OPS: Handling false breakout scenarios");
        }
    }
}

void ExecuteAllTradingTeams() {
    // üîÑ ‡∏ï‡∏•‡∏≤‡∏î‡πÑ‡∏°‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô ‚Üí ‡∏ó‡∏∏‡∏Å‡∏ó‡∏µ‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡∏≤‡∏°‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏õ‡∏Å‡∏ï‡∏¥
    Print("üîÑ MARKET UNCLEAR - All Teams Working Based on Signals");
    
    // ‚úÖ ‡∏ó‡∏∏‡∏Å‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡∏≤‡∏°‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á
    if(Scalp1Enabled && ShouldOpenPosition("Scalp1")) {
        ExecuteScalp1();
    }
    
    if(Scalp2Enabled && ShouldOpenPosition("Scalp2")) {
        ExecuteScalp2();
    }
    
    if(Scalp3_Enabled && ShouldOpenPosition("Scalp3")) {
        ExecuteScalp3Integrated();
    }
    
    if(SimpleTrendScalpEnabled && ShouldOpenPosition("Trend")) {
        ExecuteSimpleTrendScalp();
    }
    
    if(BreakoutStrategy && ShouldOpenPosition("Breakout")) {
        ExecuteAdvancedBreakout();
    }
}
bool IsLowVolatility() {
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_M15, 0, 10, rates) < 10) return false;
    
    double totalRange = 0;
    for(int i = 0; i < 10; i++) {
        totalRange += (rates[i].high - rates[i].low);
    }
    double avgRange = totalRange / 10.0;
    double rangePercent = (avgRange / rates[0].close) * 100;
    
    return (rangePercent < 0.05); // Volatility ‡∏ï‡πà‡∏≥
}

bool IsInRangeZone() {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÇ‡∏ã‡∏ô‡∏Å‡∏•‡∏≤‡∏á‡∏Ç‡∏≠‡∏á Range
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_H1, 0, 20, rates) < 20) return false;
    
    double highest = rates[0].high;
    double lowest = rates[0].low;
    for(int i = 1; i < 20; i++) {
        if(rates[i].high > highest) highest = rates[i].high;
        if(rates[i].low < lowest) lowest = rates[i].low;
    }
    
    double current = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double rangeMiddle = (highest + lowest) / 2.0;
    double deviation = MathAbs(current - rangeMiddle) / (highest - lowest) * 100;
    
    return (deviation < 30); // ‡∏≠‡∏¢‡∏π‡πà‡∏†‡∏≤‡∏¢‡πÉ‡∏ô 30% ‡∏à‡∏≤‡∏Å‡∏Å‡∏•‡∏≤‡∏á Range
}

bool IsStableRange() {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Range ‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_H1, 0, 10, rates) < 10) return false;
    
    double ranges[10];
    for(int i = 0; i < 10; i++) {
        ranges[i] = rates[i].high - rates[i].low;
    }
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Standard Deviation ‡∏Ç‡∏≠‡∏á Ranges
    double mean = 0;
    for(int i = 0; i < 10; i++) mean += ranges[i];
    mean /= 10.0;
    
    double variance = 0;
    for(int i = 0; i < 10; i++) {
        variance += MathPow(ranges[i] - mean, 2);
    }
    variance /= 10.0;
    
    double stdDev = MathSqrt(variance);
    double cv = (stdDev / mean) * 100; // Coefficient of Variation
    
    return (cv < 30); // Range ‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£ (CV < 30%)
}

// ===== PRICE EXTREME FUNCTIONS =====

// Get the highest high price for specified periods
double GetHighestHigh(int periods = 20, int shift = 1)
{
    // Validate input
    if(periods <= 0) 
    {
        Print("Error: periods must be greater than 0");
        return 0;
    }
    
    // Find the bar with highest high
    int highestBar = iHighest(Symbol(), PERIOD_CURRENT, MODE_HIGH, periods, shift);
    
    if(highestBar < 0)
    {
        Print("Error: Failed to find highest high");
        return 0;
    }
    
    // Return the high price of that bar
    return iHigh(Symbol(), PERIOD_CURRENT, highestBar);
}

// Get the lowest low price for specified periods
double GetLowestLow(int periods = 20, int shift = 1)
{
    // Validate input
    if(periods <= 0) 
    {
        Print("Error: periods must be greater than 0");
        return 0;
    }
    
    // Find the bar with lowest low
    int lowestBar = iLowest(Symbol(), PERIOD_CURRENT, MODE_LOW, periods, shift);
    
    if(lowestBar < 0)
    {
        Print("Error: Failed to find lowest low");
        return 0;
    }
    
    // Return the low price of that bar
    return iLow(Symbol(), PERIOD_CURRENT, lowestBar);
}

// Get both highest high and lowest low at once
bool GetPriceExtremes(int periods, int shift, double &highestHigh, double &lowestLow)
{
    highestHigh = GetHighestHigh(periods, shift);
    lowestLow = GetLowestLow(periods, shift);
    
    return (highestHigh > 0 && lowestLow > 0);
}
bool IsAtRangeBoundary() {
    // ‡∏´‡∏≤ range ‡∏à‡∏≤‡∏Å‡∏ä‡πà‡∏ß‡∏á 20 ‡πÅ‡∏ó‡πà‡∏á
    double high20 = GetHighestHigh(20);
    double low20 = GetLowestLow(20);
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double rangeSize = high20 - low20;
    
    if(rangeSize == 0) return false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÉ‡∏Å‡∏•‡πâ‡∏Ç‡∏≠‡∏ö range ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    double distanceFromHigh = high20 - currentPrice;
    double distanceFromLow = currentPrice - low20;
    
    ENUM_ORDER_TYPE orderType = ORDER_TYPE_BUY;
    if(orderType == ORDER_TYPE_BUY)  //
    {
        // ‡∏ã‡∏∑‡πâ‡∏≠‡∏ó‡∏µ‡πà‡∏Ç‡∏≠‡∏ö‡∏•‡πà‡∏≤‡∏á‡∏Ç‡∏≠‡∏á range
        return (distanceFromLow < rangeSize * 0.1);
    }
    else if(orderType == ORDER_TYPE_SELL) 
    {
        // ‡∏Ç‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏Ç‡∏≠‡∏ö‡∏ö‡∏ô‡∏Ç‡∏≠‡∏á range
        return (distanceFromHigh < rangeSize * 0.1);
    }
    
    return false;

}
//--//
void ExecuteRecoveryTeams() {
    // üõ°Ô∏è ‡∏ó‡∏∏‡∏Å Recovery Teams ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡∏≤‡∏°‡∏£‡∏∞‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á
    if(EnableIndividualRecovery) {
        ManageIndividualRecoverySets();    // INDIVIDUAL_RECOVERY_TEAM
    }
    
    if(StepUpRecoveryEnabled) {
        ManageStepUpRecovery();            // STEPUP_RECOVERY_TEAM
    }
    
    if(EnableCounterPosition) {
         // Get current market regime
    ENUM_MARKET_REGIME currentRegime = DetectMarketRegime();
    
    // Manage counter positions with regime
    ManageCounterPositions(currentRegime);         // COUNTER_ATTACK_TEAM
    }
    
    if(UseEmergencyHedge) {
        CheckEmergencyHedge();             // HEDGE_DEFENSE_TEAM
    }
    
    if(EnableUniversalOrphan) {
        ManageOrphanUniversal();           // ORPHAN_RESCUE_TEAM
    }
    
    if(UltimateFightingMode) {
        ExecuteUltimateFightingRecovery(); // ULTIMATE_FIGHTING_TEAM
    }
}
//+------------------------------------------------------------------+
//| Execute Coordinated Strategies                                  |
//+------------------------------------------------------------------+
void ExecuteCoordinatedStrategies()
{
    if(!EnableCooperativeSystem) return;
    
    // üî• ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÇ‡∏´‡∏°‡∏î Recovery
    if(SystemMode == MODE_RECOVERY) {
        ExecuteFullTeamCooperation();  // ‚úÖ ‡πÉ‡∏´‡∏°‡πà: ‡πÉ‡∏ä‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏µ‡∏°‡πÄ‡∏ï‡πá‡∏°‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö
        return;
    }
    
    // üî• ‡πÇ‡∏´‡∏°‡∏î‡∏õ‡∏Å‡∏ï‡∏¥: ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡∏≤‡∏°‡πÄ‡∏î‡∏¥‡∏°
    int mostNeedyStrategy = FindMostNeedyStrategy();
    
    if(mostNeedyStrategy == -1) return;
    
    Print("üéØ COORDINATOR: Executing " + strategies[mostNeedyStrategy].name + " (Most needy)");
    
    // ‚úÖ ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    switch(mostNeedyStrategy) {
        case 0: // Scalp1 needs help
            if(Scalp1Enabled && CalculateRiskPressure() < 0.7 && ShouldOpenPosition("Scalp1")) {
                ExecuteScalp1();
                if(Scalp1AdvanceEnabled) {
                    ExecuteScalp1HighFrequency();
                }
            }
            break;
            
        case 1: // Scalp2 needs help  
            if(Scalp2Enabled && CalculateRecoveryRiskPressure() < 0.9 && ShouldOpenPosition("Scalp2")) 
                ExecuteScalp2();
            break;
            
        case 2: // Scalp3 needs help
            if(Scalp3_Enabled && CalculateRecoveryRiskPressure() < 0.8 && ShouldOpenPosition("Scalp3")) 
                ExecuteScalp3Integrated();
            break;
            
        case 3: // Trend needs help
            if(SimpleTrendScalpEnabled && CalculateRiskPressure() < 0.8 && ShouldOpenPosition("Trend")) 
                ExecuteSimpleTrendScalp();
            break;
            
        case 4: // Breakout needs help
            if(BreakoutStrategy && newBarBreakout && ShouldOpenPosition("Breakout")) 
                ExecuteAdvancedBreakout();
            break;
    }
    
    // ‚úÖ ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ Recovery Systems ‡πÅ‡∏¢‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏´‡∏≤‡∏Å
    ExecuteRecoverySystems();
    
    // ‚úÖ ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ AI Systems ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
    ExecuteAISystems();
    
    // ‚úÖ ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ Low Risk Opportunities
    ExecuteLowRiskOpportunities();
}

// ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà: ‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏µ‡∏°‡πÄ‡∏ï‡πá‡∏°‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö
void ExecuteFullTeamCooperation() {
    Print("ü§ù FULL TEAM COOPERATION ACTIVATED");
    
    // ‚úÖ ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏õ‡∏£‡∏∞‡∏ä‡∏∏‡∏°‡∏ó‡∏µ‡∏°‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å
    static bool firstBriefing = true;
    if(firstBriefing) {
        TeamBriefing();
        firstBriefing = false;
    }
    
    // ‚úÖ ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡∏≤‡∏°‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î
    ExecuteTeamByMarketCondition();
    
    // ‚úÖ ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏∑‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡∏°
    UpdateTeamProgress();
    
    // ‚úÖ ‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏î‡∏ä‡∏ö‡∏≠‡∏£‡πå‡∏î
    DisplayTeamDashboard();
    
    // ‚úÖ ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å Recovery Systems ‡∏ï‡∏≤‡∏°‡∏õ‡∏Å‡∏ï‡∏¥
    ExecuteRecoverySystems();
}

// ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà: ‡∏õ‡∏£‡∏∞‡∏ä‡∏∏‡∏°‡∏ó‡∏µ‡∏°
void TeamBriefing() {
    Print("=== üéØ MISSION BRIEFING ===");
    
    // üìä ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ô
    double dailyTarget = CalculateDailyMissionTarget();
    Print("üéØ DAILY MISSION: $" + DoubleToString(dailyTarget, 2));
    
    // üë• ‡πÅ‡∏à‡∏á‡∏ö‡∏ó‡∏ö‡∏≤‡∏ó‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ó‡∏µ‡∏° (‡πÅ‡∏¢‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó)
    Print("--- TRADING TEAMS ---");
    for(int i = 0; i < 5; i++) {
        string teamTask = GetTeamTask(strategyMissionTeam[i]);
        Print("üë§ " + strategies[i].name + " ‚Üí " + strategyMissionTeam[i] + ": " + teamTask);
    }
    
    Print("--- RECOVERY TEAMS ---");
    for(int i = 5; i < 11; i++) {
        string teamTask = GetTeamTask(strategyMissionTeam[i]);
        Print("üõ°Ô∏è " + strategyMissionTeam[i] + ": " + teamTask);
    }
    
    // ü§ù ‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ô
    Print("üìú COOPERATION RULES: All teams work together for portfolio recovery");
}

// üî• ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÉ‡∏ô‡πÇ‡∏´‡∏°‡∏î Recovery
void ExecuteEssentialSystemsInRecovery()
{

    Print("üîÑ RECOVERY MODE: Running essential systems only");
    
    // 1. ‡∏£‡∏∞‡∏ö‡∏ö Low Risk ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
    ExecuteLowRiskOpportunities();
    
    // 2. ‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå Reduced (‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡∏à‡∏≤‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÑ‡∏õ‡∏°‡∏≤‡∏Å)
    if(CalculateRiskPressure() < 0.3) {
        if(Scalp1Enabled) ExecuteScalp1Reduced();
    }
    
    if(CalculateRecoveryRiskPressure() < 0.2) {
        if(Scalp2Enabled) ExecuteScalp2Reduced();
    }
    
    if(CalculateRiskPressure() < 0.4) {
        if(SimpleTrendScalpEnabled) ExecuteTrendReduced();
    }
    
    if(CalculateRiskPressure() < 0.2 && newBarBreakout) {
        if(BreakoutStrategy) ExecuteBreakoutReduced();
    }
    
    // 3. ‡πÑ‡∏°‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á
    // ExecuteAISystems(), ExecuteScalp1HighFrequency(), etc.
}

//-------Reduce lot in Primary stategy--------//

void ExecuteScalp2WithCustomLot(double customLot)
{
    if(!Scalp2Enabled) return;
    
    DebugPrint(3, "Executing Scalp2 with custom lot: " + DoubleToString(customLot, 2));
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç Risk
    if(CalculateRecoveryRiskPressure() >= 0.9) {
        DebugPrint(2, "Scalp2: Recovery risk too high");
        return;
    }
    
    if(!ShouldOpenPosition("Scalp2")) {
        DebugPrint(3, "Scalp2: No valid signal found");
        return;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Margin
    if(!CheckMargin(customLot)) {
        DebugPrint(1, "Insufficient margin for Scalp2: " + DoubleToString(customLot, 2));
        return;
    }
    
    trade.SetExpertMagicNumber(MAGIC_SCALP2);
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì TP/SL
    double slPrice = GetSLPriceUniversal(true, Scalp2_SL_Points);
    double tpPrice = GetTPPriceUniversal(true, Scalp2_TP_Points);
    
    // ‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå (‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÅ‡∏ö‡∏ö Buy)
    if(trade.Buy(customLot, _Symbol, slPrice, tpPrice, 0, "Scalp2-CustomLot")) {
        ulong ticket = trade.ResultOrder();
        Print("‚úÖ SCALP2 CUSTOM LOT BUY | Lot: " + DoubleToString(customLot, 2) + 
              " | Ticket: #" + IntegerToString(ticket));
    } else {
        Print("‚ùå Scalp2 BUY Error: " + trade.ResultRetcodeDescription());
    }
}
void ExecuteScalp3WithReducedLot(double reducedLot)
{
    if(!Scalp3_Enabled) return;
    
    DebugPrint(3, "Executing Scalp3 with reduced lot: " + DoubleToString(reducedLot, 2));
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç Risk
    if(CalculateRecoveryRiskPressure() >= 0.8) {
        DebugPrint(2, "Scalp3: Recovery risk too high");
        return;
    }
    
    if(!ShouldOpenPosition("Scalp3")) {
        DebugPrint(3, "Scalp3: No valid signal found");
        return;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Margin
    if(!CheckMargin(reducedLot)) {
        DebugPrint(1, "Insufficient margin for Scalp3: " + DoubleToString(reducedLot, 2));
        return;
    }
    
    trade.SetExpertMagicNumber(MAGIC_SCALP3);
    
    double ema9 = iMA(_Symbol, PERIOD_M1, 9, 0, MODE_EMA, PRICE_CLOSE);
    double ema21 = iMA(_Symbol, PERIOD_M1, 21, 0, MODE_EMA, PRICE_CLOSE);
    double rsi = iRSI(_Symbol, PERIOD_M1, 14, PRICE_CLOSE, 0);
    
    bool buyCondition = (ema9 > ema21 && rsi > 40 && rsi < 75);
    bool sellCondition = (ema9 < ema21 && rsi < 60 && rsi > 25);
    
    // üî• ‡πÉ‡∏ä‡πâ Fixed SL/TP Points (‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ input)
    int fixedSLPoints = 30;  // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ fixed
    int fixedTPPoints = 20;  // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ fixed
    
    if(buyCondition) {
        double slPrice = GetSLPriceUniversal(true, fixedSLPoints);
        double tpPrice = GetTPPriceUniversal(true, fixedTPPoints);
        
        if(trade.Buy(reducedLot, _Symbol, slPrice, tpPrice, 0, "Scalp3-Reduced")) {
            ulong ticket = trade.ResultOrder();
            Print("‚úÖ SCALP3 REDUCED BUY | Lot: " + DoubleToString(reducedLot, 2) + 
                  " | SL: " + IntegerToString(fixedSLPoints) + "pips" +
                  " | TP: " + IntegerToString(fixedTPPoints) + "pips");
        }
    }
    else if(sellCondition) {
        double slPrice = GetSLPriceUniversal(false, fixedSLPoints);
        double tpPrice = GetTPPriceUniversal(false, fixedTPPoints);
        
        if(trade.Sell(reducedLot, _Symbol, slPrice, tpPrice, 0, "Scalp3-Reduced")) {
            ulong ticket = trade.ResultOrder();
            Print("‚úÖ SCALP3 REDUCED SELL | Lot: " + DoubleToString(reducedLot, 2) + 
                  " | SL: " + IntegerToString(fixedSLPoints) + "pips" +
                  " | TP: " + IntegerToString(fixedTPPoints) + "pips");
        }
    }
}
void ExecuteSimpleTrendScalpWithCustomLot(double customLot)
{
    if(!SimpleTrendScalpEnabled) return;
    
    DebugPrint(3, "Executing Trend Scalp with custom lot: " + DoubleToString(customLot, 2));
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç Risk
    if(CalculateRiskPressure() >= 0.8) {
        DebugPrint(2, "Trend Scalp: Risk too high");
        return;
    }
    
    if(!ShouldOpenPosition("Trend")) {
        DebugPrint(3, "Trend Scalp: No valid signal found");
        return;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Margin
    if(!CheckMargin(customLot)) {
        DebugPrint(1, "Insufficient margin for Trend Scalp: " + DoubleToString(customLot, 2));
        return;
    }
    
    trade.SetExpertMagicNumber(MAGIC_TREND_SCALP);
    
    // ‡πÉ‡∏ä‡πâ logic ‡∏à‡∏≤‡∏Å ExecuteSimpleTrendScalp() ‡πÅ‡∏ï‡πà‡πÉ‡∏ä‡πâ custom lot
    double ema9 = iMA(_Symbol, PERIOD_M1, 9, 0, MODE_EMA, PRICE_CLOSE);
    double ema21 = iMA(_Symbol, PERIOD_M1, 21, 0, MODE_EMA, PRICE_CLOSE);
    double rsi = iRSI(_Symbol, PERIOD_M1, 14, PRICE_CLOSE, 0);
    
    // ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÅ‡∏ö‡∏ö reduced (‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î‡∏Å‡∏ß‡πà‡∏≤)
    bool buyCondition = (ema9 > ema21 && rsi > 35 && rsi < 80);
    bool sellCondition = (ema9 < ema21 && rsi < 65 && rsi > 20);
    
    if(buyCondition) {
        // üî• ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ SL/TP Points - ‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÅ‡∏ö‡∏ö‡πÑ‡∏°‡πà‡∏°‡∏µ SL/TP
        if(trade.Buy(customLot, _Symbol, 0, 0, 0, "Trend-Reduced")) {
            ulong ticket = trade.ResultOrder();
            Print("‚úÖ TREND REDUCED BUY | Lot: " + DoubleToString(customLot, 2) + 
                  " | Ticket: #" + IntegerToString(ticket));
        } else {
            Print("‚ùå Trend Reduced BUY Error: " + trade.ResultRetcodeDescription());
        }
    }
    else if(sellCondition) {
        // üî• ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ SL/TP Points - ‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÅ‡∏ö‡∏ö‡πÑ‡∏°‡πà‡∏°‡∏µ SL/TP
        if(trade.Sell(customLot, _Symbol, 0, 0, 0, "Trend-Reduced")) {
            ulong ticket = trade.ResultOrder();
            Print("‚úÖ TREND REDUCED SELL | Lot: " + DoubleToString(customLot, 2) + 
                  " | Ticket: #" + IntegerToString(ticket));
        } else {
            Print("‚ùå Trend Reduced SELL Error: " + trade.ResultRetcodeDescription());
        }
    }
}
void ExecuteAdvancedBreakoutWithCustomLot(double customLot)
{
    if(!BreakoutStrategy) return;
    
    DebugPrint(3, "Executing Breakout with custom lot: " + DoubleToString(customLot, 2));
    
    if(!newBarBreakout) {
        DebugPrint(3, "Breakout: Not a new bar");
        return;
    }
    
    if(!ShouldOpenPosition("Breakout")) {
        DebugPrint(3, "Breakout: No valid signal found");
        return;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Margin
    if(!CheckMargin(customLot)) {
        DebugPrint(1, "Insufficient margin for Breakout: " + DoubleToString(customLot, 2));
        return;
    }
    
    trade.SetExpertMagicNumber(MAGIC_BREAKOUT);
    
    // ‡πÉ‡∏ä‡πâ logic ‡∏à‡∏≤‡∏Å ExecuteAdvancedBreakout() ‡πÅ‡∏ï‡πà‡πÉ‡∏ä‡πâ custom lot
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_M1, 0, 2, rates) == 2) {
        bool bullishBreakout = (rates[1].high < rates[0].high && rates[0].close > rates[1].high);
        bool bearishBreakout = (rates[1].low > rates[0].low && rates[0].close < rates[1].low);
        
        if(bullishBreakout) {
            double slPrice = rates[1].low - 10 * _Point;
            double tpPrice = rates[0].close + 15 * _Point;
            
            if(trade.Buy(customLot, _Symbol, slPrice, tpPrice, 0, "Breakout-Reduced")) {
                ulong ticket = trade.ResultOrder();
                Print("‚úÖ BREAKOUT REDUCED BUY | Lot: " + DoubleToString(customLot, 2) + 
                      " | Ticket: #" + IntegerToString(ticket));
            }
        }
        else if(bearishBreakout) {
            double slPrice = rates[1].high + 10 * _Point;
            double tpPrice = rates[0].close - 15 * _Point;
            
            if(trade.Sell(customLot, _Symbol, slPrice, tpPrice, 0, "Breakout-Reduced")) {
                ulong ticket = trade.ResultOrder();
                Print("‚úÖ BREAKOUT REDUCED SELL | Lot: " + DoubleToString(customLot, 2) + 
                      " | Ticket: #" + IntegerToString(ticket));
            }
        }
    }
}
void ExecuteScalp1WithCustomLot(double customLot)
{
    if(!Scalp1Enabled) return;
    
    DebugPrint(3, "Executing Scalp1 with custom lot: " + DoubleToString(customLot, 2));
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç Risk
    if(CalculateRiskPressure() >= 0.7) {
        DebugPrint(2, "Scalp1: Risk too high");
        return;
    }
    
    if(!ShouldOpenPosition("Scalp1")) {
        DebugPrint(3, "Scalp1: No valid signal found");
        return;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Margin
    if(!CheckMargin(customLot)) {
        DebugPrint(1, "Insufficient margin for Scalp1: " + DoubleToString(customLot, 2));
        return;
    }
    
    trade.SetExpertMagicNumber(MAGIC_SCALP1);
    
    // ‡πÉ‡∏ä‡πâ logic ‡∏à‡∏≤‡∏Å ExecuteScalp1() ‡πÅ‡∏ï‡πà‡πÉ‡∏ä‡πâ custom lot
    double ema9 = iMA(_Symbol, PERIOD_M1, 9, 0, MODE_EMA, PRICE_CLOSE);
    double ema21 = iMA(_Symbol, PERIOD_M1, 21, 0, MODE_EMA, PRICE_CLOSE);
    double rsi = iRSI(_Symbol, PERIOD_M1, 14, PRICE_CLOSE, 0);
    
    bool buyCondition = (ema9 > ema21 && rsi > 50);
    bool sellCondition = (ema9 < ema21 && rsi < 50);
    
    if(buyCondition) {
        double slPrice = GetSLPriceUniversal(true, Scalp1_SL_Points);
        double tpPrice = GetTPPriceUniversal(true, Scalp1_TP_Points);
        
        if(trade.Buy(customLot, _Symbol, slPrice, tpPrice, 0, "Scalp1-CustomLot")) {
            ulong ticket = trade.ResultOrder();
            Print("‚úÖ SCALP1 CUSTOM LOT BUY | Lot: " + DoubleToString(customLot, 2) + 
                  " | Ticket: #" + IntegerToString(ticket));
        }
    }
    else if(sellCondition) {
        double slPrice = GetSLPriceUniversal(false, Scalp1_SL_Points);
        double tpPrice = GetTPPriceUniversal(false, Scalp1_TP_Points);
        
        if(trade.Sell(customLot, _Symbol, slPrice, tpPrice, 0, "Scalp1-CustomLot")) {
            ulong ticket = trade.ResultOrder();
            Print("‚úÖ SCALP1 CUSTOM LOT SELL | Lot: " + DoubleToString(customLot, 2) + 
                  " | Ticket: #" + IntegerToString(ticket));
        }
    }
}
//---------------//

// üî• ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Scalp1 ‡πÉ‡∏ô‡πÇ‡∏´‡∏°‡∏î Recovery
void ExecuteScalp1WithReducedRisk()
{
    Print("üî∞ Scalp1 (Reduced Risk Mode)");
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏•‡∏≠‡∏ï‡∏ó‡∏µ‡πà‡∏•‡∏î‡∏•‡∏á
    double originalLot = CalculateSafeScalpLot();
    double reducedLot = originalLot * 0.3; // ‡∏•‡∏î‡πÄ‡∏´‡∏•‡∏∑‡∏≠ 30%
    
    // ‡πÉ‡∏ä‡πâ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î‡∏Ç‡∏∂‡πâ‡∏ô
    double ema9 = iMA(_Symbol, PERIOD_M1, 9, 0, MODE_EMA, PRICE_CLOSE);
    double ema21 = iMA(_Symbol, PERIOD_M1, 21, 0, MODE_EMA, PRICE_CLOSE);
    double rsi = iRSI(_Symbol, PERIOD_M1, 14, PRICE_CLOSE, 0);
    
    // üî• ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏°
    bool buyCondition = (ema9 > ema21 && rsi > 40 && rsi < 75); // Range ‡πÅ‡∏Ñ‡∏ö‡∏•‡∏á
    bool sellCondition = (ema9 < ema21 && rsi < 60 && rsi > 25);
    
    if(buyCondition) {
        // ‡πÉ‡∏ä‡πâ‡∏•‡∏≠‡∏ï‡∏ó‡∏µ‡πà‡∏•‡∏î‡∏•‡∏á
        trade.Buy(reducedLot, _Symbol, 0, 0, 0, "Scalp1-RecoveryMode");
    }
    else if(sellCondition) {
        trade.Sell(reducedLot, _Symbol, 0, 0, 0, "Scalp1-RecoveryMode");
    }
}

//------------------------REduce character-------------//

void ExecuteScalp1Reduced()
{
    if(!Scalp1Enabled) return;
    
    Print("üî∞ Scalp1 (Reduced Risk Mode)");
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏•‡∏≠‡∏ï‡∏ó‡∏µ‡πà‡∏•‡∏î‡∏•‡∏á
    double originalLot = CalculateSafeScalpLot();
    double reducedLot = originalLot * 0.3; // ‡∏•‡∏î‡πÄ‡∏´‡∏•‡∏∑‡∏≠ 30%
    
    // ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î‡∏Ç‡∏∂‡πâ‡∏ô
    double ema9 = iMA(_Symbol, PERIOD_M1, 9, 0, MODE_EMA, PRICE_CLOSE);
    double ema21 = iMA(_Symbol, PERIOD_M1, 21, 0, MODE_EMA, PRICE_CLOSE);
    double rsi = iRSI(_Symbol, PERIOD_M1, 14, PRICE_CLOSE, 0);
    
    // ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÅ‡∏ö‡∏ö reduced (‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏°)
    bool buyCondition = (ema9 > ema21 && rsi > 45 && rsi < 70);
    bool sellCondition = (ema9 < ema21 && rsi < 55 && rsi > 30);
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Risk Pressure ‡∏ó‡∏µ‡πà‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏°
    if(CalculateRiskPressure() > 0.3) {
        DebugPrint(2, "Scalp1Reduced: Risk too high, skipping");
        return;
    }
    
    if(buyCondition) {
        double sl = GetSLPriceUniversal(true, Scalp1_SL_Points);
        double tp = GetTPPriceUniversal(true, Scalp1_TP_Points);
        
        if(trade.Buy(reducedLot, _Symbol, sl, tp, 0, "Scalp1-Reduced")) {
            Print("‚úÖ SCALP1 REDUCED BUY | Lot: " + DoubleToString(reducedLot, 2));
        }
    }
    else if(sellCondition) {
        double sl = GetSLPriceUniversal(false, Scalp1_SL_Points);
        double tp = GetTPPriceUniversal(false, Scalp1_TP_Points);
        
        if(trade.Sell(reducedLot, _Symbol, sl, tp, 0, "Scalp1-Reduced")) {
            Print("‚úÖ SCALP1 REDUCED SELL | Lot: " + DoubleToString(reducedLot, 2));
        }
    }
}
void ExecuteScalp2Reduced()
{
    if(!Scalp2Enabled) return;
    
    Print("üî∞ Scalp2 (Reduced Risk Mode)");
    
    // ‡∏•‡∏î‡∏•‡∏≠‡∏ï‡πÄ‡∏´‡∏•‡∏∑‡∏≠ 40%
    double originalLot = CalculateSafeScalpLot();
    double reducedLot = originalLot * 0.4;
    
    // ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î‡∏Ç‡∏∂‡πâ‡∏ô + Risk Pressure ‡∏ï‡πà‡∏≥
    if(CalculateRecoveryRiskPressure() > 0.2) {
        DebugPrint(2, "Scalp2Reduced: Recovery risk too high, skipping");
        return;
    }
    
    // ‡πÉ‡∏ä‡πâ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÄ‡∏î‡∏¥‡∏°‡πÅ‡∏ï‡πà‡πÄ‡∏û‡∏¥‡πà‡∏° filter
    if(ShouldOpenPosition("Scalp2")) {
        // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡πÅ‡∏ï‡πà‡∏™‡πà‡∏á‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå reduced lot
        ExecuteScalp2WithCustomLot(reducedLot);
        Print("‚úÖ SCALP2 REDUCED | Lot: " + DoubleToString(reducedLot, 2));
    }
}
void ExecuteScalp3Reduced()
{
    if(!Scalp3_Enabled) return;
    
    Print("üî∞ Scalp3 (Reduced Risk Mode)");
    
    // ‡∏•‡∏î‡∏•‡∏≠‡∏ï‡πÄ‡∏´‡∏•‡∏∑‡∏≠ 35%
    double reducedLot = CalculateSafeScalpLot() * 0.35;
    
    // ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç Risk Pressure ‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î
    if(CalculateRecoveryRiskPressure() > 0.25) {
        DebugPrint(2, "Scalp3Reduced: Recovery risk too high, skipping");
        return;
    }
    
    // ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Reduced mode
    if(ShouldOpenPosition("Scalp3")) {
        // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡πÅ‡∏ï‡πà‡∏•‡∏î‡∏Ç‡∏ô‡∏≤‡∏î
        ExecuteScalp3WithReducedLot(reducedLot);
        Print("‚úÖ SCALP3 REDUCED | Lot: " + DoubleToString(reducedLot, 2));
    }
}
void ExecuteTrendReduced()
{
    if(!SimpleTrendScalpEnabled) return;
    
    Print("üî∞ Trend (Reduced Risk Mode)");
    
    // ‡∏•‡∏î‡∏•‡∏≠‡∏ï‡πÄ‡∏´‡∏•‡∏∑‡∏≠ 50%
    double reducedLot = CalculateSafeScalpLot() * 0.5;
    
    // ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç Risk Pressure
    if(CalculateRiskPressure() > 0.4) {
        DebugPrint(2, "TrendReduced: Risk too high, skipping");
        return;
    }
    
    // ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏ó‡∏µ‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏°
    ENUM_TREND_DIRECTION trend = AnalyzeMultiTimeframeTrend();
    double trendStrength = CalculateTrendStrength();
    
    // ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏ó‡∏µ‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô‡πÅ‡∏•‡∏∞‡πÅ‡∏£‡∏á‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
    if(trend != TREND_SIDEWAYS && trendStrength > 0.7) {
        if(ShouldOpenPosition("Trend")) {
            // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡πÅ‡∏ï‡πà‡∏™‡πà‡∏á reduced lot
            ExecuteSimpleTrendScalpWithCustomLot(reducedLot);
            Print("‚úÖ TREND REDUCED | Lot: " + DoubleToString(reducedLot, 2));
        }
    }
}
void ExecuteBreakoutReduced()
{
    if(!BreakoutStrategy) return;
    
    Print("üî∞ Breakout (Reduced Risk Mode)");
    
    // ‡∏•‡∏î‡∏•‡∏≠‡∏ï‡πÄ‡∏´‡∏•‡∏∑‡∏≠ 25% (Breakout ‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß)
    double reducedLot = CalculateSafeScalpLot() * 0.25;
    
    // ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î‡∏°‡∏≤‡∏Å
    if(!newBarBreakout) return;
    
    // ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô Breakout ‡∏ó‡∏µ‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
    if(IsStrongBreakout() && CalculateRiskPressure() < 0.2) {
        if(ShouldOpenPosition("Breakout")) {
            // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡πÅ‡∏ï‡πà‡∏™‡πà‡∏á reduced lot
            ExecuteAdvancedBreakoutWithCustomLot(reducedLot);
            Print("‚úÖ BREAKOUT REDUCED | Lot: " + DoubleToString(reducedLot, 2));
        }
    } else {
        DebugPrint(3, "BreakoutReduced: Not strong breakout or risk too high");
    }
}
// üìç ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Strong Breakout
bool IsStrongBreakout()
{
    MqlRates rates[];
    if(CopyRates(_Symbol, PERIOD_M1, 0, 3, rates) < 3) return false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Bullish Breakout
    bool bullishBreakout = (rates[2].high < rates[1].high && 
                           rates[1].high < rates[0].high && 
                           rates[0].close > rates[1].high + 5 * _Point);
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Bearish Breakout
    bool bearishBreakout = (rates[2].low > rates[1].low && 
                           rates[1].low > rates[0].low && 
                           rates[0].close < rates[1].low - 5 * _Point);
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Volume (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
    bool volumeConfirm = (rates[0].tick_volume > rates[1].tick_volume * 1.2);
    
    return (bullishBreakout || bearishBreakout) && volumeConfirm;
}
//+------------------------------------------------------------------+
//| Execute Recovery Coordination                                  |
//+------------------------------------------------------------------+
void ExecuteRecoveryCoordination()
{
    // ‡πÉ‡∏ô‡πÇ‡∏´‡∏°‡∏î Recovery ‡πÉ‡∏´‡πâ‡∏ó‡∏∏‡∏Å‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ô
    int bestPerformer = FindBestPerformingStrategy();
    
    if(bestPerformer != -1) {
        Print("üèÜ RECOVERY COORDINATOR: " + strategies[bestPerformer].name + " leading recovery team");
        
        // üî• 1. ‡∏ú‡∏π‡πâ‡∏ô‡∏≥‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏µ‡πà
        ExecuteRecoveryLeader(bestPerformer);
        
        // üî• 2. ‡∏ú‡∏π‡πâ‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏î‡∏£‡∏∞‡∏î‡∏±‡∏ö
        ExecuteRecoverySupporters(bestPerformer);
    }
    
    // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å Recovery Systems ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ä‡πà‡∏ß‡∏¢‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç
    ExecuteRecoverySystems();
}

// üî• ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà: ‡∏ú‡∏π‡πâ‡∏ô‡∏≥‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏µ‡πà
void ExecuteRecoveryLeader(int leaderIndex)
{
    Print("   üéØ LEADER: " + strategies[leaderIndex].name + " - Full power");
    
    switch(leaderIndex) {
        case 0: if(Scalp1Enabled) ExecuteScalp1(); break;
        case 1: if(Scalp2Enabled) ExecuteScalp2(); break;
        case 2: if(Scalp3_Enabled) ExecuteScalp3Integrated(); break;
        case 3: if(SimpleTrendScalpEnabled) ExecuteSimpleTrendScalp(); break;
        case 4: if(BreakoutStrategy) ExecuteAdvancedBreakout(); break;
    }
}

// üî• ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà: ‡∏ú‡∏π‡πâ‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏•‡∏î‡∏£‡∏∞‡∏î‡∏±‡∏ö
void ExecuteRecoverySupporters(int leaderIndex)
{
    for(int i = 0; i < 5; i++) {
        if(i != leaderIndex && strategies[i].isActive) {
            Print("   ü§ù SUPPORTER: " + strategies[i].name + " - Reduced activity");
            
            // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô Reduced version ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå
            // (‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°)
        }
    }
}
//+------------------------------------------------------------------+
//| Execute Recovery Systems (‡πÅ‡∏¢‡∏Å‡∏à‡∏≤‡∏Å‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡πÄ‡∏ó‡∏£‡∏î)                  |
//+------------------------------------------------------------------+
void ExecuteRecoverySystems()
{
    // ‚úÖ Individual Recovery System
    if(EnableIndividualRecovery) {
        ManageIndividualRecoverySets();
    }
    
    // ‚úÖ Step-Up Recovery System  
    if(StepUpRecoveryEnabled) {
        ManageStepUpRecovery();
    }
    
    // ‚úÖ Counter Position System
    if(EnableCounterPosition) {
        ManageCounterPositions(MARKET_REGIME_NORMAL); 
    }
    
    // ‚úÖ Orphan Management System
    if(EnableUniversalOrphan) {
        ManageOrphanUniversal();
        ManageOrphanWorkers();
    }
    
    // ‚úÖ Emergency Hedge System
    if(UseEmergencyHedge) {
        CheckEmergencyHedge();
    }
    
    // ‚úÖ Ultimate Fighting Recovery System
    if(UltimateFightingMode && newBar) {
        ExecuteUltimateFightingRecovery(); // ‚úÖ ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏≠‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
    }
}
//+------------------------------------------------------------------+
//| Execute AI Systems                                             |
//+------------------------------------------------------------------+
void ExecuteAISystems()
{
    if(AI_NewsTrading_Enabled && newBarAI) {
        // AI News Trading Logic
        if(ShouldOpenPosition("AI-News")) {
            // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô AI News Trading
        }
    }
    
    if(AI_TrendTrading_Enabled && newBarAI) {
        // AI Trend Trading Logic  
        if(ShouldOpenPosition("AI-Trend")) {
            // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡πà‡∏ô AI Trend Trading
        }
    }
}

//+------------------------------------------------------------------+
//| Execute Low Risk Opportunities                                |
//+------------------------------------------------------------------+
void ExecuteLowRiskOpportunities()
{
    if(newBar && CalculateRiskPressure() < 0.3) {
        // Low Risk Trading Logic
        ExecuteLowRiskOpportunity();
    }
}


//+------------------------------------------------------------------+
//| Is Strategy Over Performing                                    |
//+------------------------------------------------------------------+
bool IsStrategyOverPerforming(int index)
{
    if(index < 0 || index >= 5) return false;
    return (strategies[index].progress > 120); // ‡∏ó‡∏≥‡πÑ‡∏î‡πâ‡πÄ‡∏Å‡∏¥‡∏ô 120% ‡∏Ç‡∏≠‡∏á target
}

//+------------------------------------------------------------------+
//| Limit Strategy Operations                                      |
//+------------------------------------------------------------------+
void LimitStrategyOperations(int index)
{
    if(index < 0 || index >= 5) return;
    
    Print("üõë Limiting " + strategies[index].name + " operations (Over-performing: " + 
          DoubleToString(strategies[index].progress, 1) + "%)");
    
    // ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏° logic ‡∏Å‡∏≤‡∏£‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà
    // ‡πÄ‡∏ä‡πà‡∏ô ‡∏•‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î, ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå ‡∏Ø‡∏•‡∏Ø
}
bool CheckRecoveryScalp2Conditions(ENUM_MARKET_REGIME regime, string symbol = NULL)
{
    if(symbol == NULL) symbol = Symbol();
    
    // Recovery Scalp 2 Conditions
    Print("Checking Recovery Scalp 2 Conditions for ", symbol, " - Regime: ", regime);
    
    // ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç:
    // 1. Price near recent low for bounce
    double recentLow = iLow(symbol, PERIOD_M15, iLowest(symbol, PERIOD_M15, MODE_LOW, 10, 1));
    double currentPrice = SymbolInfoDouble(symbol, SYMBOL_BID);
    bool nearSupport = (currentPrice <= recentLow * 1.005); // Within 0.5% of support
    
    // 2. RSI oversold
    double rsi = iRSI(symbol, PERIOD_M15, 14, PRICE_CLOSE, 0);
    bool rsiOversold = (rsi < 30);
    
    // 3. Regime-based adjustments
    switch(regime)
    {
        case MARKET_REGIME_RANGING_CALM:
            // Good for scalp in calm range
            return nearSupport && rsiOversold;
            
        case MARKET_REGIME_TRENDING_STRONG:
            // Be careful in strong trend
            return false; // Usually avoid scalp in strong trend
            
        default:
            return nearSupport && rsiOversold;
    }
}

bool CheckRecoveryScalp3Conditions(ENUM_MARKET_REGIME regime, string symbol = NULL)
{
    if(symbol == NULL) symbol = Symbol();
    
    Print("Checking Recovery Scalp 3 Conditions for ", symbol, " - Regime: ", regime);
    
    // 1. Price consolidation pattern
    double high10 = iHigh(symbol, PERIOD_M5, iHighest(symbol, PERIOD_M5, MODE_HIGH, 10, 1));
    double low10 = iLow(symbol, PERIOD_M5, iLowest(symbol, PERIOD_M5, MODE_LOW, 10, 1));
    double range = high10 - low10;
    double currentPrice = SymbolInfoDouble(symbol, SYMBOL_BID);
    
    bool tightRange = (range / currentPrice < 0.002); // Less than 0.2% range
    
    // 2. Bollinger Bands squeeze (‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á)
    double bbUpper = 0, bbMiddle = 0, bbLower = 0;
    
    // ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤ Bollinger Bands
    int bbHandle = iBands(symbol, PERIOD_M5, 20, 0, 2.0, PRICE_CLOSE);
    if(bbHandle != INVALID_HANDLE)
    {
        double upperArr[1], lowerArr[1];
        
        if(CopyBuffer(bbHandle, 1, 0, 1, upperArr) >= 1 &&
           CopyBuffer(bbHandle, 2, 0, 1, lowerArr) >= 1)
        {
            bbUpper = upperArr[0];
            bbLower = lowerArr[0];
            
            double bbWidth = (bbUpper - bbLower) / currentPrice;
            bool bbSqueeze = (bbWidth < 0.01); // Less than 1% width
            
            IndicatorRelease(bbHandle);
            
            // 3. Regime-based adjustments
            switch(regime)
            {
                case MARKET_REGIME_RANGING_CALM:
                    return tightRange && bbSqueeze;
                    
                case MARKET_REGIME_BREAKOUT_POTENTIAL:
                    return tightRange && bbSqueeze;
                    
                case MARKET_REGIME_TRENDING_STRONG:
                    return false;
                    
                default:
                    return tightRange || bbSqueeze;
            }
        }
        IndicatorRelease(bbHandle);
    }
    
    return false;
}
//+------------------------------------------------------------------+
//| Should Open Position                                            |
//+------------------------------------------------------------------+
bool ShouldOpenPosition(string strategyName, double value = 0, void* params = NULL, ENUM_MARKET_REGIME regime = MARKET_REGIME_NORMAL)
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô
    if(!IsMarketGoodForTrading(_Symbol)) return false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ï‡∏≤‡∏° strategy
    if(strategyName == "Scalp1") 
    {
        return CheckScalp1Conditions(regime);
    }
    else if(strategyName == "Trend") 
    {
        return CheckTrendConditions(regime, Symbol());
    }
    else if(strategyName == "Breakout") 
    {
        return CheckBreakoutConditions(Symbol());
    }
    else if(strategyName == "RecoveryScalp2") 
    {
        return CheckRecoveryScalp2Conditions(regime, Symbol());
    }
    else if(strategyName == "RecoveryScalp3") 
    {
        return CheckRecoveryScalp3Conditions(regime, Symbol());
    }
    
    return false;
}
bool IsPullbackEntry(string symbol = NULL, ENUM_TIMEFRAMES timeframe = PERIOD_CURRENT)
{
    if(symbol == NULL) symbol = Symbol();
    
    // Pullback entry detection logic
    
    // 1. Check if in uptrend or downtrend
    double maFast = iMA(symbol, timeframe, 20, 0, MODE_EMA, PRICE_CLOSE);
    double maSlow = iMA(symbol, timeframe, 50, 0, MODE_EMA, PRICE_CLOSE);
    
    bool isUptrend = (maFast > maSlow);
    bool isDowntrend = (maFast < maSlow);
    
    if(!isUptrend && !isDowntrend) 
        return false; // Not in trend
    
    // 2. Get current price
    double currentPrice = SymbolInfoDouble(symbol, isUptrend ? SYMBOL_BID : SYMBOL_ASK);
    
    // 3. Check for pullback to moving average
    double distanceToMA = MathAbs(currentPrice - maFast);
    double distancePercent = (distanceToMA / currentPrice) * 100;
    
    // Pullback condition: price near MA (within 0.5%)
    bool nearMA = (distancePercent < 0.5);
    
    // 4. Check momentum (RSI)
    double rsi = iRSI(symbol, timeframe, 14, PRICE_CLOSE, 0);
    
    if(isUptrend)
    {
        // For uptrend pullback: RSI should be between 40-60 (not oversold)
        bool rsiCondition = (rsi > 40 && rsi < 60);
        return nearMA && rsiCondition;
    }
    else // Downtrend
    {
        // For downtrend pullback: RSI should be between 40-60 (not overbought)
        bool rsiCondition = (rsi > 40 && rsi < 60);
        return nearMA && rsiCondition;
    }
}
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ï‡∏≤‡∏° Regime
bool CheckScalp1Conditions(ENUM_MARKET_REGIME regime)
{
    switch(regime)
    {
        case MARKET_REGIME_RANGING_VOLATILE:
            // ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô range-based
            return IsAtRangeBoundary();
            
        case MARKET_REGIME_TRENDING_STRONG:
            // ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô pullback entry
            return IsPullbackEntry();
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            // ‡∏£‡∏≠ breakout confirmation
            return IsConfirmedBreakout();
            
        case MARKET_REGIME_NORMAL:
        default:
            // ‡πÉ‡∏ä‡πâ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏õ‡∏Å‡∏ï‡∏¥
            return CheckDefaultScalp1Conditions();
    }
}
ENUM_TREND_DIRECTION GetMajorTrend(ENUM_TIMEFRAMES tf)
{
    // ‚úÖ ‡∏£‡∏π‡πâ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÉ‡∏´‡∏ç‡πà‡∏à‡∏≤‡∏Å Higher Timeframe
    double ema50 = GetEMAValue(Symbol(), PERIOD_CURRENT, 50, 0);
    double ema200 = GetEMAValue(Symbol(), PERIOD_CURRENT, 200, 0);
    double currentPrice = SymbolInfoDouble(Symbol(), SYMBOL_BID);
    
    // ‡πÉ‡∏ä‡πâ CopyBuffer ‡πÅ‡∏ö‡∏ö‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
    int ema50Handle = iMA(Symbol(), tf, 50, 0, MODE_EMA, PRICE_CLOSE);
    int ema200Handle = iMA(Symbol(), tf, 200, 0, MODE_EMA, PRICE_CLOSE);
    
    double ema50Arr[1], ema200Arr[1];
    CopyBuffer(ema50Handle, 0, 0, 1, ema50Arr);
    CopyBuffer(ema200Handle, 0, 0, 1, ema200Arr);
    IndicatorRelease(ema50Handle);
    IndicatorRelease(ema200Handle);
    
    ema50 = ema50Arr[0];
    ema200 = ema200Arr[0];
    
    if(currentPrice > ema50 && ema50 > ema200)
        return TREND_UP;
    else if(currentPrice < ema50 && ema50 < ema200)
        return TREND_DOWN;
    else
        return TREND_SIDEWAYS;
}

ENUM_TREND_DIRECTION GetMinorTrend(ENUM_TIMEFRAMES tf)
{
    // ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤ EMA9 ‡πÅ‡∏•‡∏∞ EMA21
    int ema9Handle = iMA(Symbol(), tf, 9, 0, MODE_EMA, PRICE_CLOSE);
    int ema21Handle = iMA(Symbol(), tf, 21, 0, MODE_EMA, PRICE_CLOSE);
    
    double ema9Arr[1], ema21Arr[1];
    
    CopyBuffer(ema9Handle, 0, 0, 1, ema9Arr);
    CopyBuffer(ema21Handle, 0, 0, 1, ema21Arr);
    
    IndicatorRelease(ema9Handle);
    IndicatorRelease(ema21Handle);
    
    double ema9 = ema9Arr[0];
    double ema21 = ema21Arr[0];
    double currentPrice = SymbolInfoDouble(Symbol(), SYMBOL_BID);
    
    if(currentPrice > ema9 && ema9 > ema21)
        return TREND_UP;
    else if(currentPrice < ema9 && ema9 < ema21)
        return TREND_DOWN;
    else
        return TREND_SIDEWAYS;
}

bool FindSmartScalpEntry(ENUM_TREND_DIRECTION majorTrend, ENUM_TREND_DIRECTION minorTrend)
{
    // ‚úÖ ‡∏´‡∏≤‡πÇ‡∏≠‡∏Å‡∏≤‡∏™ entry ‡∏ó‡∏µ‡πà‡∏â‡∏•‡∏≤‡∏î (‡∏ï‡∏≤‡∏°‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÉ‡∏´‡∏ç‡πà)
    
    // 1. ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ alignment ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á major ‡πÅ‡∏•‡∏∞ minor trend
    if(majorTrend == TREND_UP && minorTrend == TREND_UP)
    {
        // ‚úÖ Uptrend alignment - Look for pullback to buy
        return FindPullbackEntry(ORDER_TYPE_BUY);
    }
    else if(majorTrend == TREND_DOWN && minorTrend == TREND_DOWN)
    {
        // ‚úÖ Downtrend alignment - Look for pullback to sell
        return FindPullbackEntry(ORDER_TYPE_SELL);
    }
    else if(majorTrend == TREND_SIDEWAYS && (minorTrend == TREND_UP || minorTrend == TREND_DOWN))
    {
        // ‚úÖ Range market - look for breakout or range bounce
        return FindRangeEntry(minorTrend);
    }
    
    return false; // No smart entry found
}

bool FindPullbackEntry(ENUM_ORDER_TYPE orderType)
{
    // ‚úÖ ‡∏´‡∏≤ pullback entry ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö scalp
    double currentPrice = SymbolInfoDouble(Symbol(), orderType == ORDER_TYPE_BUY ? SYMBOL_BID : SYMBOL_ASK);
    double ema20 = iMA(Symbol(), PERIOD_M5, 20, 0, MODE_EMA, PRICE_CLOSE);
    
    // ‡πÉ‡∏ä‡πâ CopyBuffer
    int ema20Handle = iMA(Symbol(), PERIOD_M5, 20, 0, MODE_EMA, PRICE_CLOSE);
    double ema20Arr[1];
    CopyBuffer(ema20Handle, 0, 0, 1, ema20Arr);
    IndicatorRelease(ema20Handle);
    ema20 = ema20Arr[0];
    
    double distancePercent = MathAbs(currentPrice - ema20) / currentPrice * 100;
    
    // Pullback condition: ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏Å‡∏•‡πâ EMA (0.1%-0.5%)
    bool nearEMA = (distancePercent >= 0.1 && distancePercent <= 0.5);
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö RSI ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö confirmation
    double rsi = iRSI(Symbol(), PERIOD_M5, 14, PRICE_CLOSE, 0);
    
    if(orderType == ORDER_TYPE_BUY)
    {
        // Buy pullback: RSI ‡∏Ñ‡∏ß‡∏£‡∏à‡∏∞‡πÑ‡∏°‡πà oversold ‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
        return nearEMA && (rsi > 40 && rsi < 70);
    }
    else // SELL
    {
        // Sell pullback: RSI ‡∏Ñ‡∏ß‡∏£‡∏à‡∏∞‡πÑ‡∏°‡πà overbought ‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
        return nearEMA && (rsi > 30 && rsi < 60);
    }
}

bool FindRangeEntry(ENUM_TREND_DIRECTION minorTrend)
{
    // ‚úÖ ‡∏´‡∏≤ entry ‡πÉ‡∏ô range market
    
    // ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤ Bollinger Bands ‡πÅ‡∏ö‡∏ö‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
    int bbHandle = iBands(Symbol(), PERIOD_M5, 20, 0, 2.0, PRICE_CLOSE);
    
    if(bbHandle == INVALID_HANDLE)
    {
        Print("Failed to create Bollinger Bands indicator");
        return false;
    }
    
    double bbUpperArr[1], bbLowerArr[1];
    
    // Copy values
    bool upperSuccess = CopyBuffer(bbHandle, 1, 0, 1, bbUpperArr) >= 1;
    bool lowerSuccess = CopyBuffer(bbHandle, 2, 0, 1, bbLowerArr) >= 1;
    
    IndicatorRelease(bbHandle);
    
    if(!upperSuccess || !lowerSuccess)
    {
        Print("Failed to copy Bollinger Bands values");
        return false;
    }
    
    double bbUpper = bbUpperArr[0];
    double bbLower = bbLowerArr[0];
    double currentPrice = SymbolInfoDouble(Symbol(), SYMBOL_BID);
    
    // Range trading: Buy near lower band, Sell near upper band
    if(minorTrend == TREND_UP || minorTrend == TREND_SIDEWAYS)
    {
        // Consider buying near support
        double distanceToLower = (currentPrice - bbLower) / currentPrice * 100;
        return (distanceToLower <= 0.2); // Within 0.2% of lower band
    }
    else // TREND_DOWN
    {
        // Consider selling near resistance
        double distanceToUpper = (bbUpper - currentPrice) / currentPrice * 100;
        return (distanceToUpper <= 0.2); // Within 0.2% of upper band
    }
}

bool CheckRiskRewardRatio(double minRatio)
{
    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö risk/reward ratio
    double stopLossPips = CalculateOptimalStopLoss();
    double takeProfitPips = CalculateOptimalTakeProfit();
    
    if(stopLossPips <= 0 || takeProfitPips <= 0)
        return false;
    
    double ratio = takeProfitPips / stopLossPips;
    return (ratio >= minRatio);
}

bool CheckMomentumVolume()
{
    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö momentum ‡πÅ‡∏•‡∏∞ volume
    
    // 1. Volume ‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤ average (‡πÅ‡∏Å‡πâ type conversion)
    long currentVolumeLong = iVolume(Symbol(), PERIOD_M5, 0);
    long vol1 = iVolume(Symbol(), PERIOD_M5, 1);
    long vol2 = iVolume(Symbol(), PERIOD_M5, 2);
    long vol3 = iVolume(Symbol(), PERIOD_M5, 3);
    
    long avgVolumeLong = (vol1 + vol2 + vol3) / 3;
    
    double currentVolume = (double)currentVolumeLong;
    double avgVolume = (double)avgVolumeLong;
    
    if(currentVolume < avgVolume * 0.8) // ‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤ 80% ‡∏Ç‡∏≠‡∏á average
    {
        Print("Volume insufficient: ", currentVolume, " vs avg: ", avgVolume);
        return false;
    }
    
    // 2. MACD ‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏™‡∏î‡∏á momentum (‡πÅ‡∏Å‡πâ iMACD usage)
    int macdHandle = iMACD(Symbol(), PERIOD_M5, 12, 26, 9, PRICE_CLOSE);
    
    if(macdHandle == INVALID_HANDLE)
    {
        Print("Failed to create MACD indicator");
        return false;
    }
    
    double macdMainArr[1], macdSignalArr[1];
    
    // Copy MACD values
    // Buffer 0 = Main line
    // Buffer 1 = Signal line
    bool mainSuccess = CopyBuffer(macdHandle, 0, 0, 1, macdMainArr) >= 1;
    bool signalSuccess = CopyBuffer(macdHandle, 1, 0, 1, macdSignalArr) >= 1;
    
    IndicatorRelease(macdHandle);
    
    if(!mainSuccess || !signalSuccess)
    {
        Print("Failed to copy MACD buffer");
        return false;
    }
    
    double macdMain = macdMainArr[0];
    double macdSignal = macdSignalArr[0];
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ MACD ‡∏°‡∏µ momentum ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    double macdDiff = MathAbs(macdMain - macdSignal);
    
    if(macdDiff <= 0.0001) // MACD ‡πÅ‡∏ó‡∏ö‡πÑ‡∏°‡πà‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á (sideways)
    {
        Print("MACD shows no momentum. Diff: ", macdDiff);
        return false;
    }
    
    // 3. ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö RSI ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô momentum
    double rsi = iRSI(Symbol(), PERIOD_M5, 14, PRICE_CLOSE, 0);
    
    // ‡πÉ‡∏ä‡πâ CopyBuffer ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö RSI
    int rsiHandle = iRSI(Symbol(), PERIOD_M5, 14, PRICE_CLOSE);
    double rsiArr[1];
    
    if(rsiHandle != INVALID_HANDLE)
    {
        if(CopyBuffer(rsiHandle, 0, 0, 1, rsiArr) >= 1)
        {
            rsi = rsiArr[0];
            // RSI ‡∏Ñ‡∏ß‡∏£‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô extreme zone (20-80 ‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î)
            if(rsi < 20 || rsi > 80)
            {
                Print("RSI in extreme zone: ", rsi);
                IndicatorRelease(rsiHandle);
                return false;
            }
        }
        IndicatorRelease(rsiHandle);
    }
    
    Print("‚úÖ Momentum/Volume check passed. MACD diff: ", macdDiff, ", RSI: ", rsi);
    return true;
}

// ===== SIMPLE VERSIONS FOR MISSING FUNCTIONS =====
bool IsMarketActive()
{
    // Simple market activity check
    MqlDateTime timeNow;
    TimeCurrent(timeNow);
    
    // Check if within trading hours (Mon-Fri, 8AM-5PM)
    if(timeNow.day_of_week >= 1 && timeNow.day_of_week <= 5) // Mon-Fri
    {
        if(timeNow.hour >= 8 && timeNow.hour < 17) // 8AM-5PM
        {
            return true;
        }
    }
    return false;
}

bool IsHighImpactNews()
{
    // Placeholder - ‡πÉ‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏£‡∏¥‡∏á‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö news feed
    return false; // Assume no high impact news for now
}

double CalculateOptimalStopLoss()
{
    double atr = GetATRValue(Symbol(), PERIOD_M5, 14, 0);
    
    if(atr <= 0)
    {
        Print("Failed to get ATR value, using default");
        return 20 * Point(); // Default 20 pips
    }
    
    return atr * 1.5; // 1.5 x ATR
}


double CalculateOptimalTakeProfit()
{
    double atr = GetATRValue(Symbol(), PERIOD_M5, 14, 0);
    
    if(atr <= 0)
    {
        Print("Failed to get ATR value, using default");
        return 30 * Point(); // Default 30 pips
    }
    
    return atr * 2.5; // 2.5 x ATR
}
bool CheckMarketConditions()
{
    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î
    // 1. Spread ‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡πà‡∏≥ (‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö scalp)
    int spread = (int)SymbolInfoInteger(Symbol(), SYMBOL_SPREAD);
    if(spread > 5) // ‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 5 pips ‡πÑ‡∏°‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞
    {
        Print("Spread too high: ", spread);
        return false;
    }
    
    // 2. Market ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏™‡∏†‡∏≤‡∏û‡∏Ñ‡∏•‡πà‡∏≠‡∏á
    if(!IsMarketActive())
        return false;
    
    // 3. ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏ä‡πà‡∏ß‡∏á news ‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç
    if(IsHighImpactNews())
    {
        Print("High impact news - avoid trading");
        return false;
    }
    
    return true;
}
bool CheckDefaultScalp1Conditions()
{
    // üî• SMART SCALP 1.0 - ‡πÄ‡∏ó‡∏£‡∏î‡∏â‡∏•‡∏≤‡∏î ‡∏£‡∏π‡πâ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå ‡∏à‡∏±‡∏ö‡∏™‡∏ß‡∏¥‡∏á‡πÑ‡∏î‡πâ‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô
    
    // 1. ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô (‡πÑ‡∏°‡πà‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î)
    if(!CheckMarketConditions()) 
    {
        Print("‚ùå Market conditions not suitable for smart scalp");
        return false;
    }
    
    // 2. ‚úÖ ‡∏£‡∏π‡πâ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÉ‡∏´‡∏ç‡πà (Higher Timeframe Analysis)
    ENUM_TREND_DIRECTION majorTrend = GetMajorTrend(PERIOD_H1);
    ENUM_TREND_DIRECTION minorTrend = GetMinorTrend(PERIOD_M5);
    
    // 3. ‚úÖ ‡∏´‡∏≤‡πÇ‡∏≠‡∏Å‡∏≤‡∏™ entry ‡∏ó‡∏µ‡πà‡∏â‡∏•‡∏≤‡∏î (Smart Entry)
    bool smartEntryFound = FindSmartScalpEntry(majorTrend, minorTrend);
    
    if(!smartEntryFound)
    {
        Print("‚ùå No smart entry found");
        return false;
    }
    
    // 4. ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö risk/reward ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
    if(!CheckRiskRewardRatio(1.5)) // 1:1.5 minimum
    {
        Print("‚ùå Risk/Reward ratio not favorable");
        return false;
    }
    
    // 5. ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö momentum ‡πÅ‡∏•‡∏∞ volume
    if(!CheckMomentumVolume())
    {
        Print("‚ùå Momentum or volume insufficient");
        return false;
    }
    
    Print("‚úÖ SMART SCALP: Conditions met! Major Trend: ", majorTrend, 
          ", Minor Trend: ", minorTrend);
    return true;
}
bool IsGoodMarketForScalp(string symbol)
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏ó‡∏£‡∏î
    MqlDateTime timeNow;
    TimeCurrent(timeNow);
    
    // ‡πÄ‡∏ó‡∏£‡∏î‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ß‡∏±‡∏ô‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå-‡∏®‡∏∏‡∏Å‡∏£‡πå
    if(timeNow.day_of_week == 0 || timeNow.day_of_week == 6) // ‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏™‡∏≤‡∏£‡πå
        return false;
    
    // ‡πÄ‡∏ó‡∏£‡∏î‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏°‡∏µ liquidity ‡∏™‡∏π‡∏á (‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡∏ï‡∏•‡∏≤‡∏î)
    // Forex: 8:00-17:00 (‡πÄ‡∏ß‡∏•‡∏≤ server)
    if(timeNow.hour < 8 || timeNow.hour >= 17)
        return false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ market ‡πÄ‡∏õ‡∏¥‡∏î
    long marketInfo = SymbolInfoInteger(symbol, SYMBOL_TRADE_MODE);
    if(marketInfo != SYMBOL_TRADE_MODE_FULL)
        return false;
    
    return true;
}
// üî• ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏ó‡∏£‡∏î‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡πÑ‡∏´‡∏ô‡πÉ‡∏ô‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î‡πÑ‡∏´‡∏ô
bool IsStrategySuitableForMarket(string strategyType, string marketCondition)
{
    if(strategyType == "Scalp1" || strategyType == "Scalp2" || strategyType == "Scalp3") 
    {
        // Scalp ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡∏™‡∏†‡∏≤‡∏û‡∏¢‡∏Å‡πÄ‡∏ß‡πâ‡∏ô‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô‡∏™‡∏π‡∏á
        return (marketCondition != "HIGH_VOLATILITY");
    }
    else if(strategyType == "Trend" || strategyType == "SimpleTrendScalp") 
    {
        // Trend ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏•‡∏≤‡∏î‡∏°‡∏µ‡πÅ‡∏ô‡∏ß‡πÇ‡∏ô‡πâ‡∏°‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô
        return (marketCondition == "TRENDING" || marketCondition == "BREAKOUT");
    }
    else if(strategyType == "Breakout" || strategyType == "AdvancedBreakout") 
    {
        // Breakout ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏•‡∏≤‡∏î‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á Breakout
        return (marketCondition == "BREAKOUT" || marketCondition == "TRENDING");
    }
    else if(strategyType == "Recovery" || strategyType == "RecoveryScalp2" || strategyType == "RecoveryScalp3") 
    {
        // Recovery ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡∏™‡∏†‡∏≤‡∏û ‡πÅ‡∏ï‡πà‡∏£‡∏∞‡∏ß‡∏±‡∏á‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
        if(marketCondition == "HIGH_VOLATILITY") {
            Print("‚ö†Ô∏è " + strategyType + ": Recovery in high volatility market - be cautious");
        }
        return true;
    }
    else if(strategyType == "Hedge" || strategyType == "CounterPosition") 
    {
        // Hedge ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏î‡∏µ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
        return (marketCondition == "HIGH_VOLATILITY" || marketCondition == "RANGING");
    }
    
    // Default - ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏£‡∏π‡πâ‡∏à‡∏±‡∏Å strategy
    return true;
}

// üî• **‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå**
bool CheckStrategySpecificConditions(string strategyName, string symbol)
{
    if(strategyName == "TrendStrong") {
        return CheckTrendConditions(true, symbol);
    }
    else if(strategyName == "TrendWeak") {
        return CheckTrendConditions(false, symbol);
    }
    else if(strategyName == "Scalp1") {
        return CheckScalpConditions(symbol);
    }
    else if(strategyName == "RangeCalm") {
        return CheckRangeConditions(symbol);
    }
    else if(strategyName == "Breakout") {
        return CheckBreakoutConditions(symbol);
    }
    
    // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏ ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ
    return CheckBasicTradingConditions(symbol);
}

// üî• **‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°**
bool CheckBasicTradingConditions(string symbol)
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
    if(!TerminalInfoInteger(TERMINAL_CONNECTED)) {
        Print("Terminal not connected");
        return false;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î
    if(!TerminalInfoInteger(TERMINAL_TRADE_ALLOWED)) {
        Print("Trading not allowed");
        return false;
    }
    
    // üîß **‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏ö‡∏ö‡∏á‡πà‡∏≤‡∏¢: ‡πÉ‡∏ä‡πâ spread ‡πÅ‡∏ö‡∏ö points ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á**
    long spreadPoints = SymbolInfoInteger(symbol, SYMBOL_SPREAD);
    
    // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤ spread ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏¢‡∏≠‡∏°‡πÑ‡∏î‡πâ (‡πÉ‡∏ô points)
    long maxAllowedSpreadPoints = 30; // 3 pips ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö forex
    
    if(spreadPoints > maxAllowedSpreadPoints) {
        Print("Spread too high: " + IntegerToString(spreadPoints) + " points (max: " + IntegerToString(maxAllowedSpreadPoints) + ")");
        return false;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏ó‡∏£‡∏î
    if(IsBadTradingTime()) {
        Print("Bad trading time");
        return false;
    }
    
    return true;
}
// üî• ‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏Å‡πà‡∏≤ (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö backward compatibility)
bool CheckTrendConditionsLegacy(bool strongTrend, string symbol)
{
    // Convert bool to regime
    ENUM_MARKET_REGIME regime = strongTrend ? MARKET_REGIME_TRENDING_STRONG : MARKET_REGIME_NORMAL;
    return CheckTrendConditions(regime, symbol);
}

// üî• **‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå**
bool CheckTrendConditions(ENUM_MARKET_REGIME regime, string symbol)
{
    // üîß **‡πÉ‡∏ä‡πâ MQL5 syntax ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö indicators**
    int emaFastHandle = iMA(symbol, PERIOD_H1, 9, 0, MODE_EMA, PRICE_CLOSE);
    int emaMediumHandle = iMA(symbol, PERIOD_H1, 21, 0, MODE_EMA, PRICE_CLOSE);
    int emaSlowHandle = iMA(symbol, PERIOD_H1, 50, 0, MODE_EMA, PRICE_CLOSE);
    
    double emaFast[1], emaMedium[1], emaSlow[1];
    double emaFastPrev[1];
    
    // ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å indicators
    if(CopyBuffer(emaFastHandle, 0, 0, 1, emaFast) <= 0) 
    {
        IndicatorRelease(emaFastHandle);
        IndicatorRelease(emaMediumHandle);
        IndicatorRelease(emaSlowHandle);
        return false;
    }
    
    if(CopyBuffer(emaMediumHandle, 0, 0, 1, emaMedium) <= 0) 
    {
        IndicatorRelease(emaFastHandle);
        IndicatorRelease(emaMediumHandle);
        IndicatorRelease(emaSlowHandle);
        return false;
    }
    
    if(CopyBuffer(emaSlowHandle, 0, 0, 1, emaSlow) <= 0) 
    {
        IndicatorRelease(emaFastHandle);
        IndicatorRelease(emaMediumHandle);
        IndicatorRelease(emaSlowHandle);
        return false;
    }
    
    if(CopyBuffer(emaFastHandle, 0, 1, 1, emaFastPrev) <= 0) 
    {
        emaFastPrev[0] = emaFast[0]; // ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏Å‡πà‡∏≤‡πÑ‡∏î‡πâ
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏±‡∏ß‡∏Ç‡∏≠‡∏á EMA
    bool emaBullish = (emaFast[0] > emaMedium[0] && emaMedium[0] > emaSlow[0]);
    bool emaBearish = (emaFast[0] < emaMedium[0] && emaMedium[0] < emaSlow[0]);
    
    if(!emaBullish && !emaBearish) 
    {
        IndicatorRelease(emaFastHandle);
        IndicatorRelease(emaMediumHandle);
        IndicatorRelease(emaSlowHandle);
        return false;
    }
    
    // üî• ‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ï‡∏≤‡∏° Market Regime
    switch(regime)
    {
        case MARKET_REGIME_TRENDING_STRONG:
            // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏±‡∏ô‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î
            if(!CheckStrongTrendConditions(emaFast[0], emaFastPrev[0], symbol))
            {
                IndicatorRelease(emaFastHandle);
                IndicatorRelease(emaMediumHandle);
                IndicatorRelease(emaSlowHandle);
                return false;
            }
            break;
            
        case MARKET_REGIME_TRENDING_WEAK:
            // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏≠‡πà‡∏≠‡∏ô ‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏±‡∏ô‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤
            if(!CheckWeakTrendConditions(emaFast[0], emaFastPrev[0], symbol))
            {
                IndicatorRelease(emaFastHandle);
                IndicatorRelease(emaMediumHandle);
                IndicatorRelease(emaSlowHandle);
                return false;
            }
            break;
            
        case MARKET_REGIME_RANGING_CALM:
        case MARKET_REGIME_RANGING_VOLATILE:
            // ‡πÉ‡∏ô sideways market ‡πÑ‡∏°‡πà‡∏Ñ‡∏ß‡∏£‡πÉ‡∏ä‡πâ trend strategy
            IndicatorRelease(emaFastHandle);
            IndicatorRelease(emaMediumHandle);
            IndicatorRelease(emaSlowHandle);
            return false;
            break;
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö breakout ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
            if(!CheckBreakoutTrendConditions(emaFast[0], emaMedium[0], emaSlow[0], emaFastPrev[0], symbol))
            {
                IndicatorRelease(emaFastHandle);
                IndicatorRelease(emaMediumHandle);
                IndicatorRelease(emaSlowHandle);
                return false;
            }
            break;
            
        case MARKET_REGIME_NORMAL:
        default:
            // ‡∏™‡∏†‡∏≤‡∏û‡∏õ‡∏Å‡∏ï‡∏¥ ‡πÉ‡∏ä‡πâ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô
            if(!CheckNormalTrendConditions(emaFast[0], emaFastPrev[0], symbol))
            {
                IndicatorRelease(emaFastHandle);
                IndicatorRelease(emaMediumHandle);
                IndicatorRelease(emaSlowHandle);
                return false;
            }
            break;
    }
    
    // ‡∏Ñ‡∏∑‡∏ô resource
    IndicatorRelease(emaFastHandle);
    IndicatorRelease(emaMediumHandle);
    IndicatorRelease(emaSlowHandle);
    
    return true;
}
// üî• ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Helper ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ï‡πà‡∏≤‡∏á‡πÜ
bool CheckStrongTrendConditions(double emaFast, double emaFastPrev, string symbol)
{
    double point;
    if(!SymbolInfoDouble(symbol, SYMBOL_POINT, point)) 
    {
        point = 0.00001; // default ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö forex
    }
    
    double slope = MathAbs(emaFast - emaFastPrev) / point;
    
    // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏±‡∏ô‡∏™‡∏π‡∏á
    if(slope < 80) // ‡πÄ‡∏û‡∏¥‡πà‡∏° threshold ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö strong trend
    {
        if(EnableDebugMode) Print("Slope too low for strong trend: ", slope, " < 80");
        return false;
    }
    
    // ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ ADX ‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤ 30 ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö strong trend
    int adxHandle = iADX(symbol, PERIOD_H1, 14);
    double adxArray[1];
    
    if(CopyBuffer(adxHandle, 0, 0, 1, adxArray) > 0)
    {
        if(adxArray[0] < 30)
        {
            if(EnableDebugMode) Print("ADX too low for strong trend: ", adxArray[0], " < 30");
            IndicatorRelease(adxHandle);
            return false;
        }
    }
    
    IndicatorRelease(adxHandle);
    return true;
}

bool CheckWeakTrendConditions(double emaFast, double emaFastPrev, string symbol)
{
    double point;
    if(!SymbolInfoDouble(symbol, SYMBOL_POINT, point)) 
    {
        point = 0.00001;
    }
    
    double slope = MathAbs(emaFast - emaFastPrev) / point;
    
    // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏≠‡πà‡∏≠‡∏ô ‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏±‡∏ô‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤
    if(slope < 20) // threshold ‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤
    {
        if(EnableDebugMode) Print("Slope too low even for weak trend: ", slope, " < 20");
        return false;
    }
    
    // ADX ‡∏≠‡∏≤‡∏à‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤‡πÑ‡∏î‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö weak trend
    int adxHandle = iADX(symbol, PERIOD_H1, 14);
    double adxArray[1];
    
    if(CopyBuffer(adxHandle, 0, 0, 1, adxArray) > 0)
    {
        if(adxArray[0] < 20) // threshold ‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤
        {
            if(EnableDebugMode) Print("ADX too low: ", adxArray[0], " < 20");
            IndicatorRelease(adxHandle);
            return false;
        }
    }
    
    IndicatorRelease(adxHandle);
    return true;
}

bool CheckNormalTrendConditions(double emaFast, double emaFastPrev, string symbol)
{
    double point;
    if(!SymbolInfoDouble(symbol, SYMBOL_POINT, point)) 
    {
        point = 0.00001;
    }
    
    double slope = MathAbs(emaFast - emaFastPrev) / point;
    
    // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏†‡∏≤‡∏û‡∏õ‡∏Å‡∏ï‡∏¥ ‡πÉ‡∏ä‡πâ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Å‡∏•‡∏≤‡∏á‡πÜ
    if(slope < 50)
    {
        if(EnableDebugMode) Print("Slope too low for normal trend: ", slope, " < 50");
        return false;
    }
    
    return true;
}

bool CheckBreakoutTrendConditions(double emaFast, double emaMedium, double emaSlow, double emaFastPrev, string symbol)
{
    // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö breakout ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏ö‡∏µ‡∏ö‡∏ï‡∏±‡∏ß‡∏Ç‡∏≠‡∏á EMA
    double emaDistance1 = MathAbs(emaFast - emaMedium);
    double emaDistance2 = MathAbs(emaMedium - emaSlow);
    double emaDistance3 = MathAbs(emaFast - emaSlow);
    
    double point;
    if(!SymbolInfoDouble(symbol, SYMBOL_POINT, point)) 
    {
        point = 0.00001;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ EMA ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ö‡∏µ‡∏ö‡∏ï‡∏±‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö breakout)
    bool emaCompressed = (emaDistance1 < 100 * point && 
                          emaDistance2 < 100 * point && 
                          emaDistance3 < 150 * point);
    
    if(!emaCompressed)
    {
        #ifdef ENABLE_DEBUG_MODE
        Print("EMA not compressed for breakout potential");
        #endif
        return false;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö volatility ‡∏•‡∏î‡∏•‡∏á
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á atrHandle ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà (‡πÅ‡∏Å‡πâ‡∏à‡∏∏‡∏î error)
    int atrHandle = iATR(symbol, PERIOD_H1, 14);
    
    if(atrHandle == INVALID_HANDLE)
    {
        #ifdef ENABLE_DEBUG_MODE
        Print("Failed to create ATR indicator");
        #endif
        return false;
    }
    
    double atrArray[1];
    if(CopyBuffer(atrHandle, 0, 0, 1, atrArray) > 0)
    {
        // ‡πÉ‡∏ä‡πâ GetATRAverage ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
        double atr50 = GetATRAverage(symbol, PERIOD_H1, 14, 50);
        
        if(atrArray[0] > atr50 * 0.8) // ATR ‡πÑ‡∏°‡πà‡∏ï‡πà‡∏≥‡∏û‡∏≠
        {
            #ifdef ENABLE_DEBUG_MODE
            Print("Volatility not low enough for breakout: ", 
                  atrArray[0], " > ", atr50 * 0.8);
            #endif
            IndicatorRelease(atrHandle);
            return false;
        }
    }
    
    IndicatorRelease(atrHandle);
    return true;
}

double GetATRAverage(string symbol, ENUM_TIMEFRAMES tf, int period, int bars)
{
    int handle = iATR(symbol, tf, period);
    if(handle == INVALID_HANDLE) return 0;
    
    double atrArray[];
    ArrayResize(atrArray, bars);
    
    if(CopyBuffer(handle, 0, 0, bars, atrArray) < bars)
    {
        IndicatorRelease(handle);
        return 0;
    }
    
    IndicatorRelease(handle);
    
    double sum = 0;
    for(int i = 0; i < bars; i++)
    {
        sum += atrArray[i];
    }
    
    return sum / bars;
}

// üî• **‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç Scalp**
bool CheckScalpConditions(string symbol)
{
    // üîß **‡πÉ‡∏ä‡πâ MQL5 syntax ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö iATR**
    int atrHandle = iATR(symbol, PERIOD_M5, 14);
    double atrBuffer[1];
    
    if(CopyBuffer(atrHandle, 0, 0, 1, atrBuffer) <= 0) {
        IndicatorRelease(atrHandle);
        return false;
    }
    
    double atr = atrBuffer[0];
    
    // ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
    double currentBid;
    if(!SymbolInfoDouble(symbol, SYMBOL_BID, currentBid)) {
        IndicatorRelease(atrHandle);
        return false;
    }
    
    double atrPercent = (atr / currentBid) * 100;
    
    // ‡∏Ñ‡∏∑‡∏ô resource
    IndicatorRelease(atrHandle);
    
    // Scalp ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ volatility ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
    if(atrPercent < 0.02 || atrPercent > 0.1) {
        return false;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏ß‡∏•‡∏≤ (scalp ‡πÑ‡∏î‡πâ‡∏ú‡∏•‡πÉ‡∏ô session ‡∏´‡∏•‡∏±‡∏Å)
    MqlDateTime timeNow;
    TimeCurrent(timeNow); // üîß **‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÉ‡∏ä‡πâ TimeCurrent() ‡πÅ‡∏ö‡∏ö MQL5**
    int hour = timeNow.hour;
    
    if(hour < 8 || hour > 20) {
        return false;
    }
    
    return true;
}

// üî• **‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç Range**
bool CheckRangeConditions(string symbol)
{
    // üîß **‡πÉ‡∏ä‡πâ MQL5 syntax ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö iBands**
    int bbHandle = iBands(symbol, PERIOD_H1, 20, 0, 2, PRICE_CLOSE);
    double upperBandBuffer[1], lowerBandBuffer[1];
    
    // ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å Bollinger Bands
    if(CopyBuffer(bbHandle, 1, 0, 1, upperBandBuffer) <= 0) { // MODE_UPPER = 1
        IndicatorRelease(bbHandle);
        return false;
    }
    if(CopyBuffer(bbHandle, 2, 0, 1, lowerBandBuffer) <= 0) { // MODE_LOWER = 2
        IndicatorRelease(bbHandle);
        return false;
    }
    
    double upperBand = upperBandBuffer[0];
    double lowerBand = lowerBandBuffer[0];
    
    // ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
    double currentPrice;
    if(!SymbolInfoDouble(symbol, SYMBOL_BID, currentPrice)) {
        IndicatorRelease(bbHandle);
        return false;
    }
    
    // ‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏£‡∏≤‡∏Ñ‡∏≤‡πÉ‡∏Å‡∏•‡πâ‡∏Ç‡∏≠‡∏ö range
    double rangeMid = (upperBand + lowerBand) / 2;
    double bandWidth = upperBand - lowerBand;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ bandWidth ‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏®‡∏π‡∏ô‡∏¢‡πå
    if(bandWidth == 0) {
        IndicatorRelease(bbHandle);
        return false;
    }
    
    double distanceToMid = MathAbs(currentPrice - rangeMid) / bandWidth * 2;
    
    // ‡∏Ñ‡∏∑‡∏ô resource
    IndicatorRelease(bbHandle);
    
    if(distanceToMid < 0.6) {
        return false;
    }
    
    return true;
}

// üî• **‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç Breakout**
// ‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö regime ‡∏î‡πâ‡∏ß‡∏¢
bool CheckBreakoutConditions(string symbol, ENUM_MARKET_REGIME regime = MARKET_REGIME_NORMAL)
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö volume ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö breakout
    long currentVolume = iVolume(symbol, PERIOD_H1, 0);
    long avgVolume = (iVolume(symbol, PERIOD_H1, 1) + iVolume(symbol, PERIOD_H1, 2)) / 2;
    
    // ‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ï‡∏≤‡∏° regime
    double volumeMultiplier = 1.2; // default
    
    switch(regime)
    {
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            volumeMultiplier = 1.5; // ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ volume ‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤
            break;
        case MARKET_REGIME_TRENDING_STRONG:
            volumeMultiplier = 1.3; // volume ‡∏™‡∏π‡∏á‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á
            break;
        case MARKET_REGIME_RANGING_CALM:
            volumeMultiplier = 1.8; // ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ volume ‡∏™‡∏π‡∏á‡∏°‡∏≤‡∏Å‡πÉ‡∏ô calm range
            break;
        default:
            volumeMultiplier = 1.2;
            break;
    }
    
    if(currentVolume < avgVolume * volumeMultiplier) {
        return false;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö price breakout ‡∏î‡πâ‡∏ß‡∏¢
    double high20 = iHigh(symbol, PERIOD_H1, iHighest(symbol, PERIOD_H1, MODE_HIGH, 20, 1));
    double low20 = iLow(symbol, PERIOD_H1, iLowest(symbol, PERIOD_H1, MODE_LOW, 20, 1));
    double currentPrice = SymbolInfoDouble(symbol, SYMBOL_BID);
    
    // Breakout condition
    return (currentPrice > high20 || currentPrice < low20);
}

// üî• **‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏ó‡∏£‡∏î**
bool IsBadTradingTime()
{
    MqlDateTime timeNow;
    TimeToStruct(TimeCurrent(), timeNow);
    
    int hour = timeNow.hour;
    int dayOfWeek = timeNow.day_of_week;
    
    // ‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
    if(dayOfWeek == 0) return true; // Sunday
    if(hour < 2 || hour > 22) return true; // ‡∏Å‡∏•‡∏≤‡∏á‡∏Ñ‡∏∑‡∏ô
    
    return false;
}

//+------------------------------------------------------------------+
//| Adjust Strategy Aggression Based on Performance                 |
//+------------------------------------------------------------------+
void AdjustStrategyAggression(double progress)
{
    // Under-performing strategies get more aggressive
    // Over-performing strategies become conservative
    
    for(int i = 0; i < 5; i++) {
        double targetProgress = (strategies[i].currentProfit / strategies[i].targetProfit) * 100;
        double aggressionMultiplier = 1.0;
        
        if(targetProgress < 50) {
            // Under-performing: increase aggression
            aggressionMultiplier = 1.5;
            Print("üöÄ BOOSTING " + strategies[i].name + " (Under-performing: " + DoubleToString(targetProgress, 1) + "%)");
        }
        else if(targetProgress > 120) {
            // Over-performing: reduce aggression  
            aggressionMultiplier = 0.5;
            Print("üõë SLOWING " + strategies[i].name + " (Over-performing: " + DoubleToString(targetProgress, 1) + "%)");
        }
        
        ApplyStrategyAggression(strategies[i].name, aggressionMultiplier);
    }
}

//+------------------------------------------------------------------+
//| Apply Aggression to Specific Strategy                           |
//+------------------------------------------------------------------+
void ApplyStrategyAggression(string strategyName, double multiplier)
{
    if(strategyName == "Scalp1" && Scalp1Enabled) {
        double newMultiplier = Current_Scalp1_Lot_Multiplier * multiplier;
        Current_Scalp1_Lot_Multiplier = MathMin(newMultiplier, 2.0);
        Print("   Scalp1 Lot Multiplier adjusted to: " + DoubleToString(Current_Scalp1_Lot_Multiplier, 2));
    }
    else if(strategyName == "Scalp2" && Scalp2Enabled) {
        double newMultiplier = Current_Scalp2_LotMultiplier * multiplier;
        Current_Scalp2_LotMultiplier = MathMin(newMultiplier, 1.8);
        Print("   Scalp2 Lot Multiplier adjusted to: " + DoubleToString(Current_Scalp2_LotMultiplier, 2));
    }
    else if(strategyName == "Trend" && SimpleTrendScalpEnabled) {
        int newTP = (int)(Current_TrendScalp_TP_Points * multiplier);
        Current_TrendScalp_TP_Points = MathMax(newTP, 20);
        Print("   Trend TP Points adjusted to: " + IntegerToString(Current_TrendScalp_TP_Points));
    }
}

//+------------------------------------------------------------------+
//| Find Most Needy Strategy                                        |
//+------------------------------------------------------------------+
int FindMostNeedyStrategy()
{
    int mostNeedy = -1;
    double worstProgress = 1000;
    
    for(int i = 0; i < 5; i++) {
        if(!strategies[i].isActive) continue;
        
        if(strategies[i].progress < worstProgress) {
            worstProgress = strategies[i].progress;
            mostNeedy = i;
        }
    }
    
    return mostNeedy;
}
//+------------------------------------------------------------------+
//| Execute Global Take Profit                                      |
//+------------------------------------------------------------------+
void ExecuteGlobalTakeProfit()
{
    Print("üéâüéâüéâ GLOBAL TARGET ACHIEVED! üéâüéâüéâ");
    Print("Closing all positions: $" + DoubleToString(totalCollaborativeProfit, 2) + " profit");
    
    // Close all positions
    int closedCount = 0;
    for(int i = PositionsTotal()-1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket)) {
            if(trade.PositionClose(ticket)) {
                closedCount++;
            }
        }
    }
    
    Print("‚úÖ Closed " + IntegerToString(closedCount) + " positions");
    
    // Reset system for next round
    ResetCollaborativeSystem();
    Alert("SUCCESS! All strategies achieved target: $" + DoubleToString(totalCollaborativeProfit, 2));
}

//+------------------------------------------------------------------+
//| Reset Collaborative System                                      |
//+------------------------------------------------------------------+
void ResetCollaborativeSystem()
{
    totalCollaborativeProfit = 0;
    for(int i = 0; i < 5; i++) {
        strategies[i].currentProfit = 0;
        strategies[i].positions = 0;
        strategies[i].contribution = 0;
        strategies[i].progress = 0;
    }
    
    // ‚úÖ Reset strategy parameters to original
    Current_Scalp1_Lot_Multiplier = Original_Scalp1_Multiplier;
    Current_Scalp2_LotMultiplier = Original_Scalp2_Multiplier;
    Current_TrendScalp_TP_Points = Original_Trend_TP;
    
    Print("üîÑ Cooperative system reset - ready for next session");
}
//+------------------------------------------------------------------+
//| Display Cooperative Dashboard                                   |
//+------------------------------------------------------------------+
void DisplayCooperativeDashboard()
{
    string dashboard = "";
    dashboard += "=== ü§ù COOPERATIVE TRADING SYSTEM ===\n";
    dashboard += "Overall Progress: " + DoubleToString((totalCollaborativeProfit/collaborativeTarget)*100, 1) + "%\n";
    dashboard += "Total: $" + DoubleToString(totalCollaborativeProfit, 2) + " / $" + DoubleToString(collaborativeTarget, 2) + "\n";
    dashboard += "----------------------------------------\n";
    
    for(int i = 0; i < 5; i++) {
        string emoji = "üü¢"; // Green - on target
        double progress = (strategies[i].currentProfit / strategies[i].targetProfit) * 100;
        
        if(progress < 50) emoji = "üî¥"; // Red - behind
        else if(progress < 80) emoji = "üü°"; // Yellow - catching up
        else if(progress >= 100) emoji = "‚úÖ"; // Check - target achieved
        
        dashboard += emoji + " " + strategies[i].name + ": " + 
                    DoubleToString(progress, 1) + "% (" + 
                    DoubleToString(strategies[i].contribution, 1) + "% contrib)\n";
    }
    
    Comment(dashboard);
}
//+------------------------------------------------------------------+
//| Get Progress Bar                                                |
//+------------------------------------------------------------------+
string GetStrategyStatusIcon(double progress)
{
    if(progress >= 100) return "‚úÖ";
    else if(progress >= 80) return "üü¢";
    else if(progress >= 50) return "üü°";  
    else return "üî¥";
}



//+------------------------------------------------------------------+
//| Get Progress Bar                                                |
//+------------------------------------------------------------------+
string GetProgressBar(double progress, int length)
{
    string bar = "[";
    int filled = (int)((progress / 100.0) * length);
    
    for(int i = 0; i < length; i++) {
        if(i < filled) bar += "‚ñà";
        else bar += "‚ñë";
    }
    bar += "]";
    
    return bar;
}

//+------------------------------------------------------------------+
//| Calculate Market Condition Score                               |
//+------------------------------------------------------------------+
int CalculateMarketConditionScore()
{
    int score = 50; // Base score
    
    // 1. Volatility Score (0-20 points)
    double atrPercent = (GetATRValue(_Symbol, PERIOD_H1, 14) / SymbolInfoDouble(_Symbol, SYMBOL_BID)) * 100;
    if(atrPercent > 0.08 && atrPercent < 0.15) {
        score += 15; // Ideal volatility
    } else if(atrPercent > 0.05 && atrPercent < 0.2) {
        score += 10; // Good volatility
    } else if(atrPercent > 0.03 && atrPercent < 0.25) {
        score += 5; // Acceptable volatility
    }
    
    // 2. Trend Strength Score (0-20 points)
    double trendStrengthH1 = CalculateTrendStrengthOnTimeframe(PERIOD_H1);
    double trendStrengthH4 = CalculateTrendStrengthOnTimeframe(PERIOD_H4);
    
    if(trendStrengthH1 > 0.7 && trendStrengthH4 > 0.7) {
        score += 15; // Strong trend
    } else if(trendStrengthH1 > 0.5 || trendStrengthH4 > 0.5) {
        score += 10; // Moderate trend
    } else if(trendStrengthH1 < 0.3 && trendStrengthH4 < 0.3) {
        score += 5; // Weak trend/ranging
    }
    
    // 3. Session Quality Score (0-15 points)
    string session = GetTradingSession();
    if(session == "LONDON_NY_OVERLAP") {
        score += 15;
    } else if(session == "LONDON" || session == "NY") {
        score += 10;
    } else if(session == "ASIA") {
        score += 5;
    }
    
    // 4. Risk Condition Score (0-15 points)
    double riskPressure = CalculateRiskPressure();
    if(riskPressure < 0.3) {
        score += 15; // Low risk
    } else if(riskPressure < 0.6) {
        score += 10; // Moderate risk
    } else if(riskPressure < 0.8) {
        score += 5; // High risk
    }
    
    // 5. Signal Clarity Score (0-10 points)
    int clearSignals = 0;
    if(HasClearScalpSignal()) clearSignals++;
    if(HasClearTrendSignal()) clearSignals++;
    if(HasClearBreakoutSignal()) clearSignals++;
    
    if(clearSignals >= 2) {
        score += 10;
    } else if(clearSignals == 1) {
        score += 5;
    }
    
    return MathMin(score, 100); // Cap at 100
}
// üìç ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ï‡∏•‡∏≤‡∏î‡πÅ‡∏ö‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏•‡πÑ‡∏ó‡∏°‡πå
void CheckMarketConditionsRealTime()
{
   if(TimeCurrent() - lastMarketConditionCheck < 300) return; // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏∏‡∏Å 5 ‡∏ô‡∏≤‡∏ó‡∏µ
   
   ENUM_MARKET_REGIME newRegime = DetectMarketRegime();
   int newScore = CalculateMarketConditionScore();
   
   // ‡∏ñ‡πâ‡∏≤‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÑ‡∏õ
   if(newRegime != currentMarketRegime || MathAbs(newScore - marketConditionScore) > 20) {
      Print("üîÑ MARKET REGIME CHANGED: " + GetRegimeName(currentMarketRegime) + 
            " ‚Üí " + GetRegimeName(newRegime) + " | Score: " + IntegerToString(marketConditionScore) +
            " ‚Üí " + IntegerToString(newScore));
      
      currentMarketRegime = newRegime;
      marketConditionScore = newScore;
      
      // ‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏ú‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î‡∏ï‡∏≤‡∏°‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î‡πÉ‡∏´‡∏°‡πà
      AdjustTradingPlanForNewRegime(newRegime);
   }
   
   lastMarketConditionCheck = TimeCurrent();
}

//+------------------------------------------------------------------+
//| Adjust Trading Plan For New Regime                              |
//+------------------------------------------------------------------+
void AdjustTradingPlanForNewRegime(ENUM_MARKET_REGIME newRegime)
{
    Print("üîÑ ADJUSTING TRADING PLAN FOR: " + GetRegimeName(newRegime));
    
    switch(newRegime) {
        case MARKET_REGIME_TRENDING_STRONG:
            // ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á ‚Üí ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏ó‡∏£‡∏î‡πÉ‡∏ô‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå
            Current_TrendScalp_TP_Points = (int)(Original_Trend_TP * 1.3);
            Print("   üìà Trend TP increased to: " + IntegerToString(Current_TrendScalp_TP_Points));
            break;
            
        case MARKET_REGIME_TRENDING_WEAK:
            // ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏≠‡πà‡∏≠‡∏ô ‚Üí ‡∏•‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏ó‡∏£‡∏î
            Current_Scalp1_Lot_Multiplier = Original_Scalp1_Multiplier * 0.7;
            Print("   üìâ Scalp1 lot reduced to: " + DoubleToString(Current_Scalp1_Lot_Multiplier, 2));
            break;
            
        case MARKET_REGIME_RANGING_VOLATILE:
            // ‡πÑ‡∏ã‡∏î‡πå‡πÄ‡∏ß‡∏¢‡πå‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô ‚Üí ‡πÄ‡∏ô‡πâ‡∏ô Scalp
            Current_Scalp1_Lot_Multiplier = Original_Scalp1_Multiplier * 1.2;
            Print("   üîÑ Scalp1 lot increased for volatile range: " + DoubleToString(Current_Scalp1_Lot_Multiplier, 2));
            break;
            
        case MARKET_REGIME_RANGING_CALM:
            // ‡πÑ‡∏ã‡∏î‡πå‡πÄ‡∏ß‡∏¢‡πå‡πÄ‡∏á‡∏µ‡∏¢‡∏ö ‚Üí ‡∏•‡∏î‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°
            Current_Scalp1_Lot_Multiplier = Original_Scalp1_Multiplier * 0.5;
            Print("   üò¥ Reduced activity for calm range");
            break;
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            // ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡πÄ‡∏ö‡∏£‡∏Å‡πÄ‡∏≠‡πâ‡∏≤‡∏ó‡πå ‚Üí ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå Breakout
            Print("   üöÄ Preparing for potential breakout");
            break;
            
        case MARKET_REGIME_NORMAL:
            // ‡πÇ‡∏´‡∏°‡∏î‡∏õ‡∏Å‡∏ï‡∏¥ ‚Üí ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏õ‡∏Å‡∏ï‡∏¥
            Current_TrendScalp_TP_Points = Original_Trend_TP;
            Current_Scalp1_Lot_Multiplier = Original_Scalp1_Multiplier;
            Print("   üìä Normal market - using standard settings");
            break;
    }
    
    // üî• ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ó‡∏µ‡∏°‡∏ï‡∏≤‡∏°‡πÅ‡∏ú‡∏ô‡πÉ‡∏´‡∏°‡πà
    UpdateTeamMissions();
}
//+------------------------------------------------------------------+/
//| Enable Aggressive Recovery - ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Recovery ‡πÅ‡∏ö‡∏ö Aggressive|
//+------------------------------------------------------------------+
void EnableAggressiveRecovery(bool enable)
{
    if(enable) {
        currentRecoveryMultiplier = 1.8;
        currentMaxRecovery = 6;
        Print("   üí™ AGGRESSIVE RECOVERY ENABLED");
    } else {
        currentRecoveryMultiplier = 1.5;
        currentMaxRecovery = 4;
        Print("   üí™ AGGRESSIVE RECOVERY DISABLED");
    }
}

//+------------------------------------------------------------------+
//| Enable Conservative Recovery - ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Recovery ‡πÅ‡∏ö‡∏ö‡∏£‡∏∞‡∏°‡∏±‡∏î‡∏£‡∏∞‡∏ß‡∏±‡∏á|
//+------------------------------------------------------------------+
void EnableConservativeRecovery(bool enable)
{
   //double currentRecoveryMultiplier = localRecoveryMultiplier;
   //int currentMaxRecovery = localMaxRecovery;
    if(enable) {
        currentRecoveryMultiplier = 1.2;
        currentMaxRecovery = 3;
        Print("   üõ°Ô∏è CONSERVATIVE RECOVERY: Multiplier=" + DoubleToString(currentRecoveryMultiplier, 1) + 
              ", Max Steps=" + IntegerToString(currentMaxRecovery));
    } else {
        currentRecoveryMultiplier = localRecoveryMultiplier;
        currentMaxRecovery = localMaxRecovery;
    }
}
double CalculateTemporaryTP(ulong ticket)
{
    if(PositionSelectByTicket(ticket)) {
        double entryPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        double currentPrice = PositionGetDouble(POSITION_PRICE_CURRENT);
        long positionType = PositionGetInteger(POSITION_TYPE);  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å int ‡πÄ‡∏õ‡πá‡∏ô long
        
        if(positionType == POSITION_TYPE_BUY) {
            // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Long: TP = Entry + ‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
            return entryPrice + 0.0005;  // ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡∏™‡∏Å‡∏∏‡∏•‡πÄ‡∏á‡∏¥‡∏ô
        } else if(positionType == POSITION_TYPE_SELL) {  // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö SELL
            // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Short: TP = Entry - ‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢  
            return entryPrice - 0.0005;  // ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡∏™‡∏Å‡∏∏‡∏•‡πÄ‡∏á‡∏¥‡∏ô
        }
    }
    return 0;
}
//+------------------------------------------------------------------+
//| Set Temporary Breakeven TPs - ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ TP ‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß            |
//+------------------------------------------------------------------+
void SetTemporaryBreakevenTPs()
{
    int modifiedCount = 0;
    
    for(int i = 0; i < PositionsTotal(); i++) {
        g_currentTicket = PositionGetTicket(i);  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô ticket ‡πÄ‡∏õ‡πá‡∏ô g_currentTicket
        if(PositionSelectByTicket(g_currentTicket)) {  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô ticket ‡πÄ‡∏õ‡πá‡∏ô g_currentTicket
            double profit = PositionGetDouble(POSITION_PROFIT);
            double currentTP = PositionGetDouble(POSITION_TP);
            
            // ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ TP ‡πÅ‡∏•‡∏∞‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏ô‡πâ‡∏≠‡∏¢
            if(currentTP == 0 && profit > -5 && profit < 2) {
                // ‡∏ï‡∏±‡πâ‡∏á TP ‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß‡∏ó‡∏µ‡πà Breakeven + ‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
                double newTP = CalculateTemporaryTP(g_currentTicket);  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô ticket ‡πÄ‡∏õ‡πá‡∏ô g_currentTicket
                if(trade.PositionModify(g_currentTicket, 0, newTP)) {  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô ticket ‡πÄ‡∏õ‡πá‡∏ô g_currentTicket
                    modifiedCount++;
                }
            }
        }
    }
    
    if(modifiedCount > 0) {
        Print("   ‚úÖ Set temporary TP for " + IntegerToString(modifiedCount) + " positions");
    }
}
//+------------------------------------------------------------------+
//| Update Team Missions - ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏†‡∏≤‡∏£‡∏Å‡∏¥‡∏à‡∏ó‡∏µ‡∏°                       |
//+------------------------------------------------------------------+
void UpdateTradingTeamMissions()
{
    // ‡πÉ‡∏™‡πà logic ‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó Trading Teams ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà
    if(EnableDebugMode) Print("   üìä Updating Trading Team Missions");
}

void UpdateRecoveryTeamMissions()
{
    // ‡πÉ‡∏™‡πà logic ‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó Recovery Teams ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà
    if(EnableDebugMode) Print("   üîÑ Updating Recovery Team Missions");
}

void UpdateSpecialTeamMissions() 
{
    // ‡πÉ‡∏™‡πà logic ‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó Special Teams ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà
    if(EnableDebugMode) Print("   ‚≠ê Updating Special Team Missions");
}
void UpdateTeamMissions()
{
    Print("üë®‚ÄçüöÄ UPDATING TEAM MISSIONS:");
    
    // 1. ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó Trading Teams
    UpdateTradingTeamMissions();
    
    // 2. ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó Recovery Teams  
    UpdateRecoveryTeamMissions();
    
    // 3. ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó Special Teams
    UpdateSpecialTeamMissions();
}
//+------------------------------------------------------------------+
//| Analyze Current Momentum - ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÇ‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡∏±‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏ù‡∏±‡πà‡∏á       |
//+------------------------------------------------------------------+
// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ
void UpdateMomentumHistory(double momentum)
{
    if(EnableDebugMode) 
        Print("   üìà Momentum history updated: " + DoubleToString(momentum, 2));
}
double CalculateBuyPositionsProfit()
{
    double profit = 0;
    for(int i = 0; i < PositionsTotal(); i++) {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket) && PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY) {
            profit += PositionGetDouble(POSITION_PROFIT);
        }
    }
    return profit;
}
bool IsBullishSignal()
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö RSI < 30 (Oversold)
    double rsi = iRSI(_Symbol, PERIOD_M5, 14, PRICE_CLOSE, 0);
    if(rsi != 0 && rsi < 30) return true;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Price > EMA (‡πÉ‡∏ä‡πâ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á)
    double ema[];
    ArraySetAsSeries(ema, true);
    if(CopyBuffer(iMA(_Symbol, PERIOD_M5, 20, 0, MODE_EMA, PRICE_CLOSE), 0, 0, 1, ema) > 0) {
        double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
        if(price > ema[0]) return true;
    }
    
    return false;
}

bool IsBearishSignal()
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö RSI > 70 (Overbought)
    double rsi = iRSI(_Symbol, PERIOD_M5, 14, PRICE_CLOSE, 0);
    if(rsi != 0 && rsi > 70) return true;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Price < EMA (‡πÉ‡∏ä‡πâ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á)
    double ema[];
    ArraySetAsSeries(ema, true);
    if(CopyBuffer(iMA(_Symbol, PERIOD_M5, 20, 0, MODE_EMA, PRICE_CLOSE), 0, 0, 1, ema) > 0) {
        double price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
        if(price < ema[0]) return true;
    }
    
    return false;
}

bool IsBuyVolumeIncreasing()
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Volume ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô > Volume ‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤
    long currentVolume = iVolume(_Symbol, PERIOD_M5, 0);
    long prevVolume = iVolume(_Symbol, PERIOD_M5, 1);
    return currentVolume > prevVolume;
}

bool IsSellVolumeIncreasing()
{
    // ‡πÉ‡∏ä‡πâ logic ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏Å‡∏±‡∏ö Buy Volume
    return IsBuyVolumeIncreasing(); // ‡∏´‡∏£‡∏∑‡∏≠‡∏õ‡∏£‡∏±‡∏ö logic ‡πÉ‡∏´‡πâ‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á‡πÑ‡∏î‡πâ
}
double CalculateBuyMomentum()
{
    double momentum = 0;
    
    // 1. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå Buy
    int buyPositions = CountPositionsByType(POSITION_TYPE_BUY);
    momentum += buyPositions * 5;
    
    // 2. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≥‡πÑ‡∏£/‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏ù‡∏±‡πà‡∏á Buy
    double buyProfit = CalculateBuyPositionsProfit();
    if(buyProfit > 0) momentum += 10;
    else if(buyProfit < -20) momentum -= 15;
    
    // 3. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡∏ù‡∏±‡πà‡∏á Buy
    if(IsBullishSignal()) momentum += 20;
    
    // 4. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Volume ‡∏Ç‡∏≤‡∏Ç‡∏∂‡πâ‡∏ô
    if(IsBuyVolumeIncreasing()) momentum += 15;
    
    return MathMax(momentum, 0);
}

double CalculateSellMomentum()
{
    double momentum = 0;
    
    // 1. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå Sell
    int sellPositions = CountPositionsByType(POSITION_TYPE_SELL);
    momentum += sellPositions * 5;
    
    // 2. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≥‡πÑ‡∏£/‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏ù‡∏±‡πà‡∏á Sell
    double sellProfit = CalculateSellPositionsProfit();
    if(sellProfit > 0) momentum += 10;
    else if(sellProfit < -20) momentum -= 15;
    
    // 3. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡∏ù‡∏±‡πà‡∏á Sell
    if(IsBearishSignal()) momentum += 20;
    
    // 4. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Volume ‡∏Ç‡∏≤‡∏•‡∏á
    if(IsSellVolumeIncreasing()) momentum += 15;
    
    return MathMax(momentum, 0);
}

void AnalyzeCurrentMomentum()
{
    double buyMomentum = CalculateBuyMomentum();
    double sellMomentum = CalculateSellMomentum();
    g_netMomentum = buyMomentum - sellMomentum;
    
    Print("üìä MOMENTUM ANALYSIS:");
    Print("   BUY Momentum: " + DoubleToString(buyMomentum, 2));
    Print("   SELL Momentum: " + DoubleToString(sellMomentum, 2));
    Print("   NET Momentum: " + DoubleToString(g_netMomentum, 2));
    
    // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ñ‡πà‡∏≤‡πÇ‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡∏±‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÉ‡∏ä‡πâ‡πÉ‡∏ô Recovery
    UpdateMomentumHistory(g_netMomentum);
}



//+------------------------------------------------------------------+
//| Plan Breakeven Strategy - ‡∏ß‡∏≤‡∏á‡πÅ‡∏ú‡∏ô‡∏à‡∏∏‡∏î Breakeven                  |
//+------------------------------------------------------------------+
void PlanBreakevenStrategy()
{
    Print("üéØ BREAKEVEN STRATEGY PLANNING:");
    
    // 1. ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏∏‡∏î Breakeven ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ù‡∏±‡πà‡∏á
    double buyBreakeven = CalculateBreakevenForSide(POSITION_TYPE_BUY);
    double sellBreakeven = CalculateBreakevenForSide(POSITION_TYPE_SELL);
    
    Print("   BUY Breakeven Target: " + DoubleToString(buyBreakeven, 5));
    Print("   SELL Breakeven Target: " + DoubleToString(sellBreakeven, 5));
    
    // 2. ‡∏ß‡∏≤‡∏á‡πÅ‡∏ú‡∏ô Recovery ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ù‡∏±‡πà‡∏á‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô
    if(buyBreakeven > 0) PlanRecoveryForBuySide(buyBreakeven);
    if(sellBreakeven > 0) PlanRecoveryForSellSide(sellBreakeven);
    
    // 3. ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ TP ‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß‡πÄ‡∏û‡∏∑‡πà‡∏≠ Breakeven
    SetTemporaryBreakevenTPs();
}
//+------------------------------------------------------------------+
//| Calculate Breakeven For Side - ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏∏‡∏î Breakeven ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ù‡∏±‡πà‡∏á   |
//+------------------------------------------------------------------+
double CalculateBreakevenForSide(ENUM_POSITION_TYPE side)
{
    double totalVolume = 0;
    double totalCost = 0;
    int positionCount = 0;
    
    for(int i = 0; i < PositionsTotal(); i++) {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket)) {
            if(PositionGetInteger(POSITION_TYPE) == side) {
                double volume = PositionGetDouble(POSITION_VOLUME);
                double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
                
                totalVolume += volume;
                totalCost += volume * openPrice;
                positionCount++;
            }
        }
    }
    
    if(totalVolume <= 0) return 0;
    
    double breakevenPrice = totalCost / totalVolume;
    
    // ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° Spread ‡πÅ‡∏•‡∏∞ Commission
    double spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) * _Point;
    if(side == POSITION_TYPE_BUY) {
        breakevenPrice += spread * 1.5; // ‡πÄ‡∏û‡∏¥‡πà‡∏° buffer
    } else {
        breakevenPrice -= spread * 1.5;
    }
    
    Print("   " + (side == POSITION_TYPE_BUY ? "BUY" : "SELL") + 
          " Side: " + IntegerToString(positionCount) + " positions" +
          " | Breakeven: " + DoubleToString(breakevenPrice, 5));
    
    return breakevenPrice;
}
double GetNetMomentum()
{
    return g_netMomentum; // ‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å AnalyzeCurrentMomentum()
}
//+------------------------------------------------------------------+
//| Execute Trending Strong Plan - ‡πÅ‡∏ú‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á                   |
//+------------------------------------------------------------------+
void ExecuteTrendingStrongPlan()
{
    Print("üìà EXECUTING TRENDING STRONG PLAN");
    
    // 1. ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå
    Current_TrendScalp_TP_Points = (int)(Original_Trend_TP * 1.3);
    
    // 2. ‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡∏ó‡∏µ‡∏°‡∏ï‡∏≤‡∏°‡πÇ‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡∏±‡∏°
    double netMomentum = GetNetMomentum();
    if(netMomentum > 10) {
        // ‡πÇ‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡∏±‡∏°‡∏ö‡∏ß‡∏Å ‚Üí ‡πÄ‡∏ô‡πâ‡∏ô‡∏ó‡∏µ‡∏° Buy
        AssignTeamWeights(60, 20, 10, 5, 5); // TREND:60%, BREAKOUT:20%, etc.
        Print("   üü¢ Momentum Positive - Focusing on BUY teams");
    } else if(netMomentum < -10) {
        // ‡πÇ‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡∏±‡∏°‡∏•‡∏ö ‚Üí ‡πÄ‡∏ô‡πâ‡∏ô‡∏ó‡∏µ‡∏° Sell  
        AssignTeamWeights(20, 60, 10, 5, 5);
        Print("   üî¥ Momentum Negative - Focusing on SELL teams");
    } else {
        // ‡πÇ‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡∏±‡∏°‡∏™‡∏°‡∏î‡∏∏‡∏• ‚Üí ‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡πÄ‡∏ó‡πà‡∏≤‡πÜ ‡∏Å‡∏±‡∏ô
        AssignTeamWeights(40, 40, 10, 5, 5);
        Print("   ‚öñÔ∏è Balanced Momentum - Equal team distribution");
    }
    
    // 3. ‡πÄ‡∏õ‡∏¥‡∏î‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô‡πÅ‡∏ï‡πà‡∏°‡∏µ Recovery Plan
    EnableAggressiveRecovery(true);
}
//+------------------------------------------------------------------+
//| Execute Trending Weak Plan - ‡πÅ‡∏ú‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏≠‡πà‡∏≠‡∏ô                    |
//+------------------------------------------------------------------+
void ExecuteTrendingWeakPlan()
{
    Print("üìâ EXECUTING TRENDING WEAK PLAN");
    
    // ‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡πà‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≠‡∏á‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå‡∏Å‡∏ß‡πà‡∏≤
    Current_Scalp1_Lot_Multiplier = Original_Scalp1_Multiplier * 0.7;
    Current_Scalp2_LotMultiplier = Original_Scalp2_Multiplier * 0.8;
    
    AssignTeamWeights(25, 25, 30, 10, 10);
    
    EnableConservativeRecovery(true);
    
    Print("   üõ°Ô∏è Conservative approach with balanced teams");
    Print("   üí∞ Reduced lot sizes for risk management");
}

//+------------------------------------------------------------------+
//| Execute Ranging Volatile Plan - ‡πÅ‡∏ú‡∏ô‡πÑ‡∏ã‡∏î‡πå‡πÄ‡∏ß‡∏¢‡πå‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô            |
//+------------------------------------------------------------------+
void EnableQuickRecovery(bool enable)
{
    // ‡∏•‡∏ö‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏°‡∏µ global variables ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß:
    // double currentRecoveryMultiplier = localRecoveryMultiplier;
    // int currentMaxRecovery = localMaxRecovery;
    // bool currentCounterPosition = EnableCounterPosition;

    if(enable) {
        Print("   ‚ö° QUICK RECOVERY ENABLED");
        currentRecoveryMultiplier = 1.8;  // ‡πÉ‡∏ä‡πâ global variable
        currentMaxRecovery = 6;           // ‡πÉ‡∏ä‡πâ global variable
    } else {
        Print("   ‚ö° QUICK RECOVERY DISABLED");
        currentRecoveryMultiplier = localRecoveryMultiplier;  // ‡πÉ‡∏ä‡πâ global variable
        currentMaxRecovery = localMaxRecovery;                // ‡πÉ‡∏ä‡πâ global variable
    }
}

void EnableCounterPositionMode(bool enable)
{
    currentEnableCounterPosition = enable;
    if(enable) {
        Print("   üîÑ COUNTER POSITION: ENABLED");
        // ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏° logic ‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏¥‡∏î‡πÇ‡∏´‡∏°‡∏î‡πÑ‡∏î‡πâ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà
    } else {
        Print("   üîÑ COUNTER POSITION: DISABLED");
        // ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏° logic ‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏õ‡∏¥‡∏î‡πÇ‡∏´‡∏°‡∏î‡πÑ‡∏î‡πâ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà
    }
}

void SetCounterPosition(bool enable)
{
    g_EnableCounterPosition = enable;
    Print("   üîÑ COUNTER POSITION: " + string(enable ? "ENABLED" : "DISABLED"));
}


//+------------------------------------------------------------------+
//| Execute Ranging Calm Plan - ‡πÅ‡∏ú‡∏ô‡πÑ‡∏ã‡∏î‡πå‡πÄ‡∏ß‡∏¢‡πå‡πÄ‡∏á‡∏µ‡∏¢‡∏ö                 |
//+------------------------------------------------------------------+
void EnablePassiveRecovery(bool enable)
{
    if(enable) {
        currentRecoveryMultiplier = 1.1;  // ‡∏Ñ‡πà‡∏≤ recovery ‡∏ï‡πà‡∏≥
        currentMaxRecovery = 2;           // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥
        Print("   üò¥ PASSIVE RECOVERY: Multiplier=" + DoubleToString(currentRecoveryMultiplier, 1) + 
              ", Max Steps=" + IntegerToString(currentMaxRecovery));
    } else {
        currentRecoveryMultiplier = localRecoveryMultiplier;
        currentMaxRecovery = localMaxRecovery;
        Print("   üò¥ PASSIVE RECOVERY DISABLED");
    }
}
void ExecuteRangingCalmPlan()
{
    Print("üò¥ EXECUTING RANGING CALM PLAN");
    
    // 1. ‡∏•‡∏î‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    Current_Scalp1_Lot_Multiplier = Original_Scalp1_Multiplier * 0.5;
    
    // 2. ‡πÄ‡∏ô‡πâ‡∏ô‡∏ó‡∏µ‡∏° Breakout ‡πÅ‡∏•‡∏∞ Trend (‡∏£‡∏≠‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì)
    AssignTeamWeights(30, 30, 10, 20, 10);
    
    // 3. Recovery ‡πÅ‡∏ö‡∏ö passive
    EnablePassiveRecovery(true);
    
    Print("   üí§ Reduced activity - waiting for signals");
}
//+------------------------------------------------------------------+
//| Execute Breakout Potential Plan - ‡πÅ‡∏ú‡∏ô‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡πÄ‡∏ö‡∏£‡∏Å‡πÄ‡∏≠‡πâ‡∏≤‡∏ó‡πå         |
//+------------------------------------------------------------------+
void ExecuteBreakoutPotentialPlan()
{
    Print("üöÄ EXECUTING BREAKOUT POTENTIAL PLAN");
    
    // 1. ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏ó‡∏µ‡∏° Breakout
    AssignTeamWeights(20, 20, 15, 15, 30); // BREAKOUT:30%
    
    // 2. ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ TP ‡∏ó‡∏µ‡πà aggressive
    Current_TrendScalp_TP_Points = (int)(Original_Trend_TP * 1.5);
    
    // 3. Recovery ‡πÅ‡∏ö‡∏ö‡∏£‡∏≠‡πÇ‡∏≠‡∏Å‡∏≤‡∏™
    EnableOpportunisticRecovery(true);
    
    Print("   üéØ Breakout teams ready - aggressive TP settings");
}
void EnableOpportunisticRecovery(bool enable)
{
    if(enable) {
        Print("   üéØ OPPORTUNISTIC RECOVERY ENABLED");
        // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Opportunistic Recovery
    } else {
        Print("   üéØ OPPORTUNISTIC RECOVERY DISABLED");
    }
}
//+------------------------------------------------------------------+
//| Assign Team Weights - ‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡∏ó‡∏µ‡∏°                        |
//+------------------------------------------------------------------+
void AssignTeamWeights(int trendWeight, int breakoutWeight, int scalp1Weight, int scalp2Weight, int scalp3Weight)
{
    Print("   üë• ASSIGNING TEAM WEIGHTS:");
    Print("   Trend: " + IntegerToString(trendWeight) + "%");
    Print("   Breakout: " + IntegerToString(breakoutWeight) + "%");
    Print("   Scalp1: " + IntegerToString(scalp1Weight) + "%");
    Print("   Scalp2: " + IntegerToString(scalp2Weight) + "%");
    Print("   Scalp3: " + IntegerToString(scalp3Weight) + "%");
    
    // TODO: ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ñ‡πà‡∏≤‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡∏à‡∏£‡∏¥‡∏á‡πÑ‡∏î‡πâ
}
void AdjustStrategyWeights(double scalp1, double scalp2, double scalp3, double trend, double breakout)
{
    currentStrategyWeight_Scalp1   = scalp1;
    currentStrategyWeight_Scalp2   = scalp2;
    currentStrategyWeight_Scalp3   = scalp3;
    currentStrategyWeight_Trend    = trend;
    currentStrategyWeight_Breakout = breakout;
    
    Print("   ‚öôÔ∏è STRATEGY WEIGHTS UPDATED:");
    Print("   Scalp1: " + DoubleToString(currentStrategyWeight_Scalp1, 2));
    Print("   Scalp2: " + DoubleToString(currentStrategyWeight_Scalp2, 2));
    Print("   Scalp3: " + DoubleToString(currentStrategyWeight_Scalp3, 2));
    Print("   Trend: " + DoubleToString(currentStrategyWeight_Trend, 2));
    Print("   Breakout: " + DoubleToString(currentStrategyWeight_Breakout, 2));
}
void EnableCooperativeMode(bool enable)
{
    currentEnableCooperativeSystem = enable;
    Print("   ü§ù COOPERATIVE SYSTEM: " + string(enable ? "ENABLED" : "DISABLED"));
}
//+------------------------------------------------------------------+
//| Plan Recovery For Buy Side - ‡∏ß‡∏≤‡∏á‡πÅ‡∏ú‡∏ô Recovery ‡∏ù‡∏±‡πà‡∏á Buy         |
//+------------------------------------------------------------------+
void PlanRecoveryForBuySide(double breakevenPrice)
{
 

    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    if(currentPrice < breakevenPrice) {
        Print("   üÜò BUY SIDE RECOVERY NEEDED:");
        Print("      Current: " + DoubleToString(currentPrice, 5) + 
              " | Target: " + DoubleToString(breakevenPrice, 5) +
              " | Distance: " + DoubleToString((breakevenPrice - currentPrice) / GetPipSize(_Symbol), 1) + " pips");
        
        // ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Recovery Teams
        currentEnableIndividualRecovery = true;
         currentStepUpRecoveryEnabled = true;
        
        // ‡∏°‡∏≠‡∏ö‡∏´‡∏°‡∏≤‡∏¢‡πÉ‡∏´‡πâ‡∏ó‡∏µ‡∏° Recovery
        AssignRecoveryMission("BUY_RECOVERY", breakevenPrice);
    }
}

//+------------------------------------------------------------------+
//| Plan Recovery For Sell Side - ‡∏ß‡∏≤‡∏á‡πÅ‡∏ú‡∏ô Recovery ‡∏ù‡∏±‡πà‡∏á Sell       |
//+------------------------------------------------------------------+
void PlanRecoveryForSellSide(double breakevenPrice)
{
      
      
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    
    if(currentPrice > breakevenPrice) {
        Print("   üÜò SELL SIDE RECOVERY NEEDED:");
        Print("      Current: " + DoubleToString(currentPrice, 5) + 
              " | Target: " + DoubleToString(breakevenPrice, 5) +
              " | Distance: " + DoubleToString((currentPrice - breakevenPrice) / GetPipSize(_Symbol), 1) + " pips");
        
        // ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Recovery Teams
        currentEnableIndividualRecovery = true;
         currentStepUpRecoveryEnabled = true;
        
        // ‡∏°‡∏≠‡∏ö‡∏´‡∏°‡∏≤‡∏¢‡πÉ‡∏´‡πâ‡∏ó‡∏µ‡∏° Recovery
        AssignRecoveryMission("SELL_RECOVERY", breakevenPrice);
    }
}

//+------------------------------------------------------------------+
//| Assign Recovery Mission - ‡∏°‡∏≠‡∏ö‡∏´‡∏°‡∏≤‡∏¢‡∏†‡∏≤‡∏£‡∏Å‡∏¥‡∏à‡πÉ‡∏´‡πâ‡∏ó‡∏µ‡∏° Recovery      |
//+------------------------------------------------------------------+
void AssignRecoveryMission(string side, double targetPrice)
{
    string localMissionId = side + "_" + IntegerToString((int)TimeCurrent());  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ä‡∏∑‡πà‡∏≠ local
    
    Print("   üéØ RECOVERY MISSION: " + localMissionId);
    Print("      Target Price: " + DoubleToString(targetPrice, 5));
    Print("      Assigned Teams: INDIVIDUAL_RECOVERY_TEAM, STEPUP_RECOVERY_TEAM");
    
    // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏†‡∏≤‡∏£‡∏Å‡∏¥‡∏à Recovery
    SaveRecoveryMission(localMissionId, side, targetPrice);  // ‡πÉ‡∏ä‡πâ‡∏ä‡∏∑‡πà‡∏≠‡πÉ‡∏´‡∏°‡πà
}
void SaveRecoveryMission(string missionIdParam, string side, double targetPrice)  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ä‡∏∑‡πà‡∏≠ parameter
{
    if(EnableDebugMode) {
        Print("   üíæ SAVING RECOVERY MISSION:");
        Print("      ID: " + missionIdParam);  // ‡πÉ‡∏ä‡πâ‡∏ä‡∏∑‡πà‡∏≠ parameter ‡πÉ‡∏´‡∏°‡πà
        Print("      Side: " + side);
        Print("      Target Price: " + DoubleToString(targetPrice, 5));
    }
    
    // ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏° logic ‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏î‡πâ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà
}
//-----//
//+------------------------------------------------------------------+
//| Has Clear Trend Signal                                         |
//+------------------------------------------------------------------+
bool HasClearTrendSignal()
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏´‡∏•‡∏≤‡∏¢ timeframe ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏ó‡∏µ‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô
    ENUM_TREND_DIRECTION trendH1 = AnalyzeTrendOnTimeframe(PERIOD_H1);
    ENUM_TREND_DIRECTION trendH4 = AnalyzeTrendOnTimeframe(PERIOD_H4);
    ENUM_TREND_DIRECTION trendD1 = AnalyzeTrendOnTimeframe(PERIOD_D1);
    
    // ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏ó‡∏µ‡πà‡∏™‡∏≠‡∏î‡∏Ñ‡∏•‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡πÉ‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 2 timeframe
    int matchingTrends = 0;
    if(trendH1 == trendH4) matchingTrends++;
    if(trendH1 == trendD1) matchingTrends++;
    if(trendH4 == trendD1) matchingTrends++;
    
    if(matchingTrends < 2) {
        DebugPrint(3, "Trend signals not aligned across timeframes");
        return false;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏Å‡∏£‡πà‡∏á‡∏Ç‡∏≠‡∏á‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå
    double trendStrengthH1 = CalculateTrendStrengthOnTimeframe(PERIOD_H1);
    double trendStrengthH4 = CalculateTrendStrengthOnTimeframe(PERIOD_H4);
    
    if(trendStrengthH1 < 0.6 || trendStrengthH4 < 0.6) {
        DebugPrint(3, "Trend strength too weak: H1=" + DoubleToString(trendStrengthH1,2) + 
                  ", H4=" + DoubleToString(trendStrengthH4,2));
        return false;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö momentum
    double rsiH1 = GetRSIValue(_Symbol, PERIOD_H1, 14, PRICE_CLOSE, 0);
    double adxH1 = GetADXValue(_Symbol, PERIOD_H1, 14);
    
    // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö uptrend: RSI ‡∏Ñ‡∏ß‡∏£‡πÑ‡∏°‡πà overbought, ADX ‡∏Ñ‡∏ß‡∏£‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á
    if(trendH1 == TREND_UP) {
        if(rsiH1 > 75) {
            DebugPrint(3, "Uptrend but RSI overbought: " + DoubleToString(rsiH1,1));
            return false;
        }
        if(adxH1 < 20) {
            DebugPrint(3, "Uptrend but ADX too weak: " + DoubleToString(adxH1,1));
            return false;
        }
    }
    // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö downtrend: RSI ‡∏Ñ‡∏ß‡∏£‡πÑ‡∏°‡πà oversold, ADX ‡∏Ñ‡∏ß‡∏£‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á
    else if(trendH1 == TREND_DOWN) {
        if(rsiH1 < 25) {
            DebugPrint(3, "Downtrend but RSI oversold: " + DoubleToString(rsiH1,1));
            return false;
        }
        if(adxH1 < 20) {
            DebugPrint(3, "Downtrend but ADX too weak: " + DoubleToString(adxH1,1));
            return false;
        }
    }
    
    Print("‚úÖ Clear trend signal detected: " + GetTrendDirectionName(trendH1) + 
          " | Strength H1: " + DoubleToString(trendStrengthH1,2) +
          " | ADX: " + DoubleToString(adxH1,1));
    
    return true;
}

//+------------------------------------------------------------------+
//| Has Clear Trading Signal                                       |
//+------------------------------------------------------------------+
bool HasClearTradingSignal()
{
    int clearSignals = 0;
    
    // ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 2 ‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏ó‡∏µ‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô‡∏à‡∏≤‡∏Å 3 ‡∏ä‡∏ô‡∏¥‡∏î
    if(HasClearScalpSignal()) {
        clearSignals++;
        DebugPrint(3, "Clear scalp signal found");
    }
    
    if(HasClearTrendSignal()) {
        clearSignals++;
        DebugPrint(3, "Clear trend signal found");
    }
    
    if(HasClearBreakoutSignal()) {
        clearSignals++;
        DebugPrint(3, "Clear breakout signal found");
    }
    
    DebugPrint(2, "Total clear signals: " + IntegerToString(clearSignals) + "/3");
    return (clearSignals >= 2);
}

//+------------------------------------------------------------------+
//| Has Clear Scalp Signal                                         |
//+------------------------------------------------------------------+
bool HasClearScalpSignal()
{
    double ema9_M1 = iMA(_Symbol, PERIOD_M1, 9, 0, MODE_EMA, PRICE_CLOSE);
    double ema21_M1 = iMA(_Symbol, PERIOD_M1, 21, 0, MODE_EMA, PRICE_CLOSE);
    double ema9_M5 = iMA(_Symbol, PERIOD_M5, 9, 0, MODE_EMA, PRICE_CLOSE);
    double ema21_M5 = iMA(_Symbol, PERIOD_M5, 21, 0, MODE_EMA, PRICE_CLOSE);
    
    double rsi_M1 = GetRSIValue(_Symbol, PERIOD_M1, 14, PRICE_CLOSE, 0);
    double rsi_M5 = GetRSIValue(_Symbol, PERIOD_M5, 14, PRICE_CLOSE, 0);
    
    // ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö scalp
    bool clearBuySignal = (
        (ema9_M1 > ema21_M1 && ema9_M5 > ema21_M5) && // EMA alignment
        ((ema9_M1 - ema21_M1) > (ema21_M1 * 0.0003)) && // Strong separation
        (rsi_M1 > 52 && rsi_M1 < 72) && // RSI in good range
        (rsi_M5 > 48 && rsi_M5 < 70) && // Confirmation from M5
        (!IsPriceAtExtreme()) // Not at extreme levels
    );
    
    bool clearSellSignal = (
        (ema9_M1 < ema21_M1 && ema9_M5 < ema21_M5) && // EMA alignment
        ((ema21_M1 - ema9_M1) > (ema21_M1 * 0.0003)) && // Strong separation
        (rsi_M1 < 48 && rsi_M1 > 28) && // RSI in good range
        (rsi_M5 < 52 && rsi_M5 > 30) && // Confirmation from M5
        (!IsPriceAtExtreme()) // Not at extreme levels
    );
    
    if(clearBuySignal || clearSellSignal) {
        string direction = clearBuySignal ? "BUY" : "SELL";
        Print("‚úÖ Clear scalp signal: " + direction + 
              " | RSI_M1: " + DoubleToString(rsi_M1,1) +
              " | EMA Separation: " + DoubleToString(MathAbs(ema9_M1 - ema21_M1) / GetPipSize(_Symbol), 1) + " pips");
        return true;
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| Has Clear Breakout Signal                                      |
//+------------------------------------------------------------------+
bool HasClearBreakoutSignal()
{
    MqlRates ratesH1[], ratesH4[];
    
    if(CopyRates(_Symbol, PERIOD_H1, 0, 10, ratesH1) < 10) return false;
    if(CopyRates(_Symbol, PERIOD_H4, 0, 5, ratesH4) < 5) return false;
    
    // ‡∏´‡∏≤‡∏Ñ‡πà‡∏≤ High/Low ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö breakout detection
    double recentHigh_H1 = ratesH1[1].high;
    double recentLow_H1 = ratesH1[1].low;
    double recentHigh_H4 = ratesH4[1].high;
    double recentLow_H4 = ratesH4[1].low;
    
    for(int i = 2; i < 5; i++) {
        if(ratesH1[i].high > recentHigh_H1) recentHigh_H1 = ratesH1[i].high;
        if(ratesH1[i].low < recentLow_H1) recentLow_H1 = ratesH1[i].low;
    }
    
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö breakout ‡∏ó‡∏µ‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô
    bool clearBreakoutUp = (
        (currentPrice > recentHigh_H1) && // Break H1 resistance
        (ratesH1[0].close > ratesH1[0].open) && // Bullish candle
        (ratesH1[0].tick_volume > ratesH1[1].tick_volume * 1.3) && // Volume confirmation
        (currentPrice > recentHigh_H4 * 0.9995) // Approaching H4 resistance
    );
    
    bool clearBreakoutDown = (
        (currentPrice < recentLow_H1) && // Break H1 support
        (ratesH1[0].close < ratesH1[0].open) && // Bearish candle
        (ratesH1[0].tick_volume > ratesH1[1].tick_volume * 1.3) && // Volume confirmation
        (currentPrice < recentLow_H4 * 1.0005) // Approaching H4 support
    );
    
    if(clearBreakoutUp || clearBreakoutDown) {
        string direction = clearBreakoutUp ? "UP" : "DOWN";
        double breakoutLevel = clearBreakoutUp ? recentHigh_H1 : recentLow_H1;
        Print("‚úÖ Clear breakout signal: " + direction + 
              " | Level: " + DoubleToString(breakoutLevel, 5) +
              " | Volume: " + DoubleToString((double)ratesH1[0].tick_volume / ratesH1[1].tick_volume, 1) + "x");
        return true;
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| Is Price At Extreme                                            |
//+------------------------------------------------------------------+
bool IsPriceAtExtreme()
{
    MqlRates ratesH4[];
    if(CopyRates(_Symbol, PERIOD_H4, 0, 20, ratesH4) < 20) return false;
    
    // ‡∏´‡∏≤ Bollinger Bands
    double bbUpper[1], bbLower[1];
    int bbHandle = iBands(_Symbol, PERIOD_H4, 20, 2, 0, PRICE_CLOSE);
    
    if(CopyBuffer(bbHandle, 1, 0, 1, bbUpper) <= 0 || 
       CopyBuffer(bbHandle, 2, 0, 1, bbLower) <= 0) {
        IndicatorRelease(bbHandle);
        return false;
    }
    
    IndicatorRelease(bbHandle);
    
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double distanceToUpper = (bbUpper[0] - currentPrice) / GetPipSize(_Symbol);
    double distanceToLower = (currentPrice - bbLower[0]) / GetPipSize(_Symbol);
    
    // ‡∏ñ‡πâ‡∏≤‡∏£‡∏≤‡∏Ñ‡∏≤‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏Ç‡∏≠‡∏ö Band ‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ (‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤ 10 pips)
    bool atUpperExtreme = (distanceToUpper < 10);
    bool atLowerExtreme = (distanceToLower < 10);
    
    if(atUpperExtreme || atLowerExtreme) {
        DebugPrint(3, "Price at extreme: " + 
                  (atUpperExtreme ? "Upper BB" : "Lower BB") + 
                  " | Distance: " + DoubleToString(atUpperExtreme ? distanceToUpper : distanceToLower, 1) + " pips");
        return true;
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| Get Market Score                                               |
//+------------------------------------------------------------------+
double GetMarketScore()
{
    double score = 0;
    int factors = 0;
    
    // 1. Trend Quality (30 points)
    if(HasClearTrendSignal()) {
        score += 30;
        factors++;
    }
    
    // 2. Volatility Suitability (25 points)
    double atrPercent = (GetATRValue(_Symbol, PERIOD_H1, 14) / SymbolInfoDouble(_Symbol, SYMBOL_BID)) * 100;
    if(atrPercent > 0.05 && atrPercent < 0.2) {
        score += 25; // Good volatility for trading
        factors++;
    } else if(atrPercent > 0.02 && atrPercent < 0.3) {
        score += 15; // Acceptable volatility
        factors++;
    }
    
    // 3. Risk Conditions (20 points)
    double riskPressure = CalculateRiskPressure();
    if(riskPressure < 0.3) {
        score += 20; // Low risk
        factors++;
    } else if(riskPressure < 0.6) {
        score += 10; // Moderate risk
        factors++;
    }
    
    // 4. Session Quality (15 points)
    string session = GetTradingSession();
    if(session == "LONDON_NY_OVERLAP" || session == "LONDON") {
        score += 15; // Good trading session
        factors++;
    } else if(session == "NY" || session == "ASIA") {
        score += 10; // Decent session
        factors++;
    }
    
    // 5. Signal Clarity (10 points)
    int clearSignals = 0;
    if(HasClearScalpSignal()) clearSignals++;
    if(HasClearTrendSignal()) clearSignals++;
    if(HasClearBreakoutSignal()) clearSignals++;
    
    if(clearSignals >= 2) {
        score += 10;
        factors++;
    } else if(clearSignals == 1) {
        score += 5;
        factors++;
    }
    
    // Calculate average score
    double finalScore = (factors > 0) ? (score / factors) : 0;
    
    DebugPrint(2, "Market Score: " + DoubleToString(finalScore, 1) + 
              " | Factors: " + IntegerToString(factors) + 
              " | Raw Score: " + DoubleToString(score, 1));
    
    return finalScore;
}
//----//
double CalculateDynamicDistance()
{
   double atrBuffer[];
   ArraySetAsSeries(atrBuffer, true);
   int atrHandle = iATR(_Symbol, _Period, 14);
   
   if(CopyBuffer(atrHandle, 0, 0, 3, atrBuffer) > 0)
   {
      double atr = atrBuffer[0];
      double distance = atr * 0.5;
      return MathMax(distance, MinDistance);
   }
   return MinDistance;
}
bool ShouldTradeInVolatileMarket(int marketRegime = -1)
{
    // ‡πÉ‡∏ä‡πâ currentVolatility ‡∏à‡∏≤‡∏Å Global variable ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
    
    if(marketRegime == MARKET_REGIME_RANGING_VOLATILE) {
        Print("‚ö° VOLATILE MARKET DETECTED - Checking trading conditions...");
        
        if(currentVolatility >= 150) {
            Print("‚ö†Ô∏è Volatility too high: ", currentVolatility, " > 150 - Skipping trade");
            return false;
        }
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô
        double totalProfit = CalculateTotalProfit();
        int totalOrders = CountAllOrders();
        
        if(totalProfit < -100) {
            return false;
        }
        
        if(totalOrders >= MaxTrade) {
            return false;
        }
        
        if(!IsSafeTradingTime()) {
            return false;
        }
        
        Print("‚úÖ Volatile market trading allowed | Volatility: ", currentVolatility);
        return true;
    }
    
    // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡πÅ‡∏ö‡∏ö‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå
    return ShouldTradeInVolatileMarketDefault();
}

// üî• ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå
bool CheckOrderDistance()
{
    double minDistancePoints = 50; // ‡∏à‡∏∏‡∏î‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå
    
    int buyOrders = CountBuyOrders();
    int sellOrders = CountSellOrders();
    
    if(buyOrders > 0 && sellOrders > 0) {
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£ hedging ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        double avgBuyPrice = GetAverageBuyPrice();
        double avgSellPrice = GetAverageSellPrice();
        double distance = MathAbs(avgBuyPrice - avgSellPrice) / _Point;
        
        if(distance < minDistancePoints) {
            Print("‚ö†Ô∏è Order distance too small: ", distance, " points");
            return false;
        }
    }
    
    return true;
}
// üî• ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏ó‡∏£‡∏î
bool IsSafeTradingTime()
{
    datetime currentTime = TimeCurrent();
    MqlDateTime timeStruct;
    TimeToStruct(currentTime, timeStruct);
    
    int currentHour = timeStruct.hour;
    
    // ‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡πÄ‡∏ß‡∏•‡∏≤ news ‡∏´‡∏£‡∏∑‡∏≠‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á
    if((currentHour >= 0 && currentHour <= 1) ||    // ‡∏Å‡∏£‡∏∏‡∏á‡πÄ‡∏ó‡∏û‡∏Ø ‡πÄ‡∏ä‡πâ‡∏≤‡∏°‡∏∑‡∏î
       (currentHour >= 12 && currentHour <= 14) ||   // ‡∏ä‡πà‡∏ß‡∏á‡∏û‡∏±‡∏Å‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏á
       (currentHour >= 21 && currentHour <= 23)) {   // ‡∏Å‡∏£‡∏∏‡∏á‡πÄ‡∏ó‡∏û‡∏Ø ‡∏î‡∏∂‡∏Å
        Print("‚ö†Ô∏è Unsafe trading hour: ", currentHour);
        return false;
    }
    
    return true;
}
// üî• ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö risk management
bool CheckRiskManagement(double volatility = 0)
{
    double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
    double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);
    double drawdownPercent = ((accountBalance - accountEquity) / accountBalance) * 100;
    
    if(drawdownPercent > 5) { // ‡∏à‡∏≥‡∏Å‡∏±‡∏î drawdown ‡∏ó‡∏µ‡πà 5%
        Print("‚ö†Ô∏è Drawdown too high: ", drawdownPercent, "%");
        return false;
    }
    
    double marginLevel = AccountInfoDouble(ACCOUNT_MARGIN_LEVEL);
    if(marginLevel > 0 && marginLevel < 200) { // Margin level ‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤ 200%
        Print("‚ö†Ô∏è Margin level too low: ", marginLevel, "%");
        return false;
    }
    
    // üî• ‡∏õ‡∏£‡∏±‡∏ö risk ‡∏ï‡∏≤‡∏° volatility
    if(volatility > 100) {
        // ‡∏´‡∏≤‡∏Å volatility ‡∏™‡∏π‡∏á ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ risk ‡∏ó‡∏µ‡πà‡∏ï‡πà‡∏≥‡∏•‡∏á
        double maxRiskPercent = 1.0; // 1% ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö high volatility
        double currentRisk = CalculateCurrentRiskPercent();
        
        if(currentRisk > maxRiskPercent) {
            Print("‚ö†Ô∏è Risk too high for volatile market: ", currentRisk, "% > ", maxRiskPercent, "%");
            return false;
        }
    }
    
    return true;
}
double CalculateCurrentRiskPercent()
{
    double totalLots = 0;
    int totalOrders = OrdersTotal();
    
    for(int i = 0; i < totalOrders; i++) {
        if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) {
            if(OrderSymbol() == _Symbol && OrderMagicNumber() == MagicNumber) {
                totalLots += OrderLots();
            }
        }
    }
    
    double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
    double riskPercent = (totalLots * 1000) / accountBalance * 100; // ‡∏™‡∏π‡∏ï‡∏£‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á
    
    return NormalizeDouble(riskPercent, 2);
}

// üî• ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÉ‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì:
void CheckMarketAndTrade()
{
    // ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î
    int marketRegime = AnalyzeMarketCondition();
    
    if(marketRegime == MARKET_REGIME_RANGING_VOLATILE) {
        Print("üåä DETECTED: VOLATILE RANGING MARKET");
        
        double volatility = CalculateVolatility();
        
        // üî• ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÅ‡∏•‡πâ‡∏ß
        if(volatility < 150 && ShouldTradeInVolatileMarket(MARKET_REGIME_RANGING_VOLATILE)) {
            Print("‚úÖ Trading in volatile market allowed");
            ExecuteVolatileMarketStrategy();
        } else {
            Print("‚õî Trading in volatile market NOT allowed");
            Print("   Volatility: ", volatility, " | ShouldTrade: ", 
                  ShouldTradeInVolatileMarket(MARKET_REGIME_RANGING_VOLATILE));
        }
    }
}



void CheckForTrade()
{
    string marketCondition = AnalyzeMarket();
    double trendStrength = GetTrendStrength();
    double volatility = GetVolatility();
    double spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) * _Point;
    
    // Debug output
    Print("=== MARKET ANALYSIS ===");
    Print("Condition: ", marketCondition, " | Trend Strength: ", trendStrength, " | Volatility: ", volatility, " | Spread: ", spread);
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ï‡∏•‡∏≤‡∏î‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏ó‡∏£‡∏î
    if(!IsMarketSuitableForTrading(marketCondition, spread, volatility))
    {
        Print("Market not suitable for trading - Skipping trade");
        return;
    }
    
    // ‡πÄ‡∏ó‡∏£‡∏î‡∏ï‡∏≤‡∏°‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î
    if(marketCondition == "TRENDING" && trendStrength > 0.6)
    {
        Print("Strong Trend detected - Trading with trend");
        
        if(IsUptrend() && CountBuy < MaxTrade)
        {
            // ‚úÖ ‡πÅ‡∏Å‡πâ: ‡πÉ‡∏ä‡πâ MARKET_REGIME_TRENDING_STRONG ‡πÅ‡∏ó‡∏ô marketCondition
            if(ShouldOpenTrade(ORDER_TYPE_BUY, MARKET_REGIME_TRENDING_STRONG))
            {
                OpenBuyOrder();
                Print("Opening BUY order - Strong Uptrend");
            }
        }
        else if(IsDowntrend() && CountSell < MaxTrade)
        {
            // ‚úÖ ‡πÅ‡∏Å‡πâ: ‡πÉ‡∏ä‡πâ MARKET_REGIME_TRENDING_STRONG ‡πÅ‡∏ó‡∏ô marketCondition
            if(ShouldOpenTrade(ORDER_TYPE_SELL, MARKET_REGIME_TRENDING_STRONG))
            {
                OpenSellOrder();
                Print("Opening SELL order - Strong Downtrend");
            }
        }
    }
    else if(marketCondition == "RANGING" && volatility < 80)
    {
        Print("Range Market detected - Using range strategy");
        // ‚úÖ ‡πÉ‡∏ä‡πâ MARKET_REGIME_RANGING_CALM
        UseRangeStrategy(MARKET_REGIME_RANGING_CALM);
    }
    else if(marketCondition == "BREAKOUT")
    {
        Print("Breakout detected - Looking for breakout opportunities");
        // ‚úÖ ‡πÉ‡∏ä‡πâ MARKET_REGIME_BREAKOUT_POTENTIAL
        if(IsBreakoutConfirmed(MARKET_REGIME_BREAKOUT_POTENTIAL))
        {
            TradeBreakout();
        }
    }
    else if(marketCondition == "VOLATILE")
    {
        Print("Volatile market - Using cautious strategy");
        // ‚úÖ ‡πÉ‡∏ä‡πâ MARKET_REGIME_RANGING_VOLATILE
        if(volatility < 150 && ShouldTradeInVolatileMarket(MARKET_REGIME_RANGING_VOLATILE))
        {
            UseVolatileMarketStrategy(MARKET_REGIME_RANGING_VOLATILE);
        }
    }
    else
    {
        Print("Waiting for better market condition: ", marketCondition);
        // ‚úÖ ‡πÉ‡∏ä‡πâ MARKET_REGIME_NORMAL
    }
}
bool IsMarketSuitableForTrading(string condition, double spread, double volatility)
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Spread ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡∏ó‡∏µ‡πà‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö‡πÑ‡∏î‡πâ
    if(spread > MaxAllowedSpread * _Point)
    {
        Print("Spread too high: ", spread/_Point, " points");
        return false;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
    if(volatility > 200 && !AllowHighVolatilityTrading)
    {
        Print("Volatility too high: ", volatility);
        return false;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
    if(condition == "VOLATILE" && !AllowVolatileTrading)
    {
        Print("Volatile market trading disabled");
        return false;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ä‡πà‡∏ß‡∏á‡∏Ç‡πà‡∏≤‡∏ß‡πÄ‡∏®‡∏£‡∏©‡∏ê‡∏Å‡∏¥‡∏à
    if(IsEconomicNewsTime() && !TradeDuringNews)
    {
        Print("Economic news time - Trading paused");
        return false;
    }
    
    return true;
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô OpenBuyOrder ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ Lot Dynamic
void OpenBuyOrder()
{
   MqlTradeRequest request;
   MqlTradeResult result;
   ZeroMemory(request);
   ZeroMemory(result);
   
   double lot = CalculateDynamicLot();
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double dynamicDistance = CalculateDynamicDistance();
   
   request.action = TRADE_ACTION_DEAL;
   request.symbol = _Symbol;
   request.volume = lot;
   request.type = ORDER_TYPE_BUY;
   request.price = ask;
   request.sl = ask - (dynamicDistance * 2 * _Point);
   request.tp = ask + (dynamicDistance * 3 * _Point);
   request.deviation = 10;
   request.magic = 12345;
   
   if(!OrderSend(request, result))
   {
      Print("Buy Order failed: ", GetLastError());
   }
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô OpenSellOrder ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ Lot Dynamic
void OpenSellOrder()
{
   MqlTradeRequest request;
   MqlTradeResult result;
   ZeroMemory(request);
   ZeroMemory(result);
   
   double lot = CalculateDynamicLot();
   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double dynamicDistance = CalculateDynamicDistance();
   
   request.action = TRADE_ACTION_DEAL;
   request.symbol = _Symbol;
   request.volume = lot;
   request.type = ORDER_TYPE_SELL;
   request.price = bid;
   request.sl = bid + (dynamicDistance * 2 * _Point);
   request.tp = bid - (dynamicDistance * 3 * _Point);
   request.deviation = 10;
   request.magic = 12345;
   
   if(!OrderSend(request, result))
   {
      Print("Sell Order failed: ", GetLastError());
   }
}
string DetectMarketCondition()
{
   double atrBuffer[];
   ArraySetAsSeries(atrBuffer, true);
   int atrHandle = iATR(_Symbol, _Period, 14);
   
   if(CopyBuffer(atrHandle, 0, 0, 3, atrBuffer) > 0)
   {
      double volatility = atrBuffer[0] / _Point;
      int spread = (int)SymbolInfoInteger(_Symbol, SYMBOL_SPREAD);
      
      if(volatility > 100 && spread < 30) 
         return "TRENDING";
      else if(volatility < 50 && spread < 20)
         return "RANGING";
   }
   return "VOLATILE";
}
bool IsBreakoutConfirmed(int marketCondition = -1)
{
    // üî• ‡∏´‡∏≤‡∏Å‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ï‡∏≤‡∏°‡∏ô‡∏±‡πâ‡∏ô
    if(marketCondition == MARKET_REGIME_BREAKOUT_POTENTIAL) {
        Print("üîç Checking for Breakout Confirmation (POTENTIAL mode)");
        return CheckBreakoutWithConfirmation(true); // ‡πÇ‡∏´‡∏°‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏ö‡∏ö‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î
    }
    
    // üî• ‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Breakout ‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô
    double highBuffer[], lowBuffer[];
    ArraySetAsSeries(highBuffer, true);
    ArraySetAsSeries(lowBuffer, true);
    
    CopyHigh(_Symbol, _Period, 0, 5, highBuffer);
    CopyLow(_Symbol, _Period, 0, 5, lowBuffer);
    
    double currentATR = GetATR();
    double atrMultiplier = 0.3;
    
    // üìä ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Breakout ‡∏Ç‡∏∂‡πâ‡∏ô
    bool bullishBreakout = (highBuffer[0] > highBuffer[1] + (currentATR * atrMultiplier));
    // üìâ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Breakout ‡∏•‡∏á
    bool bearishBreakout = (lowBuffer[0] < lowBuffer[1] - (currentATR * atrMultiplier));
    
    bool isConfirmed = bullishBreakout || bearishBreakout;
    
    if(isConfirmed) {
        string direction = bullishBreakout ? "BULLISH" : "BEARISH";
        Print("‚úÖ BREAKOUT CONFIRMED | Direction: ", direction, 
              " | Price: ", bullishBreakout ? highBuffer[0] : lowBuffer[0],
              " | Previous: ", bullishBreakout ? highBuffer[1] : lowBuffer[1],
              " | ATR: ", currentATR);
    }
    
    return isConfirmed;
}
// üî• ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö breakout ‡πÅ‡∏ö‡∏ö‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö POTENTIAL mode)
bool CheckBreakoutWithConfirmation(bool strictMode = false)
{
    // ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏•‡∏≤‡∏¢ timeframe ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô breakout
    double highBufferM15[], lowBufferM15[];
    double highBufferH1[], lowBufferH1[];
    
    ArraySetAsSeries(highBufferM15, true);
    ArraySetAsSeries(lowBufferM15, true);
    ArraySetAsSeries(highBufferH1, true);
    ArraySetAsSeries(lowBufferH1, true);
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏ô‡∏´‡∏•‡∏≤‡∏¢ timeframe
    CopyHigh(_Symbol, PERIOD_M15, 0, 3, highBufferM15);
    CopyLow(_Symbol, PERIOD_M15, 0, 3, lowBufferM15);
    CopyHigh(_Symbol, PERIOD_H1, 0, 3, highBufferH1);
    CopyLow(_Symbol, PERIOD_H1, 0, 3, lowBufferH1);
    
    double currentATR = GetATR();
    double atrMultiplier = strictMode ? 0.25 : 0.3;
    
    // ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î‡∏Å‡∏ß‡πà‡∏≤
    bool breakoutM15 = (highBufferM15[0] > highBufferM15[1] + (currentATR * atrMultiplier)) ||
                       (lowBufferM15[0] < lowBufferM15[1] - (currentATR * atrMultiplier));
    
    bool breakoutH1 = (highBufferH1[0] > highBufferH1[1] + (currentATR * atrMultiplier * 0.7)) ||
                      (lowBufferH1[0] < lowBufferH1[1] - (currentATR * atrMultiplier * 0.7));
    
    // ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏à‡∏≤‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á timeframe
    bool isConfirmed = breakoutM15 && breakoutH1;
    
    if(isConfirmed) {
        Print("üéØ STRONG BREAKOUT CONFIRMED | M15 & H1 alignment");
        Print("   M15 Breakout: ", breakoutM15 ? "Yes" : "No");
        Print("   H1 Breakout: ", breakoutH1 ? "Yes" : "No");
        Print("   ATR: ", currentATR, " | Multiplier: ", atrMultiplier);
    }
    
    return isConfirmed;
}
void CheckAndHandleBreakout()
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö market condition
    int marketRegime = AnalyzeMarketCondition(); // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡πÉ‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î
    
    // ‡∏´‡∏≤‡∏Å‡∏°‡∏µ‡πÅ‡∏ô‡∏ß‡πÇ‡∏ô‡πâ‡∏° breakout
    if(marketRegime == MARKET_REGIME_BREAKOUT_POTENTIAL) {
        Print("‚ö° BREAKOUT POTENTIAL DETECTED - Initiating confirmation check");
        
        // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ IsBreakoutConfirmed ‡∏î‡πâ‡∏ß‡∏¢‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå
        bool breakoutConfirmed = IsBreakoutConfirmed(MARKET_REGIME_BREAKOUT_POTENTIAL);
        
        if(breakoutConfirmed) {
            // ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô breakout
            HandleConfirmedBreakout();
        } else {
            Print("‚è≥ Breakout not yet confirmed, continuing monitoring...");
        }
    }
}

bool IsEconomicNewsTime()
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ä‡πà‡∏ß‡∏á‡∏Ç‡πà‡∏≤‡∏ß‡πÄ‡∏®‡∏£‡∏©‡∏ê‡∏Å‡∏¥‡∏à (‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á)
    MqlDateTime time;
    TimeCurrent(time);
    
    // ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á: ‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏ä‡πà‡∏ß‡∏á NFP (‡∏ß‡∏±‡∏ô‡∏®‡∏∏‡∏Å‡∏£‡πå‡πÅ‡∏£‡∏Å‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏∑‡∏≠‡∏ô 13:30 UTC)
    if(time.day_of_week == 5 && time.hour == 13 && time.min >= 25 && time.min <= 45)
    {
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏±‡∏ô‡∏®‡∏∏‡∏Å‡∏£‡πå‡πÅ‡∏£‡∏Å‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡πÑ‡∏´‡∏°
        if(time.day <= 7) return true;
    }
    
    return false;
}
void TradeBreakout()
{
    // ‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡πÄ‡∏ó‡∏£‡∏î Breakout (‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á)
    double highBuffer[], lowBuffer[];
    ArraySetAsSeries(highBuffer, true);
    ArraySetAsSeries(lowBuffer, true);
    
    CopyHigh(_Symbol, _Period, 0, 5, highBuffer);
    CopyLow(_Symbol, _Period, 0, 5, lowBuffer);
    
    if(highBuffer[0] > highBuffer[1] + (GetATR() * 0.3) && CountBuy < MaxTrade)
    {
        OpenBuyOrder();
        Print("BUY Breakout confirmed");
    }
    else if(lowBuffer[0] < lowBuffer[1] - (GetATR() * 0.3) && CountSell < MaxTrade)
    {
        OpenSellOrder();
        Print("SELL Breakout confirmed");
    }
}

void CheckTradeCondition()
{
    // ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏ï‡∏•‡∏≤‡∏î‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
    string marketCondition = AnalyzeMarket();
    double trendStrength = GetTrendStrength();
    double volatility = GetVolatility();
    
    // Debug output
    Print("Market Condition: ", marketCondition, " | Trend Strength: ", trendStrength, " | Volatility: ", volatility);
    
    // ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î‡∏ï‡∏≤‡∏°‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î
    if(marketCondition == "TRENDING" && trendStrength > 0.7)
    {
        // ‡∏ï‡∏•‡∏≤‡∏î‡∏°‡∏µ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏ä‡∏±‡∏î - ‡πÄ‡∏ó‡∏£‡∏î‡∏ï‡∏≤‡∏°‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå
        if(IsUptrend() && CountBuy < MaxTrade)
        {
            if(ShouldOpenTrade("BUY", marketCondition))
            {
                OpenBuyOrder();
                Print("Opening BUY - Strong Uptrend");
            }
        }
        else if(IsDowntrend() && CountSell < MaxTrade)
        {
            if(ShouldOpenTrade("SELL", marketCondition))
            {
                OpenSellOrder();
                Print("Opening SELL - Strong Downtrend");
            }
        }
    }
    else if(marketCondition == "RANGING" && volatility < 50)
    {
        // ‡∏ï‡∏•‡∏≤‡∏î Sideway - ‡πÉ‡∏ä‡πâ‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå Range
        if(ShouldUseRangeStrategy())
        {
            UseRangeStrategy();
            Print("Using Range Strategy - Market Ranging");
        }
    }
    else if(marketCondition == "VOLATILE" && volatility > 100)
    {
        // ‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô - ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏ä‡πâ Hedge
        if(ShouldTradeInVolatileMarket())
        {
            UseVolatileMarketStrategy();
            Print("Using Volatile Market Strategy");
        }
    }
    else if(marketCondition == "BREAKOUT")
    {
        // ‡∏ï‡∏•‡∏≤‡∏î‡∏Å‡∏≥‡∏•‡∏±‡∏á Breakout - ‡∏£‡∏≠‡πÇ‡∏≠‡∏Å‡∏≤‡∏™
        if(IsBreakoutConfirmed())
        {
            TradeBreakout();
            Print("Trading Breakout");
        }
    }
    else
    {
        // ‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î‡πÑ‡∏°‡πà‡πÅ‡∏ô‡πà‡∏ô‡∏≠‡∏ô - ‡∏£‡∏≠‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô
        Print("Market unclear - Waiting for better condition");
    }
}

bool IsTooCloseToLastTrade(string tradeType)
{
    if(!CheckPreviousOrderLevel) return false;
    
    double currentPrice = (tradeType == "BUY") ? SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionGetString(POSITION_SYMBOL) == _Symbol)
        {
            double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            double distance = MathAbs(currentPrice - openPrice) / _Point;
            
            if(distance < MinTradeDistance)
            {
                Print("Too close to existing order: ", distance, " points");
                return true;
            }
        }
    }
    
    return false;
}
bool IsTooCloseToPreviousOrders(string tradeType)
{
    double currentPrice = (tradeType == "BUY") ? SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID);
    int nearbyOrders = 0;
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionGetString(POSITION_SYMBOL) == _Symbol)
        {
            double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            double distance = MathAbs(currentPrice - openPrice) / _Point;
            
            // ‡∏ô‡∏±‡∏ö‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
            if(distance < MinTradeDistance)
            {
                nearbyOrders++;
            }
            
            // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÉ‡∏ô‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏°‡∏≤‡∏Å‡πÜ
            if(distance < (MinTradeDistance * 0.3))
            {
                Print("Very close to existing order: ", distance, " points");
                return true;
            }
        }
    }
    
    // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÉ‡∏Å‡∏•‡πâ‡πÜ ‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 2 ‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå
    if(nearbyOrders >= 2)
    {
        Print("Too many nearby orders: ", nearbyOrders);
        return true;
    }
    
    return false;
}
bool ShouldOpenTrade(ENUM_ORDER_TYPE type, ENUM_MARKET_REGIME regime) 
{
    // ===== ‡πÇ‡∏Ñ‡πâ‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô =====
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Spread
    int spread = (int)SymbolInfoInteger(_Symbol, SYMBOL_SPREAD);
    if(spread > MaxAllowedSpread) 
    {
        Print("Spread too high: ", spread);
        return false;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πà‡∏≤‡∏ß‡πÄ‡∏®‡∏£‡∏©‡∏ê‡∏Å‡∏¥‡∏à (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ)
    if(CheckEconomicNews && !IsEconomicNewsTime()) 
    {
        Print("Economic news time - skipping");
        return false;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏° (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ)
    if(UseTradingHours && !IsTradingTime()) 
    {
        Print("Outside trading hours");
        return false;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° regime)
    int maxPositions = GetMaxPositionsForRegime(regime);
    if(PositionsTotal() >= maxPositions) 
    {
        Print("Maximum positions reached for ", EnumToString(regime));
        return false;
    }
    
    // ===== ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÉ‡∏´‡∏°‡πà‡∏ï‡∏≤‡∏° Regime =====
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö regime-specific conditions
    switch(regime) 
    {
        case MARKET_REGIME_RANGING_VOLATILE:
            // ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô ‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏û‡∏¥‡πà‡∏°
            if(!CheckVolatilityConditions(type)) 
            {
                Print("Failed volatility check in RANGING_VOLATILE");
                return false;
            }
            break;
            
        case MARKET_REGIME_TRENDING_STRONG:
            // ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏ó‡∏£‡∏î‡∏ï‡∏≤‡∏°‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
            if(!IsTradingWithTrend(type)) 
            {
                Print("Trading against trend in TRENDING_STRONG");
                return false;
            }
            break;
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            // ‡∏£‡∏≠ breakout confirmation
            if(!IsConfirmedBreakout(orderType)) 
            {
                Print("No confirmed breakout in BREAKOUT_POTENTIAL");
                return false;
            }
            break;
            
        case MARKET_REGIME_RANGING_CALM:
            // ‡πÉ‡∏ô sideways ‡πÄ‡∏á‡∏µ‡∏¢‡∏ö ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö range boundaries
            if(!IsAtRangeBoundary(type)) 
            {
                Print("Not at range boundary in RANGING_CALM");
                return false;
            }
            break;
            
        case MARKET_REGIME_TRENDING_WEAK:
            // ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏≠‡πà‡∏≠‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ confirmation ‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô
            if(!HasMultipleConfirmations(type)) 
            {
                Print("Insufficient confirmations in TRENDING_WEAK");
                return false;
            }
            break;
            
        case MARKET_REGIME_NORMAL:
            // ‡∏™‡∏†‡∏≤‡∏û‡∏õ‡∏Å‡∏ï‡∏¥ ‡πÉ‡∏ä‡πâ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô
            if(!IsNormalMarketConditionGood(type)) 
            {
                Print("Market conditions not favorable in NORMAL");
                return false;
            }
            break;
    }
    
    // ===== ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î =====
    // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô IsTooCloseToLastTrade
    
    return true;
}
// Helper functions
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î‡∏õ‡∏Å‡∏ï‡∏¥
bool IsNormalMarketConditionGood(ENUM_ORDER_TYPE type)
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö volatility ‡∏õ‡∏Å‡∏ï‡∏¥
    ouble atr = GetATRValue(_Symbol, PERIOD_H1, 14, 0);
    double atrAvg = GetATRAverage(50);
    
    if(atr > atrAvg * 1.8) 
    {
        Print("Too volatile for normal conditions");
        return false;
    }
    
    return true;
}
bool HasMultipleConfirmations(ENUM_ORDER_TYPE type)
{
    int confirmations = 0;
    
    // 1. Trend direction
    if(IsTradingWithTrend(type)) confirmations++;
    
    // 2. Momentum confirmation
    if(IsMomentumConfirming(type)) confirmations++;
    
    // 3. Volume confirmation
    if(IsVolumeConfirming(type)) confirmations++;
    
    // ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 2 confirmations
    return (confirmations >= 2);
}
int GetMaxPositionsForRegime(ENUM_MARKET_REGIME regime)
{
    switch(regime)
    {
        case MARKET_REGIME_RANGING_VOLATILE:
            return 3;  // ‡∏ô‡πâ‡∏≠‡∏¢‡∏•‡∏á‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
            
        case MARKET_REGIME_TRENDING_STRONG:
            return 4;  // ‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á
            
        case MARKET_REGIME_BREAKOUT_POTENTIAL:
            return 2;  // ‡∏ô‡πâ‡∏≠‡∏¢‡∏°‡∏≤‡∏Å‡πÉ‡∏ô breakout
            
        case MARKET_REGIME_RANGING_CALM:
            return 5;  // ‡∏°‡∏≤‡∏Å‡πÉ‡∏ô sideways ‡πÄ‡∏á‡∏µ‡∏¢‡∏ö
            
        case MARKET_REGIME_TRENDING_WEAK:
            return 4;  // ‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏≠‡πà‡∏≠‡∏ô
            
        case MARKET_REGIME_NORMAL:
        default:
            return MaxTotalPositions; // ‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å input parameter
    }
}
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
bool CheckVolatilityConditions(ENUM_ORDER_TYPE type)
{
    ouble atr = GetATRValue(_Symbol, PERIOD_H1, 14, 0);
    double atrAvg = GetATRAverage(50);
    
    // ‡∏ñ‡πâ‡∏≤ ATR ‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏°‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
    if(atr > atrAvg * 2.0) 
    {
        Print("Extreme volatility detected");
        return false;
    }
    
    return true;
}
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏ó‡∏£‡∏î‡∏ï‡∏≤‡∏°‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
bool IsTradingWithTrend(ENUM_ORDER_TYPE type)
{
    double trendDirection = GetTrendDirection();
    
    if(type == ORDER_TYPE_BUY && trendDirection >= 0) 
        return true;
        
    if(type == ORDER_TYPE_SELL && trendDirection <= 0) 
        return true;
    
    return false;
}
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏≤‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå
double GetTrendDirection()
{
    double ema50 = GetEMAValue(Symbol(), PERIOD_CURRENT, 50, 0);
    double ema200 = GetEMAValue(Symbol(), PERIOD_CURRENT, 200, 0);
    double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    if(price > ema50 && ema50 > ema200) 
        return 1.0;    // Uptrend
    else if(price < ema50 && ema50 < ema200) 
        return -1.0;   // Downtrend
    else 
        return 0.0;    // No clear trend
}
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö breakout confirmation
bool IsConfirmedBreakout(ENUM_ORDER_TYPE orderType = ORDER_TYPE_BUY)
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ú‡πà‡∏≤‡∏ô key level ‡πÅ‡∏•‡∏∞‡∏¢‡∏∑‡∏ô‡πÄ‡∏´‡∏ô‡∏∑‡∏≠/‡πÉ‡∏ï‡πâ‡πÑ‡∏î‡πâ
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    // ‡πÉ‡∏ä‡πâ iHigh ‡πÅ‡∏•‡∏∞ iLow ‡πÅ‡∏ó‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ
    double previousHigh = iHigh(_Symbol, PERIOD_CURRENT, 1);  // High ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ó‡πà‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤
    double previousLow = iLow(_Symbol, PERIOD_CURRENT, 1);    // Low ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ó‡πà‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤
    
    // ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ orderType ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà type
    if(orderType == ORDER_TYPE_BUY) 
    {
        // Breakout ‡∏Ç‡∏∂‡πâ‡∏ô: ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤ previous high
        bool breakoutUp = (currentPrice > previousHigh);
        
        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç confirmation: volume ‡πÅ‡∏•‡∏∞ momentum
        if(breakoutUp)
        {
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö volume confirmation
            bool volumeOK = CheckBreakoutVolume();
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö momentum ‡∏î‡πâ‡∏ß‡∏¢ RSI ‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏∑‡πà‡∏ô‡πÜ
            bool momentumOK = CheckBreakoutMomentum(ORDER_TYPE_BUY);
            
            return volumeOK && momentumOK;
        }
        return false;
    }
    else if(orderType == ORDER_TYPE_SELL) 
    {
        // Breakout ‡∏•‡∏á: ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤ previous low
        bool breakoutDown = (currentPrice < previousLow);
        
        if(breakoutDown)
        {
            bool volumeOK = CheckBreakoutVolume();
            bool momentumOK = CheckBreakoutMomentum(ORDER_TYPE_SELL);
            
            return volumeOK && momentumOK;
        }
        return false;
    }
    
    return false;
}
bool IsMarketGoodForTrading(string symbol, ENUM_MARKET_REGIME regime)
{
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô
    if(!SymbolInfoInteger(symbol, SYMBOL_TRADE_MODE) == SYMBOL_TRADE_MODE_FULL)
        return false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ï‡∏≤‡∏° regime
    double volatility = GetMarketVolatility();
    
    switch(regime)
    {
        case MARKET_REGIME_RANGING_VOLATILE:
            return (volatility < 0.02); // ‡πÑ‡∏°‡πà‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
            
        case MARKET_REGIME_TRENDING_STRONG:
            return true; // ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡πÅ‡∏£‡∏á‡πÄ‡∏ó‡∏£‡∏î‡πÑ‡∏î‡πâ‡∏õ‡∏Å‡∏ï‡∏¥
            
        default:
            return true;
    }
}

bool ShouldUseRangeStrategy()
{
    // ‚úÖ ‡πÉ‡∏ä‡πâ PositionsTotal() ‡πÅ‡∏ó‡∏ô (built-in ‡∏Ç‡∏≠‡∏á MQL5)
    if(PositionsTotal() >= MaxRangeOrders)
        return false;
        
    if(CalculateTotalProfit() < -MaxRangeDrawdown)
        return false;
        
    return true;
}

bool ShouldOpenNewTradeInRange()
{
    double profit = CalculateTotalProfit();
    double riskPressure = CalculateRiskPressure();
    
    // ‡∏ñ‡πâ‡∏≤‡∏Å‡∏≥‡πÑ‡∏£: ‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÑ‡∏î‡πâ‡∏ï‡∏≤‡∏°‡∏õ‡∏Å‡∏ï‡∏¥
    if(profit > 0) return true;
    
    // ‡∏ñ‡πâ‡∏≤‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏ô‡πâ‡∏≠‡∏¢: ‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏î‡πâ‡πÅ‡∏ï‡πà‡∏•‡∏î‡∏•‡πá‡∏≠‡∏ï
    if(profit >= -20) return true;
    
    // ‡∏ñ‡πâ‡∏≤‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á: ‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏î‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡∏î‡∏µ‡∏à‡∏£‡∏¥‡∏á‡πÜ
    if(profit >= -50 && riskPressure < 0.3) return true;
    
    // ‡∏ñ‡πâ‡∏≤‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏°‡∏≤‡∏Å: ‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÉ‡∏´‡∏°‡πà
    return false;
}
// üî• ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏•‡πá‡∏≠‡∏ï‡πÅ‡∏ö‡∏ö‡∏á‡πà‡∏≤‡∏¢‡πÜ
// üî• ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏•‡πá‡∏≠‡∏ï‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏Ñ‡∏∏‡∏ì
double CalculateSimpleRecoveryLot(double currentProfit, string marketCondition)
{
    // ‚úÖ ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏•‡πá‡∏≠‡∏ï‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
    double baseLot = CalculateSimpleLot();  // ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
    
    // ‡πÉ‡∏ä‡πâ RecoveryTarget ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏õ‡∏£‡∏±‡∏ö‡∏•‡πá‡∏≠‡∏ï
    if(currentProfit < -RecoveryTarget * 2) {
        return baseLot * 1.5; // ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏´‡∏ô‡∏±‡∏Å ‚Üí ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏•‡πá‡∏≠‡∏ï
    }
    else if(currentProfit < -RecoveryTarget) {
        return baseLot * 1.2; // ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á ‚Üí ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏•‡πá‡∏≠‡∏ï‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
    }
    else if(currentProfit > RecoveryTarget) {
        return baseLot * 0.8; // ‡∏Å‡∏≥‡πÑ‡∏£‡∏î‡∏µ ‚Üí ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏ï
    }
    
    return baseLot; // ‡∏™‡∏†‡∏≤‡∏û‡∏õ‡∏Å‡∏ï‡∏¥
}

// üî• ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÇ‡∏´‡∏°‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î‡πÅ‡∏ö‡∏ö‡∏á‡πà‡∏≤‡∏¢‡πÜ
string GetSimpleTradingMode(double profit)
{
    // ‡πÉ‡∏ä‡πâ RecoveryTarget ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÇ‡∏´‡∏°‡∏î
    if(profit < -RecoveryTarget * 2) return "AGGRESSIVE_RECOVERY";
    if(profit < -RecoveryTarget) return "CAUTIOUS_RECOVERY"; 
    if(profit > RecoveryTarget) return "PROFIT_PROTECTION";
    return "NORMAL_TRADING";
}
void UseRangeStrategy(int marketRegime = -1)
{
    double rangeHigh = GetRangeHigh();
    double rangeLow = GetRangeLow();
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double totalProfit = CalculateTotalProfit();
    string marketCondition = "";
    
    // üî• ‡πÅ‡∏õ‡∏•‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç regime ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏ï‡∏£‡∏¥‡∏á
    if(marketRegime == MARKET_REGIME_RANGING_CALM) {
        marketCondition = "MARKET_REGIME_RANGING_CALM";
        Print("üìä Using CALM RANGING strategy (Regime: ", marketRegime, ")");
    }
    else if(marketRegime == MARKET_REGIME_RANGING_VOLATILE) {
        marketCondition = "MARKET_REGIME_RANGING_VOLATILE";
        Print("üìä Using VOLATILE RANGING strategy (Regime: ", marketRegime, ")");
    }
    else if(marketRegime == MARKET_REGIME_TRENDING) {
        marketCondition = "MARKET_REGIME_TRENDING";
        Print("üìä Using TRENDING strategy (Regime: ", marketRegime, ")");
    }
    else {
        // ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
        marketCondition = AnalyzeMarket();
        Print("üìä Using auto-detected market: ", marketCondition);
    }
    
    bool isCalmRanging = (marketCondition == "MARKET_REGIME_RANGING_CALM");
    int rangeBuffer = isCalmRanging ? 8 : 5; // ‡∏Ç‡∏¢‡∏≤‡∏¢ buffer ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏•‡∏≤‡∏î‡πÄ‡∏á‡∏µ‡∏¢‡∏ö
    double calmLotMultiplier = isCalmRanging ? 0.7 : 1.0; // ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏ï‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏•‡∏≤‡∏î‡πÄ‡∏á‡∏µ‡∏¢‡∏ö
    
    int currentCountBuy = CountBuyOrders();
    int currentCountSell = CountSellOrders();
    
    // üî• ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Cooperative ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
    if(EnableCooperativeSystem) {
        ManageCooperativeStrategies();   // ‚úÖ ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
        DisplayCooperativeDashboard();   // ‚úÖ ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
    }
    
    // üî• ‡πÉ‡∏ä‡πâ RecoveryTarget ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏£‡∏∞‡∏ö‡∏ö
    double teamProfitTarget = RecoveryTarget;  // ‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
    bool teamAllowsNewTrades = EnableCooperativeSystem;
    
    // üî• ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏•‡πá‡∏≠‡∏ï (‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ï‡∏•‡∏≤‡∏î)
    double recoveryLot = CalculateSimpleRecoveryLot(totalProfit, marketCondition);
    recoveryLot *= calmLotMultiplier; // ‡∏õ‡∏£‡∏±‡∏ö‡∏•‡πá‡∏≠‡∏ï‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏•‡∏≤‡∏î‡πÄ‡∏á‡∏µ‡∏¢‡∏ö
    
    string tradingMode = GetSimpleTradingMode(totalProfit);
    
    Print("=== COOPERATIVE TRADING ===");
    Print("Team Target: ", teamProfitTarget, " | Market Regime: ", marketCondition);
    Print("Current P/L: ", totalProfit, " | Mode: ", tradingMode);
    Print("Calm Ranging: ", isCalmRanging ? "Yes" : "No", " | Buffer: ", rangeBuffer, " | Lot Multiplier: ", calmLotMultiplier);
    
    bool canOpenBuy = (currentCountBuy < MaxTrade);
    bool canOpenSell = (currentCountSell < MaxTrade);
    
    // üî• ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏û‡∏¥‡πÄ‡∏®‡∏©‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏•‡∏≤‡∏î‡πÄ‡∏á‡∏µ‡∏¢‡∏ö
    bool allowCalmTrading = isCalmRanging ? (totalProfit > -50) : true; // ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÄ‡∏ó‡∏£‡∏î‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡πÑ‡∏°‡πà‡∏°‡∏≤‡∏Å‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡πÄ‡∏á‡∏µ‡∏¢‡∏ö
    
    // üìà SELL Signal
    if((currentPrice >= rangeHigh - (rangeBuffer * _Point)) && canOpenSell && allowCalmTrading)
    {
        if(ShouldOpenTrade("SELL", marketCondition))
        {
            double finalLot = NormalizeDouble(recoveryLot, 2);
            OpenSellOrderWithLot(finalLot);
            
            // üî• ‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏£‡∏∞‡∏ö‡∏ö Cooperative (‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô)
            if(EnableCooperativeSystem) {
                ExecuteRecoveryCoordination();  // ‚úÖ ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
            }
            
            Print("üéØ COOP SELL | Regime: ", marketCondition, " | Mode: ", tradingMode);
            Print("Lot: ", finalLot, " | Target: ", RecoveryTarget, " | Price: ", currentPrice);
        }
    }
    
    // üìâ BUY Signal
    if((currentPrice <= rangeLow + (rangeBuffer * _Point)) && canOpenBuy && allowCalmTrading)
    {
        if(ShouldOpenTrade("BUY", marketCondition))
        {
            double finalLot = NormalizeDouble(recoveryLot, 2);
            OpenBuyOrderWithLot(finalLot);
            
            // üî• ‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏£‡∏∞‡∏ö‡∏ö Cooperative (‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô)
            if(EnableCooperativeSystem) {
                ExecuteRecoveryCoordination();  // ‚úÖ ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
            }
            
            Print("üéØ COOP BUY | Regime: ", marketCondition, " | Mode: ", tradingMode);
            Print("Lot: ", finalLot, " | Target: ", RecoveryTarget, " | Price: ", currentPrice);
        }
    }
    
    // üî• ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå
    if(!(currentPrice >= rangeHigh - (rangeBuffer * _Point) || currentPrice <= rangeLow + (rangeBuffer * _Point))) {
        Print("‚è∏Ô∏è Waiting for entry signal | Price: ", currentPrice, 
              " | Range: ", rangeLow, " - ", rangeHigh,
              " | Buffer: ¬±", rangeBuffer * _Point);
    }
}


void OpenBuyOrderWithLot(double lotSize)
{
   MqlTradeRequest request;
   MqlTradeResult result;
   ZeroMemory(request);
   ZeroMemory(result);
   
   request.action = TRADE_ACTION_DEAL;
   request.symbol = _Symbol;
   request.volume = NormalizeDouble(lotSize, 2);
   request.type = ORDER_TYPE_BUY;
   request.price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   request.deviation = 10;
   request.magic = 12345;
   
   // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Ç‡∏≠‡∏á OrderSend
   if(OrderSend(request, result))
   {
      Print("‚úÖ BUY Order opened successfully | Lot: ", lotSize, " | Ticket: ", result.order);
   }
   else
   {
      Print("‚ùå BUY Order failed | Error: ", GetLastError(), " | Lot: ", lotSize);
   }
}

void OpenSellOrderWithLot(double lotSize)
{
   MqlTradeRequest request;
   MqlTradeResult result;
   ZeroMemory(request);
   ZeroMemory(result);
   
   request.action = TRADE_ACTION_DEAL;
   request.symbol = _Symbol;
   request.volume = NormalizeDouble(lotSize, 2);
   request.type = ORDER_TYPE_SELL;
   request.price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   request.deviation = 10;
   request.magic = 12345;
   
   // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Ç‡∏≠‡∏á OrderSend
   if(OrderSend(request, result))
   {
      Print("‚úÖ SELL Order opened successfully | Lot: ", lotSize, " | Ticket: ", result.order);
   }
   else
   {
      Print("‚ùå SELL Order failed | Error: ", GetLastError(), " | Lot: ", lotSize);
   }
}
// üî• ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏±‡∏ö‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÉ‡∏´‡∏°‡πà
int CountBuyOrders()
{
    int count = 0;
    for(int i = 0; i < PositionsTotal(); i++)
    {
        if(PositionGetSymbol(i) == _Symbol && PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY)
            count++;
    }
    return count;
}

int CountSellOrders()
{
    int count = 0;
    for(int i = 0; i < PositionsTotal(); i++)
    {
        if(PositionGetSymbol(i) == _Symbol && PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL)
            count++;
    }
    return count;
}
// üî• ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà UseRangeStrategy() ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ
double GetRangeHigh()
{
    double highBuffer[];
    ArraySetAsSeries(highBuffer, true);
    CopyHigh(_Symbol, _Period, 0, 20, highBuffer); // ‡πÉ‡∏ä‡πâ 20 ‡πÅ‡∏ó‡πà‡∏á‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á
    
    return highBuffer[ArrayMaximum(highBuffer, 0, 20)];
}

double GetRangeLow()
{
    double lowBuffer[];
    ArraySetAsSeries(lowBuffer, true);
    CopyLow(_Symbol, _Period, 0, 20, lowBuffer); // ‡πÉ‡∏ä‡πâ 20 ‡πÅ‡∏ó‡πà‡∏á‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á
    
    return lowBuffer[ArrayMinimum(lowBuffer, 0, 20)];
}
void UseVolatileMarketStrategy()
{
    // ‡πÉ‡∏ä‡πâ‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏£‡∏∞‡∏°‡∏±‡∏î‡∏£‡∏∞‡∏ß‡∏±‡∏á‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
    // ‚úÖ ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏õ‡∏Å‡∏ï‡∏¥‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
    // ‚úÖ ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏•‡∏î‡∏•‡πá‡∏≠‡∏ï ‡πÅ‡∏ï‡πà‡πÄ‡∏õ‡∏¥‡∏î‡∏ô‡πâ‡∏≠‡∏¢‡∏•‡∏á‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î
    
    if(CountBuy < (MaxTrade / 2) && IsUptrend() && CalculateTotalProfit() > -20)
    {
        OpenBuyOrder(); // ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏õ‡∏Å‡∏ï‡∏¥
        Print("Cautious BUY in volatile market");
    }
    else if(CountSell < (MaxTrade / 2) && IsDowntrend() && CalculateTotalProfit() > -20)
    {
        OpenSellOrder(); // ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏õ‡∏Å‡∏ï‡∏¥
        Print("Cautious SELL in volatile market");
    }
}
